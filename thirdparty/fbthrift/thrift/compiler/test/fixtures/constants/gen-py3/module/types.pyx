#
# Autogenerated by Thrift
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#  @generated
#

from libcpp.memory cimport shared_ptr, make_shared, unique_ptr, make_unique
from libcpp.string cimport string
from libcpp cimport bool as cbool
from libcpp.iterator cimport inserter as cinserter
from cpython cimport bool as pbool
from libc.stdint cimport int8_t, int16_t, int32_t, int64_t, uint32_t
from cython.operator cimport dereference as deref, preincrement as inc, address as ptr_address
import thrift.py3.types
cimport thrift.py3.types
cimport thrift.py3.exceptions
from thrift.py3.types import NOTSET as __NOTSET
from thrift.py3.types cimport translate_cpp_enum_to_python
cimport thrift.py3.std_libcpp as std_libcpp
from thrift.py3.serializer import Protocol
cimport thrift.py3.serializer as serializer
from thrift.py3.serializer import deserialize, serialize
import folly.iobuf as __iobuf
from folly.optional cimport cOptional

import sys
import itertools
from collections import Sequence, Set, Mapping, Iterable
import enum as __enum
import warnings
import builtins as _builtins


class EmptyEnum(__enum.Enum):

    __hash__ = __enum.Enum.__hash__

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            warnings.warn(f"comparison not supported between instances of {type(self)} and {type(other)}", RuntimeWarning, stacklevel=2)
            return False
        return self.value == other.value

    def __int__(self):
        return self.value

cdef inline cEmptyEnum EmptyEnum_to_cpp(value):
    cdef int cvalue = value.value
    pass
class City(__enum.Enum):
    NYC = 0
    MPK = 1
    SEA = 2
    LON = 3

    __hash__ = __enum.Enum.__hash__

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            warnings.warn(f"comparison not supported between instances of {type(self)} and {type(other)}", RuntimeWarning, stacklevel=2)
            return False
        return self.value == other.value

    def __int__(self):
        return self.value

cdef inline cCity City_to_cpp(value):
    cdef int cvalue = value.value
    if cvalue == 0:
        return City__NYC
    elif cvalue == 1:
        return City__MPK
    elif cvalue == 2:
        return City__SEA
    elif cvalue == 3:
        return City__LON
class Company(__enum.Enum):
    FACEBOOK = 0
    WHATSAPP = 1
    OCULUS = 2
    INSTAGRAM = 3

    __hash__ = __enum.Enum.__hash__

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            warnings.warn(f"comparison not supported between instances of {type(self)} and {type(other)}", RuntimeWarning, stacklevel=2)
            return False
        return self.value == other.value

    def __int__(self):
        return self.value

cdef inline cCompany Company_to_cpp(value):
    cdef int cvalue = value.value
    if cvalue == 0:
        return Company__FACEBOOK
    elif cvalue == 1:
        return Company__WHATSAPP
    elif cvalue == 2:
        return Company__OCULUS
    elif cvalue == 3:
        return Company__INSTAGRAM


cdef cInternship _Internship_defaults = cInternship()

cdef class Internship(thrift.py3.types.Struct):

    def __init__(
        Internship self, *,
        weeks,
        str title=None,
        employer=None
    ):
        if weeks is not None:
            if not isinstance(weeks, int):
                raise TypeError(f'weeks is not a { int !r}.')
            weeks = <int32_t> weeks

        if employer is not None:
            if not isinstance(employer, Company):
                raise TypeError(f'field employer value: { employer !r} is not of the enum type { Company }.')

        self._cpp_obj = move(Internship._make_instance(
          NULL,
          weeks,
          title,
          employer,
        ))

    def __call__(
        Internship self,
        weeks=__NOTSET,
        title=__NOTSET,
        employer=__NOTSET
    ):
        changes = any((
            weeks is not __NOTSET,

            title is not __NOTSET,

            employer is not __NOTSET,
        ))

        if not changes:
            return self

        if weeks is None:
            raise TypeError('field weeks is required and has no default, it can not be unset')
        if None is not weeks is not __NOTSET:
            if not isinstance(weeks, int):
                raise TypeError(f'weeks is not a { int !r}.')
            weeks = <int32_t> weeks

        if None is not title is not __NOTSET:
            if not isinstance(title, str):
                raise TypeError(f'title is not a { str !r}.')

        if None is not employer is not __NOTSET:
            if not isinstance(employer, Company):
                raise TypeError(f'field employer value: { employer !r} is not of the enum type { Company }.')

        inst = <Internship>Internship.__new__(Internship)
        inst._cpp_obj = move(Internship._make_instance(
          self._cpp_obj.get(),
          weeks,
          title,
          employer,
        ))
        return inst

    @staticmethod
    cdef unique_ptr[cInternship] _make_instance(
        cInternship* base_instance,
        object weeks,
        object title,
        object employer
    ) except *:
        cdef unique_ptr[cInternship] c_inst
        if base_instance:
            c_inst = make_unique[cInternship](deref(base_instance))
        else:
            c_inst = make_unique[cInternship]()

        if base_instance:
            # Convert None's to default value. (or unset)
            if weeks is None:
                pass
            elif weeks is __NOTSET:
                weeks = None

            if title is None:
                deref(c_inst).title = _Internship_defaults.title
                deref(c_inst).__isset.title = False
                pass
            elif title is __NOTSET:
                title = None

            if employer is None:
                deref(c_inst).__isset.employer = False
                pass
            elif employer is __NOTSET:
                employer = None

        if weeks is not None:
            deref(c_inst).weeks = weeks
        if title is not None:
            deref(c_inst).title = title.encode('UTF-8')
            deref(c_inst).__isset.title = True
        if employer is not None:
            deref(c_inst).employer = Company_to_cpp(employer)
            deref(c_inst).__isset.employer = True
        # in C++ you don't have to call move(), but this doesn't translate
        # into a C++ return statement, so you do here
        return move_unique(c_inst)

    def __iter__(self):
        yield 'weeks', self.weeks
        yield 'title', self.title
        yield 'employer', self.employer

    def __bool__(self):
        return True or True or deref(self._cpp_obj).__isset.employer

    @staticmethod
    cdef create(shared_ptr[cInternship] cpp_obj):
        inst = <Internship>Internship.__new__(Internship)
        inst._cpp_obj = cpp_obj
        return inst

    @property
    def weeks(self):

        return self._cpp_obj.get().weeks

    @property
    def title(self):

        return (<bytes>self._cpp_obj.get().title).decode('UTF-8')

    @property
    def employer(self):
        if not deref(self._cpp_obj).__isset.employer:
            return None

        return translate_cpp_enum_to_python(Company, <int>(deref(self._cpp_obj).employer))


    def __hash__(Internship self):
        if not self.__hash:
            self.__hash = hash((
            self.weeks,
            self.title,
            self.employer,
            ))
        return self.__hash

    def __repr__(Internship self):
        return f'Internship(weeks={repr(self.weeks)}, title={repr(self.title)}, employer={repr(self.employer)})'
    def __richcmp__(self, other, op):
        cdef int cop = op
        if cop not in (2, 3):
            raise TypeError("unorderable types: {}, {}".format(self, other))
        if not (
                isinstance(self, Internship) and
                isinstance(other, Internship)):
            if cop == 2:  # different types are never equal
                return False
            else:         # different types are always notequal
                return True

        cdef cInternship cself = deref((<Internship>self)._cpp_obj)
        cdef cInternship cother = deref((<Internship>other)._cpp_obj)
        cdef cbool cmp = cself == cother
        if cop == 2:
            return cmp
        return not cmp

    cdef __iobuf.IOBuf _serialize(Internship self, proto):
        cdef __iobuf.cIOBufQueue queue = __iobuf.cIOBufQueue(__iobuf.cacheChainLength())
        cdef cInternship* cpp_obj = self._cpp_obj.get()
        if proto is Protocol.COMPACT:
            with nogil:
                serializer.CompactSerialize[cInternship](deref(cpp_obj), &queue, serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is Protocol.BINARY:
            with nogil:
                serializer.BinarySerialize[cInternship](deref(cpp_obj), &queue, serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is Protocol.JSON:
            with nogil:
                serializer.JSONSerialize[cInternship](deref(cpp_obj), &queue, serializer.SHARE_EXTERNAL_BUFFER)
        return __iobuf.from_unique_ptr(queue.move())

    cdef uint32_t _deserialize(Internship self, const __iobuf.cIOBuf* buf, proto) except? 0:
        cdef uint32_t needed
        self._cpp_obj = make_shared[cInternship]()
        cdef cInternship* cpp_obj = self._cpp_obj.get()
        if proto is Protocol.COMPACT:
            with nogil:
                needed = serializer.CompactDeserialize[cInternship](buf, deref(cpp_obj), serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is Protocol.BINARY:
            with nogil:
                needed = serializer.BinaryDeserialize[cInternship](buf, deref(cpp_obj), serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is Protocol.JSON:
            with nogil:
                needed = serializer.JSONDeserialize[cInternship](buf, deref(cpp_obj), serializer.SHARE_EXTERNAL_BUFFER)
        return needed

    def __reduce__(self):
        return (deserialize, (Internship, serialize(self)))


cdef cUnEnumStruct _UnEnumStruct_defaults = cUnEnumStruct()

cdef class UnEnumStruct(thrift.py3.types.Struct):

    def __init__(
        UnEnumStruct self, *,
        city=None
    ):
        if city is not None:
            if not isinstance(city, City):
                raise TypeError(f'field city value: { city !r} is not of the enum type { City }.')

        self._cpp_obj = move(UnEnumStruct._make_instance(
          NULL,
          city,
        ))

    def __call__(
        UnEnumStruct self,
        city=__NOTSET
    ):
        changes = any((
            city is not __NOTSET,
        ))

        if not changes:
            return self

        if None is not city is not __NOTSET:
            if not isinstance(city, City):
                raise TypeError(f'field city value: { city !r} is not of the enum type { City }.')

        inst = <UnEnumStruct>UnEnumStruct.__new__(UnEnumStruct)
        inst._cpp_obj = move(UnEnumStruct._make_instance(
          self._cpp_obj.get(),
          city,
        ))
        return inst

    @staticmethod
    cdef unique_ptr[cUnEnumStruct] _make_instance(
        cUnEnumStruct* base_instance,
        object city
    ) except *:
        cdef unique_ptr[cUnEnumStruct] c_inst
        if base_instance:
            c_inst = make_unique[cUnEnumStruct](deref(base_instance))
        else:
            c_inst = make_unique[cUnEnumStruct]()

        if base_instance:
            # Convert None's to default value. (or unset)
            if city is None:
                deref(c_inst).city = _UnEnumStruct_defaults.city
                deref(c_inst).__isset.city = False
                pass
            elif city is __NOTSET:
                city = None

        if city is not None:
            deref(c_inst).city = City_to_cpp(city)
            deref(c_inst).__isset.city = True
        # in C++ you don't have to call move(), but this doesn't translate
        # into a C++ return statement, so you do here
        return move_unique(c_inst)

    def __iter__(self):
        yield 'city', self.city

    def __bool__(self):
        return True

    @staticmethod
    cdef create(shared_ptr[cUnEnumStruct] cpp_obj):
        inst = <UnEnumStruct>UnEnumStruct.__new__(UnEnumStruct)
        inst._cpp_obj = cpp_obj
        return inst

    @property
    def city(self):

        return translate_cpp_enum_to_python(City, <int>(deref(self._cpp_obj).city))


    def __hash__(UnEnumStruct self):
        if not self.__hash:
            self.__hash = hash((
            self.city,
            ))
        return self.__hash

    def __repr__(UnEnumStruct self):
        return f'UnEnumStruct(city={repr(self.city)})'
    def __richcmp__(self, other, op):
        cdef int cop = op
        if cop not in (2, 3):
            raise TypeError("unorderable types: {}, {}".format(self, other))
        if not (
                isinstance(self, UnEnumStruct) and
                isinstance(other, UnEnumStruct)):
            if cop == 2:  # different types are never equal
                return False
            else:         # different types are always notequal
                return True

        cdef cUnEnumStruct cself = deref((<UnEnumStruct>self)._cpp_obj)
        cdef cUnEnumStruct cother = deref((<UnEnumStruct>other)._cpp_obj)
        cdef cbool cmp = cself == cother
        if cop == 2:
            return cmp
        return not cmp

    cdef __iobuf.IOBuf _serialize(UnEnumStruct self, proto):
        cdef __iobuf.cIOBufQueue queue = __iobuf.cIOBufQueue(__iobuf.cacheChainLength())
        cdef cUnEnumStruct* cpp_obj = self._cpp_obj.get()
        if proto is Protocol.COMPACT:
            with nogil:
                serializer.CompactSerialize[cUnEnumStruct](deref(cpp_obj), &queue, serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is Protocol.BINARY:
            with nogil:
                serializer.BinarySerialize[cUnEnumStruct](deref(cpp_obj), &queue, serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is Protocol.JSON:
            with nogil:
                serializer.JSONSerialize[cUnEnumStruct](deref(cpp_obj), &queue, serializer.SHARE_EXTERNAL_BUFFER)
        return __iobuf.from_unique_ptr(queue.move())

    cdef uint32_t _deserialize(UnEnumStruct self, const __iobuf.cIOBuf* buf, proto) except? 0:
        cdef uint32_t needed
        self._cpp_obj = make_shared[cUnEnumStruct]()
        cdef cUnEnumStruct* cpp_obj = self._cpp_obj.get()
        if proto is Protocol.COMPACT:
            with nogil:
                needed = serializer.CompactDeserialize[cUnEnumStruct](buf, deref(cpp_obj), serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is Protocol.BINARY:
            with nogil:
                needed = serializer.BinaryDeserialize[cUnEnumStruct](buf, deref(cpp_obj), serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is Protocol.JSON:
            with nogil:
                needed = serializer.JSONDeserialize[cUnEnumStruct](buf, deref(cpp_obj), serializer.SHARE_EXTERNAL_BUFFER)
        return needed

    def __reduce__(self):
        return (deserialize, (UnEnumStruct, serialize(self)))


cdef cRange _Range_defaults = cRange()

cdef class Range(thrift.py3.types.Struct):

    def __init__(
        Range self, *,
        min,
        max
    ):
        if min is not None:
            if not isinstance(min, int):
                raise TypeError(f'min is not a { int !r}.')
            min = <int32_t> min

        if max is not None:
            if not isinstance(max, int):
                raise TypeError(f'max is not a { int !r}.')
            max = <int32_t> max

        self._cpp_obj = move(Range._make_instance(
          NULL,
          min,
          max,
        ))

    def __call__(
        Range self,
        min=__NOTSET,
        max=__NOTSET
    ):
        changes = any((
            min is not __NOTSET,

            max is not __NOTSET,
        ))

        if not changes:
            return self

        if min is None:
            raise TypeError('field min is required and has no default, it can not be unset')
        if None is not min is not __NOTSET:
            if not isinstance(min, int):
                raise TypeError(f'min is not a { int !r}.')
            min = <int32_t> min

        if max is None:
            raise TypeError('field max is required and has no default, it can not be unset')
        if None is not max is not __NOTSET:
            if not isinstance(max, int):
                raise TypeError(f'max is not a { int !r}.')
            max = <int32_t> max

        inst = <Range>Range.__new__(Range)
        inst._cpp_obj = move(Range._make_instance(
          self._cpp_obj.get(),
          min,
          max,
        ))
        return inst

    @staticmethod
    cdef unique_ptr[cRange] _make_instance(
        cRange* base_instance,
        object min,
        object max
    ) except *:
        cdef unique_ptr[cRange] c_inst
        if base_instance:
            c_inst = make_unique[cRange](deref(base_instance))
        else:
            c_inst = make_unique[cRange]()

        if base_instance:
            # Convert None's to default value. (or unset)
            if min is None:
                pass
            elif min is __NOTSET:
                min = None

            if max is None:
                pass
            elif max is __NOTSET:
                max = None

        if min is not None:
            deref(c_inst).min = min
        if max is not None:
            deref(c_inst).max = max
        # in C++ you don't have to call move(), but this doesn't translate
        # into a C++ return statement, so you do here
        return move_unique(c_inst)

    def __iter__(self):
        yield 'min', self.min
        yield 'max', self.max

    def __bool__(self):
        return True or True

    @staticmethod
    cdef create(shared_ptr[cRange] cpp_obj):
        inst = <Range>Range.__new__(Range)
        inst._cpp_obj = cpp_obj
        return inst

    @property
    def min(self):

        return self._cpp_obj.get().min

    @property
    def max(self):

        return self._cpp_obj.get().max


    def __hash__(Range self):
        if not self.__hash:
            self.__hash = hash((
            self.min,
            self.max,
            ))
        return self.__hash

    def __repr__(Range self):
        return f'Range(min={repr(self.min)}, max={repr(self.max)})'
    def __richcmp__(self, other, op):
        cdef int cop = op
        if cop not in (2, 3):
            raise TypeError("unorderable types: {}, {}".format(self, other))
        if not (
                isinstance(self, Range) and
                isinstance(other, Range)):
            if cop == 2:  # different types are never equal
                return False
            else:         # different types are always notequal
                return True

        cdef cRange cself = deref((<Range>self)._cpp_obj)
        cdef cRange cother = deref((<Range>other)._cpp_obj)
        cdef cbool cmp = cself == cother
        if cop == 2:
            return cmp
        return not cmp

    cdef __iobuf.IOBuf _serialize(Range self, proto):
        cdef __iobuf.cIOBufQueue queue = __iobuf.cIOBufQueue(__iobuf.cacheChainLength())
        cdef cRange* cpp_obj = self._cpp_obj.get()
        if proto is Protocol.COMPACT:
            with nogil:
                serializer.CompactSerialize[cRange](deref(cpp_obj), &queue, serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is Protocol.BINARY:
            with nogil:
                serializer.BinarySerialize[cRange](deref(cpp_obj), &queue, serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is Protocol.JSON:
            with nogil:
                serializer.JSONSerialize[cRange](deref(cpp_obj), &queue, serializer.SHARE_EXTERNAL_BUFFER)
        return __iobuf.from_unique_ptr(queue.move())

    cdef uint32_t _deserialize(Range self, const __iobuf.cIOBuf* buf, proto) except? 0:
        cdef uint32_t needed
        self._cpp_obj = make_shared[cRange]()
        cdef cRange* cpp_obj = self._cpp_obj.get()
        if proto is Protocol.COMPACT:
            with nogil:
                needed = serializer.CompactDeserialize[cRange](buf, deref(cpp_obj), serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is Protocol.BINARY:
            with nogil:
                needed = serializer.BinaryDeserialize[cRange](buf, deref(cpp_obj), serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is Protocol.JSON:
            with nogil:
                needed = serializer.JSONDeserialize[cRange](buf, deref(cpp_obj), serializer.SHARE_EXTERNAL_BUFFER)
        return needed

    def __reduce__(self):
        return (deserialize, (Range, serialize(self)))


cdef cstruct1 _struct1_defaults = cstruct1()

cdef class struct1(thrift.py3.types.Struct):

    def __init__(
        struct1 self, *,
        a=None,
        str b=None
    ):
        if a is not None:
            if not isinstance(a, int):
                raise TypeError(f'a is not a { int !r}.')
            a = <int32_t> a

        self._cpp_obj = move(struct1._make_instance(
          NULL,
          a,
          b,
        ))

    def __call__(
        struct1 self,
        a=__NOTSET,
        b=__NOTSET
    ):
        changes = any((
            a is not __NOTSET,

            b is not __NOTSET,
        ))

        if not changes:
            return self

        if None is not a is not __NOTSET:
            if not isinstance(a, int):
                raise TypeError(f'a is not a { int !r}.')
            a = <int32_t> a

        if None is not b is not __NOTSET:
            if not isinstance(b, str):
                raise TypeError(f'b is not a { str !r}.')

        inst = <struct1>struct1.__new__(struct1)
        inst._cpp_obj = move(struct1._make_instance(
          self._cpp_obj.get(),
          a,
          b,
        ))
        return inst

    @staticmethod
    cdef unique_ptr[cstruct1] _make_instance(
        cstruct1* base_instance,
        object a,
        object b
    ) except *:
        cdef unique_ptr[cstruct1] c_inst
        if base_instance:
            c_inst = make_unique[cstruct1](deref(base_instance))
        else:
            c_inst = make_unique[cstruct1]()

        if base_instance:
            # Convert None's to default value. (or unset)
            if a is None:
                deref(c_inst).a = _struct1_defaults.a
                deref(c_inst).__isset.a = False
                pass
            elif a is __NOTSET:
                a = None

            if b is None:
                deref(c_inst).b = _struct1_defaults.b
                deref(c_inst).__isset.b = False
                pass
            elif b is __NOTSET:
                b = None

        if a is not None:
            deref(c_inst).a = a
            deref(c_inst).__isset.a = True
        if b is not None:
            deref(c_inst).b = b.encode('UTF-8')
            deref(c_inst).__isset.b = True
        # in C++ you don't have to call move(), but this doesn't translate
        # into a C++ return statement, so you do here
        return move_unique(c_inst)

    def __iter__(self):
        yield 'a', self.a
        yield 'b', self.b

    def __bool__(self):
        return True or True

    @staticmethod
    cdef create(shared_ptr[cstruct1] cpp_obj):
        inst = <struct1>struct1.__new__(struct1)
        inst._cpp_obj = cpp_obj
        return inst

    @property
    def a(self):

        return self._cpp_obj.get().a

    @property
    def b(self):

        return (<bytes>self._cpp_obj.get().b).decode('UTF-8')


    def __hash__(struct1 self):
        if not self.__hash:
            self.__hash = hash((
            self.a,
            self.b,
            ))
        return self.__hash

    def __repr__(struct1 self):
        return f'struct1(a={repr(self.a)}, b={repr(self.b)})'
    def __richcmp__(self, other, op):
        cdef int cop = op
        if cop not in (2, 3):
            raise TypeError("unorderable types: {}, {}".format(self, other))
        if not (
                isinstance(self, struct1) and
                isinstance(other, struct1)):
            if cop == 2:  # different types are never equal
                return False
            else:         # different types are always notequal
                return True

        cdef cstruct1 cself = deref((<struct1>self)._cpp_obj)
        cdef cstruct1 cother = deref((<struct1>other)._cpp_obj)
        cdef cbool cmp = cself == cother
        if cop == 2:
            return cmp
        return not cmp

    cdef __iobuf.IOBuf _serialize(struct1 self, proto):
        cdef __iobuf.cIOBufQueue queue = __iobuf.cIOBufQueue(__iobuf.cacheChainLength())
        cdef cstruct1* cpp_obj = self._cpp_obj.get()
        if proto is Protocol.COMPACT:
            with nogil:
                serializer.CompactSerialize[cstruct1](deref(cpp_obj), &queue, serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is Protocol.BINARY:
            with nogil:
                serializer.BinarySerialize[cstruct1](deref(cpp_obj), &queue, serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is Protocol.JSON:
            with nogil:
                serializer.JSONSerialize[cstruct1](deref(cpp_obj), &queue, serializer.SHARE_EXTERNAL_BUFFER)
        return __iobuf.from_unique_ptr(queue.move())

    cdef uint32_t _deserialize(struct1 self, const __iobuf.cIOBuf* buf, proto) except? 0:
        cdef uint32_t needed
        self._cpp_obj = make_shared[cstruct1]()
        cdef cstruct1* cpp_obj = self._cpp_obj.get()
        if proto is Protocol.COMPACT:
            with nogil:
                needed = serializer.CompactDeserialize[cstruct1](buf, deref(cpp_obj), serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is Protocol.BINARY:
            with nogil:
                needed = serializer.BinaryDeserialize[cstruct1](buf, deref(cpp_obj), serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is Protocol.JSON:
            with nogil:
                needed = serializer.JSONDeserialize[cstruct1](buf, deref(cpp_obj), serializer.SHARE_EXTERNAL_BUFFER)
        return needed

    def __reduce__(self):
        return (deserialize, (struct1, serialize(self)))


cdef cstruct2 _struct2_defaults = cstruct2()

cdef class struct2(thrift.py3.types.Struct):

    def __init__(
        struct2 self, *,
        a=None,
        str b=None,
        struct1 c=None,
        d=None
    ):
        if a is not None:
            if not isinstance(a, int):
                raise TypeError(f'a is not a { int !r}.')
            a = <int32_t> a

        self._cpp_obj = move(struct2._make_instance(
          NULL,
          a,
          b,
          c,
          d,
        ))

    def __call__(
        struct2 self,
        a=__NOTSET,
        b=__NOTSET,
        c=__NOTSET,
        d=__NOTSET
    ):
        changes = any((
            a is not __NOTSET,

            b is not __NOTSET,

            c is not __NOTSET,

            d is not __NOTSET,
        ))

        if not changes:
            return self

        if None is not a is not __NOTSET:
            if not isinstance(a, int):
                raise TypeError(f'a is not a { int !r}.')
            a = <int32_t> a

        if None is not b is not __NOTSET:
            if not isinstance(b, str):
                raise TypeError(f'b is not a { str !r}.')

        if None is not c is not __NOTSET:
            if not isinstance(c, struct1):
                raise TypeError(f'c is not a { struct1 !r}.')

        inst = <struct2>struct2.__new__(struct2)
        inst._cpp_obj = move(struct2._make_instance(
          self._cpp_obj.get(),
          a,
          b,
          c,
          d,
        ))
        return inst

    @staticmethod
    cdef unique_ptr[cstruct2] _make_instance(
        cstruct2* base_instance,
        object a,
        object b,
        object c,
        object d
    ) except *:
        cdef unique_ptr[cstruct2] c_inst
        if base_instance:
            c_inst = make_unique[cstruct2](deref(base_instance))
        else:
            c_inst = make_unique[cstruct2]()

        if base_instance:
            # Convert None's to default value. (or unset)
            if a is None:
                deref(c_inst).a = _struct2_defaults.a
                deref(c_inst).__isset.a = False
                pass
            elif a is __NOTSET:
                a = None

            if b is None:
                deref(c_inst).b = _struct2_defaults.b
                deref(c_inst).__isset.b = False
                pass
            elif b is __NOTSET:
                b = None

            if c is None:
                deref(c_inst).c = _struct2_defaults.c
                deref(c_inst).__isset.c = False
                pass
            elif c is __NOTSET:
                c = None

            if d is None:
                deref(c_inst).d = _struct2_defaults.d
                deref(c_inst).__isset.d = False
                pass
            elif d is __NOTSET:
                d = None

        if a is not None:
            deref(c_inst).a = a
            deref(c_inst).__isset.a = True
        if b is not None:
            deref(c_inst).b = b.encode('UTF-8')
            deref(c_inst).__isset.b = True
        if c is not None:
            deref(c_inst).c = deref((<struct1?> c)._cpp_obj)
            deref(c_inst).__isset.c = True
        if d is not None:
            deref(c_inst).d = deref(List__i32(d)._cpp_obj)
            deref(c_inst).__isset.d = True
        # in C++ you don't have to call move(), but this doesn't translate
        # into a C++ return statement, so you do here
        return move_unique(c_inst)

    def __iter__(self):
        yield 'a', self.a
        yield 'b', self.b
        yield 'c', self.c
        yield 'd', self.d

    def __bool__(self):
        return True or True or True or True

    @staticmethod
    cdef create(shared_ptr[cstruct2] cpp_obj):
        inst = <struct2>struct2.__new__(struct2)
        inst._cpp_obj = cpp_obj
        return inst

    @property
    def a(self):

        return self._cpp_obj.get().a

    @property
    def b(self):

        return (<bytes>self._cpp_obj.get().b).decode('UTF-8')

    @property
    def c(self):

        if self.__c is None:
            self.__c = struct1.create(make_shared[cstruct1](deref(self._cpp_obj).c))
        return self.__c

    @property
    def d(self):

        if self.__d is None:
            self.__d = List__i32.create(make_shared[vector[int32_t]](deref(self._cpp_obj).d))
        return self.__d


    def __hash__(struct2 self):
        if not self.__hash:
            self.__hash = hash((
            self.a,
            self.b,
            self.c,
            self.d,
            ))
        return self.__hash

    def __repr__(struct2 self):
        return f'struct2(a={repr(self.a)}, b={repr(self.b)}, c={repr(self.c)}, d={repr(self.d)})'
    def __richcmp__(self, other, op):
        cdef int cop = op
        if cop not in (2, 3):
            raise TypeError("unorderable types: {}, {}".format(self, other))
        if not (
                isinstance(self, struct2) and
                isinstance(other, struct2)):
            if cop == 2:  # different types are never equal
                return False
            else:         # different types are always notequal
                return True

        cdef cstruct2 cself = deref((<struct2>self)._cpp_obj)
        cdef cstruct2 cother = deref((<struct2>other)._cpp_obj)
        cdef cbool cmp = cself == cother
        if cop == 2:
            return cmp
        return not cmp

    cdef __iobuf.IOBuf _serialize(struct2 self, proto):
        cdef __iobuf.cIOBufQueue queue = __iobuf.cIOBufQueue(__iobuf.cacheChainLength())
        cdef cstruct2* cpp_obj = self._cpp_obj.get()
        if proto is Protocol.COMPACT:
            with nogil:
                serializer.CompactSerialize[cstruct2](deref(cpp_obj), &queue, serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is Protocol.BINARY:
            with nogil:
                serializer.BinarySerialize[cstruct2](deref(cpp_obj), &queue, serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is Protocol.JSON:
            with nogil:
                serializer.JSONSerialize[cstruct2](deref(cpp_obj), &queue, serializer.SHARE_EXTERNAL_BUFFER)
        return __iobuf.from_unique_ptr(queue.move())

    cdef uint32_t _deserialize(struct2 self, const __iobuf.cIOBuf* buf, proto) except? 0:
        cdef uint32_t needed
        self._cpp_obj = make_shared[cstruct2]()
        cdef cstruct2* cpp_obj = self._cpp_obj.get()
        if proto is Protocol.COMPACT:
            with nogil:
                needed = serializer.CompactDeserialize[cstruct2](buf, deref(cpp_obj), serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is Protocol.BINARY:
            with nogil:
                needed = serializer.BinaryDeserialize[cstruct2](buf, deref(cpp_obj), serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is Protocol.JSON:
            with nogil:
                needed = serializer.JSONDeserialize[cstruct2](buf, deref(cpp_obj), serializer.SHARE_EXTERNAL_BUFFER)
        return needed

    def __reduce__(self):
        return (deserialize, (struct2, serialize(self)))


cdef cstruct3 _struct3_defaults = cstruct3()

cdef class struct3(thrift.py3.types.Struct):

    def __init__(
        struct3 self, *,
        str a=None,
        b=None,
        struct2 c=None
    ):
        if b is not None:
            if not isinstance(b, int):
                raise TypeError(f'b is not a { int !r}.')
            b = <int32_t> b

        self._cpp_obj = move(struct3._make_instance(
          NULL,
          a,
          b,
          c,
        ))

    def __call__(
        struct3 self,
        a=__NOTSET,
        b=__NOTSET,
        c=__NOTSET
    ):
        changes = any((
            a is not __NOTSET,

            b is not __NOTSET,

            c is not __NOTSET,
        ))

        if not changes:
            return self

        if None is not a is not __NOTSET:
            if not isinstance(a, str):
                raise TypeError(f'a is not a { str !r}.')

        if None is not b is not __NOTSET:
            if not isinstance(b, int):
                raise TypeError(f'b is not a { int !r}.')
            b = <int32_t> b

        if None is not c is not __NOTSET:
            if not isinstance(c, struct2):
                raise TypeError(f'c is not a { struct2 !r}.')

        inst = <struct3>struct3.__new__(struct3)
        inst._cpp_obj = move(struct3._make_instance(
          self._cpp_obj.get(),
          a,
          b,
          c,
        ))
        return inst

    @staticmethod
    cdef unique_ptr[cstruct3] _make_instance(
        cstruct3* base_instance,
        object a,
        object b,
        object c
    ) except *:
        cdef unique_ptr[cstruct3] c_inst
        if base_instance:
            c_inst = make_unique[cstruct3](deref(base_instance))
        else:
            c_inst = make_unique[cstruct3]()

        if base_instance:
            # Convert None's to default value. (or unset)
            if a is None:
                deref(c_inst).a = _struct3_defaults.a
                deref(c_inst).__isset.a = False
                pass
            elif a is __NOTSET:
                a = None

            if b is None:
                deref(c_inst).b = _struct3_defaults.b
                deref(c_inst).__isset.b = False
                pass
            elif b is __NOTSET:
                b = None

            if c is None:
                deref(c_inst).c = _struct3_defaults.c
                deref(c_inst).__isset.c = False
                pass
            elif c is __NOTSET:
                c = None

        if a is not None:
            deref(c_inst).a = a.encode('UTF-8')
            deref(c_inst).__isset.a = True
        if b is not None:
            deref(c_inst).b = b
            deref(c_inst).__isset.b = True
        if c is not None:
            deref(c_inst).c = deref((<struct2?> c)._cpp_obj)
            deref(c_inst).__isset.c = True
        # in C++ you don't have to call move(), but this doesn't translate
        # into a C++ return statement, so you do here
        return move_unique(c_inst)

    def __iter__(self):
        yield 'a', self.a
        yield 'b', self.b
        yield 'c', self.c

    def __bool__(self):
        return True or True or True

    @staticmethod
    cdef create(shared_ptr[cstruct3] cpp_obj):
        inst = <struct3>struct3.__new__(struct3)
        inst._cpp_obj = cpp_obj
        return inst

    @property
    def a(self):

        return (<bytes>self._cpp_obj.get().a).decode('UTF-8')

    @property
    def b(self):

        return self._cpp_obj.get().b

    @property
    def c(self):

        if self.__c is None:
            self.__c = struct2.create(make_shared[cstruct2](deref(self._cpp_obj).c))
        return self.__c


    def __hash__(struct3 self):
        if not self.__hash:
            self.__hash = hash((
            self.a,
            self.b,
            self.c,
            ))
        return self.__hash

    def __repr__(struct3 self):
        return f'struct3(a={repr(self.a)}, b={repr(self.b)}, c={repr(self.c)})'
    def __richcmp__(self, other, op):
        cdef int cop = op
        if cop not in (2, 3):
            raise TypeError("unorderable types: {}, {}".format(self, other))
        if not (
                isinstance(self, struct3) and
                isinstance(other, struct3)):
            if cop == 2:  # different types are never equal
                return False
            else:         # different types are always notequal
                return True

        cdef cstruct3 cself = deref((<struct3>self)._cpp_obj)
        cdef cstruct3 cother = deref((<struct3>other)._cpp_obj)
        cdef cbool cmp = cself == cother
        if cop == 2:
            return cmp
        return not cmp

    cdef __iobuf.IOBuf _serialize(struct3 self, proto):
        cdef __iobuf.cIOBufQueue queue = __iobuf.cIOBufQueue(__iobuf.cacheChainLength())
        cdef cstruct3* cpp_obj = self._cpp_obj.get()
        if proto is Protocol.COMPACT:
            with nogil:
                serializer.CompactSerialize[cstruct3](deref(cpp_obj), &queue, serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is Protocol.BINARY:
            with nogil:
                serializer.BinarySerialize[cstruct3](deref(cpp_obj), &queue, serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is Protocol.JSON:
            with nogil:
                serializer.JSONSerialize[cstruct3](deref(cpp_obj), &queue, serializer.SHARE_EXTERNAL_BUFFER)
        return __iobuf.from_unique_ptr(queue.move())

    cdef uint32_t _deserialize(struct3 self, const __iobuf.cIOBuf* buf, proto) except? 0:
        cdef uint32_t needed
        self._cpp_obj = make_shared[cstruct3]()
        cdef cstruct3* cpp_obj = self._cpp_obj.get()
        if proto is Protocol.COMPACT:
            with nogil:
                needed = serializer.CompactDeserialize[cstruct3](buf, deref(cpp_obj), serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is Protocol.BINARY:
            with nogil:
                needed = serializer.BinaryDeserialize[cstruct3](buf, deref(cpp_obj), serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is Protocol.JSON:
            with nogil:
                needed = serializer.JSONDeserialize[cstruct3](buf, deref(cpp_obj), serializer.SHARE_EXTERNAL_BUFFER)
        return needed

    def __reduce__(self):
        return (deserialize, (struct3, serialize(self)))


class __union1Type(__enum.Enum):
    EMPTY = <int>cunion1__type___EMPTY__
    i = <int>cunion1__type_i
    d = <int>cunion1__type_d


cdef class union1(thrift.py3.types.Union):
    Type = __union1Type

    def __init__(
        self, *,
        i=None,
        d=None
    ):
        if i is not None:
            if not isinstance(i, int):
                raise TypeError(f'i is not a { int !r}.')
            i = <int32_t> i

        if d is not None:
            if not isinstance(d, (float, int)):
                raise TypeError(f'd is not a { float !r}.')

        self._cpp_obj = move(union1._make_instance(
          NULL,
          i,
          d,
        ))
        self._load_cache()

    @staticmethod
    def fromValue(value):
        if value is None:
            return union1()
        if isinstance(value, int):
            if not isinstance(value, pbool):
                try:
                    <int32_t> value
                    return union1(i=value)
                except OverflowError:
                    pass
        if isinstance(value, float):
            if not isinstance(value, pbool):
                try:
                    return union1(d=value)
                except OverflowError:
                    pass
        if isinstance(value, (float, int)):
            try:
                <double> value
                return union1(d=value)
            except OverflowError:
                pass
        raise ValueError(f"Unable to derive correct union field for value: {value}")

    @staticmethod
    cdef unique_ptr[cunion1] _make_instance(
        cunion1* base_instance,
        i,
        d
    ) except *:
        cdef unique_ptr[cunion1] c_inst = make_unique[cunion1]()
        cdef bint any_set = False
        if i is not None:
            if any_set:
                raise TypeError("At most one field may be set when initializing a union")
            deref(c_inst).set_i(i)
            any_set = True
        if d is not None:
            if any_set:
                raise TypeError("At most one field may be set when initializing a union")
            deref(c_inst).set_d(d)
            any_set = True
        # in C++ you don't have to call move(), but this doesn't translate
        # into a C++ return statement, so you do here
        return move_unique(c_inst)

    def __bool__(self):
        return self.type != union1.Type.EMPTY

    @staticmethod
    cdef create(shared_ptr[cunion1] cpp_obj):
        inst = <union1>union1.__new__(union1)
        inst._cpp_obj = cpp_obj
        inst._load_cache()
        return inst

    @property
    def i(self):
        if self.type != union1.Type.i:
            raise TypeError(f'Union contains a value of type {self.type.name}, not i')
        return self.value

    @property
    def d(self):
        if self.type != union1.Type.d:
            raise TypeError(f'Union contains a value of type {self.type.name}, not d')
        return self.value


    def __hash__(union1 self):
        if not self.__hash:
            self.__hash = hash((
                self.type,
                self.value,
            ))
        return self.__hash

    def __repr__(union1 self):
        return f'union1(type={self.type.name}, value={self.value!r})'

    cdef _load_cache(union1 self):
        self.type = union1.Type(<int>(deref(self._cpp_obj).getType()))
        if self.type == union1.Type.EMPTY:
            self.value = None
        elif self.type == union1.Type.i:
            self.value = deref(self._cpp_obj).get_i()
        elif self.type == union1.Type.d:
            self.value = deref(self._cpp_obj).get_d()

    def get_type(union1 self):
        return self.type

    def __richcmp__(self, other, op):
        cdef int cop = op
        if cop not in (2, 3):
            raise TypeError("unorderable types: {}, {}".format(self, other))
        if not (
                isinstance(self, union1) and
                isinstance(other, union1)):
            if cop == 2:  # different types are never equal
                return False
            else:         # different types are always notequal
                return True

        cdef cunion1 cself = deref((<union1>self)._cpp_obj)
        cdef cunion1 cother = deref((<union1>other)._cpp_obj)
        cdef cbool cmp = cself == cother
        if cop == 2:
            return cmp
        return not cmp

    cdef __iobuf.IOBuf _serialize(union1 self, proto):
        cdef __iobuf.cIOBufQueue queue = __iobuf.cIOBufQueue(__iobuf.cacheChainLength())
        cdef cunion1* cpp_obj = self._cpp_obj.get()
        if proto is Protocol.COMPACT:
            with nogil:
                serializer.CompactSerialize[cunion1](deref(cpp_obj), &queue, serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is Protocol.BINARY:
            with nogil:
                serializer.BinarySerialize[cunion1](deref(cpp_obj), &queue, serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is Protocol.JSON:
            with nogil:
                serializer.JSONSerialize[cunion1](deref(cpp_obj), &queue, serializer.SHARE_EXTERNAL_BUFFER)
        return __iobuf.from_unique_ptr(queue.move())

    cdef uint32_t _deserialize(union1 self, const __iobuf.cIOBuf* buf, proto) except? 0:
        cdef uint32_t needed
        self._cpp_obj = make_shared[cunion1]()
        cdef cunion1* cpp_obj = self._cpp_obj.get()
        if proto is Protocol.COMPACT:
            with nogil:
                needed = serializer.CompactDeserialize[cunion1](buf, deref(cpp_obj), serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is Protocol.BINARY:
            with nogil:
                needed = serializer.BinaryDeserialize[cunion1](buf, deref(cpp_obj), serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is Protocol.JSON:
            with nogil:
                needed = serializer.JSONDeserialize[cunion1](buf, deref(cpp_obj), serializer.SHARE_EXTERNAL_BUFFER)
        # force a cache reload since the underlying data's changed
        self._load_cache()
        return needed

    def __reduce__(self):
        return (deserialize, (union1, serialize(self)))


class __union2Type(__enum.Enum):
    EMPTY = <int>cunion2__type___EMPTY__
    i = <int>cunion2__type_i
    d = <int>cunion2__type_d
    s = <int>cunion2__type_s
    u = <int>cunion2__type_u


cdef class union2(thrift.py3.types.Union):
    Type = __union2Type

    def __init__(
        self, *,
        i=None,
        d=None,
        struct1 s=None,
        union1 u=None
    ):
        if i is not None:
            if not isinstance(i, int):
                raise TypeError(f'i is not a { int !r}.')
            i = <int32_t> i

        if d is not None:
            if not isinstance(d, (float, int)):
                raise TypeError(f'd is not a { float !r}.')

        self._cpp_obj = move(union2._make_instance(
          NULL,
          i,
          d,
          s,
          u,
        ))
        self._load_cache()

    @staticmethod
    def fromValue(value):
        if value is None:
            return union2()
        if isinstance(value, int):
            if not isinstance(value, pbool):
                try:
                    <int32_t> value
                    return union2(i=value)
                except OverflowError:
                    pass
        if isinstance(value, float):
            if not isinstance(value, pbool):
                try:
                    return union2(d=value)
                except OverflowError:
                    pass
        if isinstance(value, struct1):
            return union2(s=value)
        if isinstance(value, union1):
            return union2(u=value)
        if isinstance(value, (float, int)):
            try:
                <double> value
                return union2(d=value)
            except OverflowError:
                pass
        raise ValueError(f"Unable to derive correct union field for value: {value}")

    @staticmethod
    cdef unique_ptr[cunion2] _make_instance(
        cunion2* base_instance,
        i,
        d,
        s,
        u
    ) except *:
        cdef unique_ptr[cunion2] c_inst = make_unique[cunion2]()
        cdef bint any_set = False
        if i is not None:
            if any_set:
                raise TypeError("At most one field may be set when initializing a union")
            deref(c_inst).set_i(i)
            any_set = True
        if d is not None:
            if any_set:
                raise TypeError("At most one field may be set when initializing a union")
            deref(c_inst).set_d(d)
            any_set = True
        if s is not None:
            if any_set:
                raise TypeError("At most one field may be set when initializing a union")
            deref(c_inst).set_s(deref((<struct1?> s)._cpp_obj))
            any_set = True
        if u is not None:
            if any_set:
                raise TypeError("At most one field may be set when initializing a union")
            deref(c_inst).set_u(deref((<union1?> u)._cpp_obj))
            any_set = True
        # in C++ you don't have to call move(), but this doesn't translate
        # into a C++ return statement, so you do here
        return move_unique(c_inst)

    def __bool__(self):
        return self.type != union2.Type.EMPTY

    @staticmethod
    cdef create(shared_ptr[cunion2] cpp_obj):
        inst = <union2>union2.__new__(union2)
        inst._cpp_obj = cpp_obj
        inst._load_cache()
        return inst

    @property
    def i(self):
        if self.type != union2.Type.i:
            raise TypeError(f'Union contains a value of type {self.type.name}, not i')
        return self.value

    @property
    def d(self):
        if self.type != union2.Type.d:
            raise TypeError(f'Union contains a value of type {self.type.name}, not d')
        return self.value

    @property
    def s(self):
        if self.type != union2.Type.s:
            raise TypeError(f'Union contains a value of type {self.type.name}, not s')
        return self.value

    @property
    def u(self):
        if self.type != union2.Type.u:
            raise TypeError(f'Union contains a value of type {self.type.name}, not u')
        return self.value


    def __hash__(union2 self):
        if not self.__hash:
            self.__hash = hash((
                self.type,
                self.value,
            ))
        return self.__hash

    def __repr__(union2 self):
        return f'union2(type={self.type.name}, value={self.value!r})'

    cdef _load_cache(union2 self):
        self.type = union2.Type(<int>(deref(self._cpp_obj).getType()))
        if self.type == union2.Type.EMPTY:
            self.value = None
        elif self.type == union2.Type.i:
            self.value = deref(self._cpp_obj).get_i()
        elif self.type == union2.Type.d:
            self.value = deref(self._cpp_obj).get_d()
        elif self.type == union2.Type.s:
            self.value = struct1.create(make_shared[cstruct1](deref(self._cpp_obj).get_s()))
        elif self.type == union2.Type.u:
            self.value = union1.create(make_shared[cunion1](deref(self._cpp_obj).get_u()))

    def get_type(union2 self):
        return self.type

    def __richcmp__(self, other, op):
        cdef int cop = op
        if cop not in (2, 3):
            raise TypeError("unorderable types: {}, {}".format(self, other))
        if not (
                isinstance(self, union2) and
                isinstance(other, union2)):
            if cop == 2:  # different types are never equal
                return False
            else:         # different types are always notequal
                return True

        cdef cunion2 cself = deref((<union2>self)._cpp_obj)
        cdef cunion2 cother = deref((<union2>other)._cpp_obj)
        cdef cbool cmp = cself == cother
        if cop == 2:
            return cmp
        return not cmp

    cdef __iobuf.IOBuf _serialize(union2 self, proto):
        cdef __iobuf.cIOBufQueue queue = __iobuf.cIOBufQueue(__iobuf.cacheChainLength())
        cdef cunion2* cpp_obj = self._cpp_obj.get()
        if proto is Protocol.COMPACT:
            with nogil:
                serializer.CompactSerialize[cunion2](deref(cpp_obj), &queue, serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is Protocol.BINARY:
            with nogil:
                serializer.BinarySerialize[cunion2](deref(cpp_obj), &queue, serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is Protocol.JSON:
            with nogil:
                serializer.JSONSerialize[cunion2](deref(cpp_obj), &queue, serializer.SHARE_EXTERNAL_BUFFER)
        return __iobuf.from_unique_ptr(queue.move())

    cdef uint32_t _deserialize(union2 self, const __iobuf.cIOBuf* buf, proto) except? 0:
        cdef uint32_t needed
        self._cpp_obj = make_shared[cunion2]()
        cdef cunion2* cpp_obj = self._cpp_obj.get()
        if proto is Protocol.COMPACT:
            with nogil:
                needed = serializer.CompactDeserialize[cunion2](buf, deref(cpp_obj), serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is Protocol.BINARY:
            with nogil:
                needed = serializer.BinaryDeserialize[cunion2](buf, deref(cpp_obj), serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is Protocol.JSON:
            with nogil:
                needed = serializer.JSONDeserialize[cunion2](buf, deref(cpp_obj), serializer.SHARE_EXTERNAL_BUFFER)
        # force a cache reload since the underlying data's changed
        self._load_cache()
        return needed

    def __reduce__(self):
        return (deserialize, (union2, serialize(self)))


cdef class List__i32:
    def __init__(self, items=None):
        if isinstance(items, List__i32):
            self._cpp_obj = (<List__i32> items)._cpp_obj
        else:
            self._cpp_obj = move(List__i32._make_instance(items))

    @staticmethod
    cdef create(shared_ptr[vector[int32_t]] c_items):
        inst = <List__i32>List__i32.__new__(List__i32)
        inst._cpp_obj = c_items
        return inst

    @staticmethod
    cdef unique_ptr[vector[int32_t]] _make_instance(object items) except *:
        cdef unique_ptr[vector[int32_t]] c_inst = make_unique[vector[int32_t]]()
        if items is not None:
            for item in items:
                if not isinstance(item, int):
                    raise TypeError(f"{item!r} is not of type int")
                item = <int32_t> item
                deref(c_inst).push_back(item)
        return move_unique(c_inst)

    def __add__(object self, object other):
        return type(self)(itertools.chain(self, other))

    def __getitem__(self, object index_obj):
        cdef shared_ptr[vector[int32_t]] c_inst
        cdef int32_t citem
        if isinstance(index_obj, slice):
            c_inst = make_shared[vector[int32_t]]()
            sz = deref(self._cpp_obj).size()
            for index in range(*index_obj.indices(sz)):
                citem = deref(self._cpp_obj.get())[index]
                deref(c_inst).push_back(citem)
            return List__i32.create(c_inst)
        else:
            index = <int?>index_obj
            size = len(self)
            # Convert a negative index
            if index < 0:
                index = size + index
            if index >= size or index < 0:
                raise IndexError('list index out of range')
            citem = deref(self._cpp_obj.get())[index]
            return citem

    def __len__(self):
        return deref(self._cpp_obj).size()

    def __richcmp__(self, other, op):
        cdef int cop = op
        if cop not in (2, 3):
            raise TypeError("unorderable types: {}, {}".format(type(self), type(other)))
        if not (isinstance(self, Iterable) and isinstance(other, Iterable)):
            return cop != 2
        if (len(self) != len(other)):
            return cop != 2

        for one, two in zip(self, other):
            if one != two:
                return cop != 2

        return cop == 2

    def __hash__(self):
        if not self.__hash:
            self.__hash = hash(tuple(self))
        return self.__hash

    def __contains__(self, item):
        if not self or item is None:
            return False
        if not isinstance(item, int):
            return False
        cdef int32_t citem = item
        cdef vector[int32_t] vec = deref(
            self._cpp_obj.get())
        return std_libcpp.find(vec.begin(), vec.end(), citem) != vec.end()

    def __iter__(self):
        if not self:
            raise StopIteration
        cdef int32_t citem
        for citem in deref(self._cpp_obj):
            yield citem

    def __repr__(self):
        if not self:
            return 'i[]'
        return f'i[{", ".join(map(repr, self))}]'

    def __reversed__(self):
        if not self:
            raise StopIteration
        cdef int32_t citem
        cdef vector[int32_t] vec = deref(
            self._cpp_obj.get())
        cdef vector[int32_t].reverse_iterator loc = vec.rbegin()
        while loc != vec.rend():
            citem = deref(loc)
            yield citem
            inc(loc)

    def index(self, item, start not None=__NOTSET, stop not None=__NOTSET):
        err = ValueError(f'{item} is not in list')
        if not self or item is None:
            raise err
        offset_begin = offset_end = 0
        if stop is not __NOTSET or start is not __NOTSET:
            # Like self[start:stop].index(item)
            size = len(self)
            stop = stop if stop is not __NOTSET else size
            start = start if start is not __NOTSET else 0
            # Convert stop to a negative position.
            if stop > 0:
                stop = min(stop - size, 0)
            if stop <= -size:
                raise err  # List would be empty
            offset_end = -stop
            # Convert start to always be positive
            if start < 0:
                start = max(size + start, 0)
            if start >= size:
                raise err  # past end of list
            offset_begin = start

        if not isinstance(item, int):
            raise err
        cdef int32_t citem = item
        cdef vector[int32_t] vec = deref(self._cpp_obj.get())
        cdef vector[int32_t].iterator end = std_libcpp.prev(vec.end(), <int64_t>offset_end)
        cdef vector[int32_t].iterator loc = std_libcpp.find(
            std_libcpp.next(vec.begin(), <int64_t>offset_begin),
            end,
            citem
        )
        if loc != end:
            return <int64_t> std_libcpp.distance(vec.begin(), loc)
        raise err

    def count(self, item):
        if not self or item is None:
            return 0
        if not isinstance(item, int):
            return 0
        cdef int32_t citem = item
        cdef vector[int32_t] vec = deref(self._cpp_obj.get())
        return <int64_t> std_libcpp.count(vec.begin(), vec.end(), citem)


Sequence.register(List__i32)

cdef class Map__string_i32:
    def __init__(self, items=None):
        if isinstance(items, Map__string_i32):
            self._cpp_obj = (<Map__string_i32> items)._cpp_obj
        else:
            self._cpp_obj = move(Map__string_i32._make_instance(items))

    @staticmethod
    cdef create(shared_ptr[cmap[string,int32_t]] c_items):
        inst = <Map__string_i32>Map__string_i32.__new__(Map__string_i32)
        inst._cpp_obj = c_items
        return inst

    @staticmethod
    cdef unique_ptr[cmap[string,int32_t]] _make_instance(object items) except *:
        cdef unique_ptr[cmap[string,int32_t]] c_inst = make_unique[cmap[string,int32_t]]()
        if items is not None:
            for key, item in items.items():
                if not isinstance(key, str):
                    raise TypeError(f"{key!r} is not of type str")
                if not isinstance(item, int):
                    raise TypeError(f"{item!r} is not of type int")
                item = <int32_t> item

                deref(c_inst).insert(cpair[string,int32_t](key.encode('UTF-8'),item))
        return move_unique(c_inst)

    def __getitem__(self, key):
        err = KeyError(f'{key}')
        if not self or key is None:
            raise err
        if not isinstance(key, str):
            raise err
        cdef string ckey = key.encode('UTF-8')
        cdef cmap[string,int32_t].iterator iter = deref(
            self._cpp_obj).find(ckey)
        if iter == deref(self._cpp_obj).end():
            raise err
        cdef int32_t citem = deref(iter).second
        return citem

    def __len__(self):
        return deref(self._cpp_obj).size()

    def __iter__(self):
        if not self:
            raise StopIteration
        cdef string citem
        for pair in deref(self._cpp_obj):
            citem = pair.first
            yield bytes(citem).decode('UTF-8')

    def __richcmp__(self, other, op):
        cdef int cop = op
        if cop not in (2, 3):
            raise TypeError("unorderable types: {}, {}".format(type(self), type(other)))
        if not (isinstance(self, Mapping) and isinstance(other, Mapping)):
            return cop != 2
        if (len(self) != len(other)):
            return cop != 2

        for key in self:
            if key not in other:
                return cop != 2
            if other[key] != self[key]:
                return cop != 2

        return cop == 2

    def __hash__(self):
        if not self.__hash:
            self.__hash = hash(tuple(self.items()))
        return self.__hash

    def __repr__(self):
        if not self:
            return 'i{}'
        return f'i{{{", ".join(map(lambda i: f"{repr(i[0])}: {repr(i[1])}", self.items()))}}}'

    def __contains__(self, key):
        if not self or key is None:
            return False
        if not isinstance(key, str):
            return False
        cdef string ckey = key.encode('UTF-8')
        return deref(self._cpp_obj).count(ckey) > 0

    def get(self, key, default=None):
        if not self or key is None:
            return default
        try:
            if not isinstance(key, str):
                key = str(key)
        except Exception:
            return default
        if not isinstance(key, str):
            return default
        if key not in self:
            return default
        return self[key]

    def keys(self):
        return self.__iter__()

    def values(self):
        if not self:
            raise StopIteration
        cdef int32_t citem
        for pair in deref(self._cpp_obj):
            citem = pair.second
            yield citem

    def items(self):
        if not self:
            raise StopIteration
        cdef string ckey
        cdef int32_t citem
        for pair in deref(self._cpp_obj):
            ckey = pair.first
            citem = pair.second

            yield (ckey.decode('UTF-8'), citem)



Mapping.register(Map__string_i32)

cdef class List__Map__string_i32:
    def __init__(self, items=None):
        if isinstance(items, List__Map__string_i32):
            self._cpp_obj = (<List__Map__string_i32> items)._cpp_obj
        else:
            self._cpp_obj = move(List__Map__string_i32._make_instance(items))

    @staticmethod
    cdef create(shared_ptr[vector[cmap[string,int32_t]]] c_items):
        inst = <List__Map__string_i32>List__Map__string_i32.__new__(List__Map__string_i32)
        inst._cpp_obj = c_items
        return inst

    @staticmethod
    cdef unique_ptr[vector[cmap[string,int32_t]]] _make_instance(object items) except *:
        cdef unique_ptr[vector[cmap[string,int32_t]]] c_inst = make_unique[vector[cmap[string,int32_t]]]()
        if items is not None:
            for item in items:
                if item is None:
                    raise TypeError("None is not of the type _typing.Mapping[str, int]")
                if not isinstance(item, Map__string_i32):
                    item = Map__string_i32(item)
                deref(c_inst).push_back(cmap[string,int32_t](deref(Map__string_i32(item)._cpp_obj.get())))
        return move_unique(c_inst)

    def __add__(object self, object other):
        return type(self)(itertools.chain(self, other))

    def __getitem__(self, object index_obj):
        cdef shared_ptr[vector[cmap[string,int32_t]]] c_inst
        cdef cmap[string,int32_t] citem
        if isinstance(index_obj, slice):
            c_inst = make_shared[vector[cmap[string,int32_t]]]()
            sz = deref(self._cpp_obj).size()
            for index in range(*index_obj.indices(sz)):
                citem = deref(self._cpp_obj.get())[index]
                deref(c_inst).push_back(citem)
            return List__Map__string_i32.create(c_inst)
        else:
            index = <int?>index_obj
            size = len(self)
            # Convert a negative index
            if index < 0:
                index = size + index
            if index >= size or index < 0:
                raise IndexError('list index out of range')
            citem = deref(self._cpp_obj.get())[index]
            return Map__string_i32.create(
    make_shared[cmap[string,int32_t]](citem))

    def __len__(self):
        return deref(self._cpp_obj).size()

    def __richcmp__(self, other, op):
        cdef int cop = op
        if cop not in (2, 3):
            raise TypeError("unorderable types: {}, {}".format(type(self), type(other)))
        if not (isinstance(self, Iterable) and isinstance(other, Iterable)):
            return cop != 2
        if (len(self) != len(other)):
            return cop != 2

        for one, two in zip(self, other):
            if one != two:
                return cop != 2

        return cop == 2

    def __hash__(self):
        if not self.__hash:
            self.__hash = hash(tuple(self))
        return self.__hash

    def __contains__(self, item):
        if not self or item is None:
            return False
        try:
            if not isinstance(item, Map__string_i32):
                item = Map__string_i32(item)
        except Exception:
            return False
        if not isinstance(item, Map__string_i32):
            return False
        cdef cmap[string,int32_t] citem = cmap[string,int32_t](deref(Map__string_i32(item)._cpp_obj.get()))
        cdef vector[cmap[string,int32_t]] vec = deref(
            self._cpp_obj.get())
        return std_libcpp.find(vec.begin(), vec.end(), citem) != vec.end()

    def __iter__(self):
        if not self:
            raise StopIteration
        cdef cmap[string,int32_t] citem
        for citem in deref(self._cpp_obj):
            yield Map__string_i32.create(
    make_shared[cmap[string,int32_t]](citem))

    def __repr__(self):
        if not self:
            return 'i[]'
        return f'i[{", ".join(map(repr, self))}]'

    def __reversed__(self):
        if not self:
            raise StopIteration
        cdef cmap[string,int32_t] citem
        cdef vector[cmap[string,int32_t]] vec = deref(
            self._cpp_obj.get())
        cdef vector[cmap[string,int32_t]].reverse_iterator loc = vec.rbegin()
        while loc != vec.rend():
            citem = deref(loc)
            yield Map__string_i32.create(
    make_shared[cmap[string,int32_t]](citem))
            inc(loc)

    def index(self, item, start not None=__NOTSET, stop not None=__NOTSET):
        err = ValueError(f'{item} is not in list')
        if not self or item is None:
            raise err
        offset_begin = offset_end = 0
        if stop is not __NOTSET or start is not __NOTSET:
            # Like self[start:stop].index(item)
            size = len(self)
            stop = stop if stop is not __NOTSET else size
            start = start if start is not __NOTSET else 0
            # Convert stop to a negative position.
            if stop > 0:
                stop = min(stop - size, 0)
            if stop <= -size:
                raise err  # List would be empty
            offset_end = -stop
            # Convert start to always be positive
            if start < 0:
                start = max(size + start, 0)
            if start >= size:
                raise err  # past end of list
            offset_begin = start

        try:
            if not isinstance(item, Map__string_i32):
                item = Map__string_i32(item)
        except Exception:
            raise err from None
        if not isinstance(item, Map__string_i32):
            raise err
        cdef cmap[string,int32_t] citem = cmap[string,int32_t](deref(Map__string_i32(item)._cpp_obj.get()))
        cdef vector[cmap[string,int32_t]] vec = deref(self._cpp_obj.get())
        cdef vector[cmap[string,int32_t]].iterator end = std_libcpp.prev(vec.end(), <int64_t>offset_end)
        cdef vector[cmap[string,int32_t]].iterator loc = std_libcpp.find(
            std_libcpp.next(vec.begin(), <int64_t>offset_begin),
            end,
            citem
        )
        if loc != end:
            return <int64_t> std_libcpp.distance(vec.begin(), loc)
        raise err

    def count(self, item):
        if not self or item is None:
            return 0
        try:
            if not isinstance(item, Map__string_i32):
                item = Map__string_i32(item)
        except Exception:
            return 0
        if not isinstance(item, Map__string_i32):
            return 0
        cdef cmap[string,int32_t] citem = cmap[string,int32_t](deref(Map__string_i32(item)._cpp_obj.get()))
        cdef vector[cmap[string,int32_t]] vec = deref(self._cpp_obj.get())
        return <int64_t> std_libcpp.count(vec.begin(), vec.end(), citem)


Sequence.register(List__Map__string_i32)

cdef class List__Range:
    def __init__(self, items=None):
        if isinstance(items, List__Range):
            self._cpp_obj = (<List__Range> items)._cpp_obj
        else:
            self._cpp_obj = move(List__Range._make_instance(items))

    @staticmethod
    cdef create(shared_ptr[vector[cRange]] c_items):
        inst = <List__Range>List__Range.__new__(List__Range)
        inst._cpp_obj = c_items
        return inst

    @staticmethod
    cdef unique_ptr[vector[cRange]] _make_instance(object items) except *:
        cdef unique_ptr[vector[cRange]] c_inst = make_unique[vector[cRange]]()
        if items is not None:
            for item in items:
                if not isinstance(item, Range):
                    raise TypeError(f"{item!r} is not of type 'Range'")
                deref(c_inst).push_back(deref((<Range>item)._cpp_obj))
        return move_unique(c_inst)

    def __add__(object self, object other):
        return type(self)(itertools.chain(self, other))

    def __getitem__(self, object index_obj):
        cdef shared_ptr[vector[cRange]] c_inst
        cdef cRange citem
        if isinstance(index_obj, slice):
            c_inst = make_shared[vector[cRange]]()
            sz = deref(self._cpp_obj).size()
            for index in range(*index_obj.indices(sz)):
                citem = deref(self._cpp_obj.get())[index]
                deref(c_inst).push_back(citem)
            return List__Range.create(c_inst)
        else:
            index = <int?>index_obj
            size = len(self)
            # Convert a negative index
            if index < 0:
                index = size + index
            if index >= size or index < 0:
                raise IndexError('list index out of range')
            citem = deref(self._cpp_obj.get())[index]
            return Range.create(make_shared[cRange](citem))

    def __len__(self):
        return deref(self._cpp_obj).size()

    def __richcmp__(self, other, op):
        cdef int cop = op
        if cop not in (2, 3):
            raise TypeError("unorderable types: {}, {}".format(type(self), type(other)))
        if not (isinstance(self, Iterable) and isinstance(other, Iterable)):
            return cop != 2
        if (len(self) != len(other)):
            return cop != 2

        for one, two in zip(self, other):
            if one != two:
                return cop != 2

        return cop == 2

    def __hash__(self):
        if not self.__hash:
            self.__hash = hash(tuple(self))
        return self.__hash

    def __contains__(self, item):
        if not self or item is None:
            return False
        if not isinstance(item, Range):
            return False
        cdef cRange citem = deref((<Range>item)._cpp_obj)
        cdef vector[cRange] vec = deref(
            self._cpp_obj.get())
        return std_libcpp.find(vec.begin(), vec.end(), citem) != vec.end()

    def __iter__(self):
        if not self:
            raise StopIteration
        cdef cRange citem
        for citem in deref(self._cpp_obj):
            yield Range.create(make_shared[cRange](citem))

    def __repr__(self):
        if not self:
            return 'i[]'
        return f'i[{", ".join(map(repr, self))}]'

    def __reversed__(self):
        if not self:
            raise StopIteration
        cdef cRange citem
        cdef vector[cRange] vec = deref(
            self._cpp_obj.get())
        cdef vector[cRange].reverse_iterator loc = vec.rbegin()
        while loc != vec.rend():
            citem = deref(loc)
            yield Range.create(make_shared[cRange](citem))
            inc(loc)

    def index(self, item, start not None=__NOTSET, stop not None=__NOTSET):
        err = ValueError(f'{item} is not in list')
        if not self or item is None:
            raise err
        offset_begin = offset_end = 0
        if stop is not __NOTSET or start is not __NOTSET:
            # Like self[start:stop].index(item)
            size = len(self)
            stop = stop if stop is not __NOTSET else size
            start = start if start is not __NOTSET else 0
            # Convert stop to a negative position.
            if stop > 0:
                stop = min(stop - size, 0)
            if stop <= -size:
                raise err  # List would be empty
            offset_end = -stop
            # Convert start to always be positive
            if start < 0:
                start = max(size + start, 0)
            if start >= size:
                raise err  # past end of list
            offset_begin = start

        if not isinstance(item, Range):
            raise err
        cdef cRange citem = deref((<Range>item)._cpp_obj)
        cdef vector[cRange] vec = deref(self._cpp_obj.get())
        cdef vector[cRange].iterator end = std_libcpp.prev(vec.end(), <int64_t>offset_end)
        cdef vector[cRange].iterator loc = std_libcpp.find(
            std_libcpp.next(vec.begin(), <int64_t>offset_begin),
            end,
            citem
        )
        if loc != end:
            return <int64_t> std_libcpp.distance(vec.begin(), loc)
        raise err

    def count(self, item):
        if not self or item is None:
            return 0
        if not isinstance(item, Range):
            return 0
        cdef cRange citem = deref((<Range>item)._cpp_obj)
        cdef vector[cRange] vec = deref(self._cpp_obj.get())
        return <int64_t> std_libcpp.count(vec.begin(), vec.end(), citem)


Sequence.register(List__Range)

cdef class List__Internship:
    def __init__(self, items=None):
        if isinstance(items, List__Internship):
            self._cpp_obj = (<List__Internship> items)._cpp_obj
        else:
            self._cpp_obj = move(List__Internship._make_instance(items))

    @staticmethod
    cdef create(shared_ptr[vector[cInternship]] c_items):
        inst = <List__Internship>List__Internship.__new__(List__Internship)
        inst._cpp_obj = c_items
        return inst

    @staticmethod
    cdef unique_ptr[vector[cInternship]] _make_instance(object items) except *:
        cdef unique_ptr[vector[cInternship]] c_inst = make_unique[vector[cInternship]]()
        if items is not None:
            for item in items:
                if not isinstance(item, Internship):
                    raise TypeError(f"{item!r} is not of type 'Internship'")
                deref(c_inst).push_back(deref((<Internship>item)._cpp_obj))
        return move_unique(c_inst)

    def __add__(object self, object other):
        return type(self)(itertools.chain(self, other))

    def __getitem__(self, object index_obj):
        cdef shared_ptr[vector[cInternship]] c_inst
        cdef cInternship citem
        if isinstance(index_obj, slice):
            c_inst = make_shared[vector[cInternship]]()
            sz = deref(self._cpp_obj).size()
            for index in range(*index_obj.indices(sz)):
                citem = deref(self._cpp_obj.get())[index]
                deref(c_inst).push_back(citem)
            return List__Internship.create(c_inst)
        else:
            index = <int?>index_obj
            size = len(self)
            # Convert a negative index
            if index < 0:
                index = size + index
            if index >= size or index < 0:
                raise IndexError('list index out of range')
            citem = deref(self._cpp_obj.get())[index]
            return Internship.create(make_shared[cInternship](citem))

    def __len__(self):
        return deref(self._cpp_obj).size()

    def __richcmp__(self, other, op):
        cdef int cop = op
        if cop not in (2, 3):
            raise TypeError("unorderable types: {}, {}".format(type(self), type(other)))
        if not (isinstance(self, Iterable) and isinstance(other, Iterable)):
            return cop != 2
        if (len(self) != len(other)):
            return cop != 2

        for one, two in zip(self, other):
            if one != two:
                return cop != 2

        return cop == 2

    def __hash__(self):
        if not self.__hash:
            self.__hash = hash(tuple(self))
        return self.__hash

    def __contains__(self, item):
        if not self or item is None:
            return False
        if not isinstance(item, Internship):
            return False
        cdef cInternship citem = deref((<Internship>item)._cpp_obj)
        cdef vector[cInternship] vec = deref(
            self._cpp_obj.get())
        return std_libcpp.find(vec.begin(), vec.end(), citem) != vec.end()

    def __iter__(self):
        if not self:
            raise StopIteration
        cdef cInternship citem
        for citem in deref(self._cpp_obj):
            yield Internship.create(make_shared[cInternship](citem))

    def __repr__(self):
        if not self:
            return 'i[]'
        return f'i[{", ".join(map(repr, self))}]'

    def __reversed__(self):
        if not self:
            raise StopIteration
        cdef cInternship citem
        cdef vector[cInternship] vec = deref(
            self._cpp_obj.get())
        cdef vector[cInternship].reverse_iterator loc = vec.rbegin()
        while loc != vec.rend():
            citem = deref(loc)
            yield Internship.create(make_shared[cInternship](citem))
            inc(loc)

    def index(self, item, start not None=__NOTSET, stop not None=__NOTSET):
        err = ValueError(f'{item} is not in list')
        if not self or item is None:
            raise err
        offset_begin = offset_end = 0
        if stop is not __NOTSET or start is not __NOTSET:
            # Like self[start:stop].index(item)
            size = len(self)
            stop = stop if stop is not __NOTSET else size
            start = start if start is not __NOTSET else 0
            # Convert stop to a negative position.
            if stop > 0:
                stop = min(stop - size, 0)
            if stop <= -size:
                raise err  # List would be empty
            offset_end = -stop
            # Convert start to always be positive
            if start < 0:
                start = max(size + start, 0)
            if start >= size:
                raise err  # past end of list
            offset_begin = start

        if not isinstance(item, Internship):
            raise err
        cdef cInternship citem = deref((<Internship>item)._cpp_obj)
        cdef vector[cInternship] vec = deref(self._cpp_obj.get())
        cdef vector[cInternship].iterator end = std_libcpp.prev(vec.end(), <int64_t>offset_end)
        cdef vector[cInternship].iterator loc = std_libcpp.find(
            std_libcpp.next(vec.begin(), <int64_t>offset_begin),
            end,
            citem
        )
        if loc != end:
            return <int64_t> std_libcpp.distance(vec.begin(), loc)
        raise err

    def count(self, item):
        if not self or item is None:
            return 0
        if not isinstance(item, Internship):
            return 0
        cdef cInternship citem = deref((<Internship>item)._cpp_obj)
        cdef vector[cInternship] vec = deref(self._cpp_obj.get())
        return <int64_t> std_libcpp.count(vec.begin(), vec.end(), citem)


Sequence.register(List__Internship)

cdef class List__string:
    def __init__(self, items=None):
        if isinstance(items, List__string):
            self._cpp_obj = (<List__string> items)._cpp_obj
        else:
            self._cpp_obj = move(List__string._make_instance(items))

    @staticmethod
    cdef create(shared_ptr[vector[string]] c_items):
        inst = <List__string>List__string.__new__(List__string)
        inst._cpp_obj = c_items
        return inst

    @staticmethod
    cdef unique_ptr[vector[string]] _make_instance(object items) except *:
        cdef unique_ptr[vector[string]] c_inst = make_unique[vector[string]]()
        if items is not None:
            for item in items:
                if not isinstance(item, str):
                    raise TypeError(f"{item!r} is not of type str")
                deref(c_inst).push_back(item.encode('UTF-8'))
        return move_unique(c_inst)

    def __add__(object self, object other):
        return type(self)(itertools.chain(self, other))

    def __getitem__(self, object index_obj):
        cdef shared_ptr[vector[string]] c_inst
        cdef string citem
        if isinstance(index_obj, slice):
            c_inst = make_shared[vector[string]]()
            sz = deref(self._cpp_obj).size()
            for index in range(*index_obj.indices(sz)):
                citem = deref(self._cpp_obj.get())[index]
                deref(c_inst).push_back(citem)
            return List__string.create(c_inst)
        else:
            index = <int?>index_obj
            size = len(self)
            # Convert a negative index
            if index < 0:
                index = size + index
            if index >= size or index < 0:
                raise IndexError('list index out of range')
            citem = deref(self._cpp_obj.get())[index]
            return bytes(citem).decode('UTF-8')

    def __len__(self):
        return deref(self._cpp_obj).size()

    def __richcmp__(self, other, op):
        cdef int cop = op
        if cop not in (2, 3):
            raise TypeError("unorderable types: {}, {}".format(type(self), type(other)))
        if not (isinstance(self, Iterable) and isinstance(other, Iterable)):
            return cop != 2
        if (len(self) != len(other)):
            return cop != 2

        for one, two in zip(self, other):
            if one != two:
                return cop != 2

        return cop == 2

    def __hash__(self):
        if not self.__hash:
            self.__hash = hash(tuple(self))
        return self.__hash

    def __contains__(self, item):
        if not self or item is None:
            return False
        if not isinstance(item, str):
            return False
        cdef string citem = item.encode('UTF-8')
        cdef vector[string] vec = deref(
            self._cpp_obj.get())
        return std_libcpp.find(vec.begin(), vec.end(), citem) != vec.end()

    def __iter__(self):
        if not self:
            raise StopIteration
        cdef string citem
        for citem in deref(self._cpp_obj):
            yield bytes(citem).decode('UTF-8')

    def __repr__(self):
        if not self:
            return 'i[]'
        return f'i[{", ".join(map(repr, self))}]'

    def __reversed__(self):
        if not self:
            raise StopIteration
        cdef string citem
        cdef vector[string] vec = deref(
            self._cpp_obj.get())
        cdef vector[string].reverse_iterator loc = vec.rbegin()
        while loc != vec.rend():
            citem = deref(loc)
            yield bytes(citem).decode('UTF-8')
            inc(loc)

    def index(self, item, start not None=__NOTSET, stop not None=__NOTSET):
        err = ValueError(f'{item} is not in list')
        if not self or item is None:
            raise err
        offset_begin = offset_end = 0
        if stop is not __NOTSET or start is not __NOTSET:
            # Like self[start:stop].index(item)
            size = len(self)
            stop = stop if stop is not __NOTSET else size
            start = start if start is not __NOTSET else 0
            # Convert stop to a negative position.
            if stop > 0:
                stop = min(stop - size, 0)
            if stop <= -size:
                raise err  # List would be empty
            offset_end = -stop
            # Convert start to always be positive
            if start < 0:
                start = max(size + start, 0)
            if start >= size:
                raise err  # past end of list
            offset_begin = start

        if not isinstance(item, str):
            raise err
        cdef string citem = item.encode('UTF-8')
        cdef vector[string] vec = deref(self._cpp_obj.get())
        cdef vector[string].iterator end = std_libcpp.prev(vec.end(), <int64_t>offset_end)
        cdef vector[string].iterator loc = std_libcpp.find(
            std_libcpp.next(vec.begin(), <int64_t>offset_begin),
            end,
            citem
        )
        if loc != end:
            return <int64_t> std_libcpp.distance(vec.begin(), loc)
        raise err

    def count(self, item):
        if not self or item is None:
            return 0
        if not isinstance(item, str):
            return 0
        cdef string citem = item.encode('UTF-8')
        cdef vector[string] vec = deref(self._cpp_obj.get())
        return <int64_t> std_libcpp.count(vec.begin(), vec.end(), citem)


Sequence.register(List__string)

cdef class Set__i32:
    def __init__(self, items=None):
        if isinstance(items, Set__i32):
            self._cpp_obj = (<Set__i32> items)._cpp_obj
        else:
            self._cpp_obj = move(Set__i32._make_instance(items))

    @staticmethod
    cdef create(shared_ptr[cset[int32_t]] c_items):
        inst = <Set__i32>Set__i32.__new__(Set__i32)
        inst._cpp_obj = c_items
        return inst

    @staticmethod
    cdef unique_ptr[cset[int32_t]] _make_instance(object items) except *:
        cdef unique_ptr[cset[int32_t]] c_inst = make_unique[cset[int32_t]]()
        if items is not None:
            for item in items:
                if not isinstance(item, int):
                    raise TypeError(f"{item!r} is not of type int")
                item = <int32_t> item
                deref(c_inst).insert(item)
        return move_unique(c_inst)

    def __contains__(self, item):
        if not self or item is None:
            return False
        if not isinstance(item, int):
            return False
        return pbool(deref(self._cpp_obj).count(item))


    def __len__(self):
        return deref(self._cpp_obj).size()

    def __iter__(self):
        if not self:
            raise StopIteration
        for citem in deref(self._cpp_obj):
            yield citem

    def __repr__(self):
        if not self:
            return 'iset()'
        return f'i{{{", ".join(map(repr, self))}}}'

    def __richcmp__(self, other, op):
        cdef int cop = op
        cdef cset[int32_t] cself, cother
        cdef cbool retval
        if (isinstance(self, Set__i32) and
                isinstance(other, Set__i32)):
            cself = deref((<Set__i32> self)._cpp_obj)
            cother = deref((<Set__i32> other)._cpp_obj)
            # C level comparisons
            if cop == 0:    # Less Than (strict subset)
                if not cself.size() < cother.size():
                    return False
                for item in cself:
                    if not cother.count(item):
                        return False
                return True
            elif cop == 1:  # Less Than or Equal To  (subset)
                for item in cself:
                    if not cother.count(item):
                        return False
                return True
            elif cop == 2:  # Equivalent
                if cself.size() != cother.size():
                    return False
                for item in cself:
                    if not cother.count(item):
                        return False
                return True
            elif cop == 3:  # Not Equivalent
                for item in cself:
                    if not cother.count(item):
                        return True
                return cself.size() != cother.size()
            elif cop == 4:  # Greater Than (strict superset)
                if not cself.size() > cother.size():
                    return False
                for item in cother:
                    if not cself.count(item):
                        return False
                return True
            elif cop == 5:  # Greater Than or Equal To (superset)
                for item in cother:
                    if not cself.count(item):
                        return False
                return True

        # Python level comparisons
        if cop == 0:
            return Set.__lt__(self, other)
        elif cop == 1:
            return Set.__le__(self, other)
        elif cop == 2:
            return Set.__eq__(self, other)
        elif cop == 3:
            return Set.__ne__(self, other)
        elif cop == 4:
            return Set.__gt__(self, other)
        elif cop == 5:
            return Set.__ge__(self, other)

    def __hash__(self):
        if not self.__hash:
            self.__hash = hash(tuple(self))
        return self.__hash

    def __and__(self, other):
        if not isinstance(self, Set__i32):
            self = Set__i32(self)
        if not isinstance(other, Set__i32):
            other = Set__i32(other)

        cdef shared_ptr[cset[int32_t]] shretval = \
            make_shared[cset[int32_t]]()
        for citem in deref((<Set__i32> self)._cpp_obj):
            if deref((<Set__i32> other)._cpp_obj).count(citem) > 0:
                deref(shretval).insert(citem)
        return Set__i32.create(shretval)

    def __sub__(self, other):
        if not isinstance(self, Set__i32):
            self = Set__i32(self)
        if not isinstance(other, Set__i32):
            other = Set__i32(other)

        cdef shared_ptr[cset[int32_t]] shretval = \
            make_shared[cset[int32_t]]()
        for citem in deref((<Set__i32> self)._cpp_obj):
            if deref((<Set__i32> other)._cpp_obj).count(citem) == 0:
                deref(shretval).insert(citem)
        return Set__i32.create(shretval)

    def __or__(self, other):
        if not isinstance(self, Set__i32):
            self = Set__i32(self)
        if not isinstance(other, Set__i32):
            other = Set__i32(other)

        cdef shared_ptr[cset[int32_t]] shretval = \
            make_shared[cset[int32_t]]()
        for citem in deref((<Set__i32> self)._cpp_obj):
                deref(shretval).insert(citem)
        for citem in deref((<Set__i32> other)._cpp_obj):
                deref(shretval).insert(citem)
        return Set__i32.create(shretval)

    def __xor__(self, other):
        if not isinstance(self, Set__i32):
            self = Set__i32(self)
        if not isinstance(other, Set__i32):
            other = Set__i32(other)

        cdef shared_ptr[cset[int32_t]] shretval = \
            make_shared[cset[int32_t]]()
        for citem in deref((<Set__i32> self)._cpp_obj):
            if deref((<Set__i32> other)._cpp_obj).count(citem) == 0:
                deref(shretval).insert(citem)
        for citem in deref((<Set__i32> other)._cpp_obj):
            if deref((<Set__i32> self)._cpp_obj).count(citem) == 0:
                deref(shretval).insert(citem)
        return Set__i32.create(shretval)

    def isdisjoint(self, other):
        return len(self & other) == 0

    def union(self, other):
        return self | other

    def intersection(self, other):
        return self & other

    def difference(self, other):
        return self - other

    def symmetric_difference(self, other):
        return self ^ other

    def issubset(self, other):
        return self <= other

    def issuperset(self, other):
        return self >= other


Set.register(Set__i32)

cdef class Set__string:
    def __init__(self, items=None):
        if isinstance(items, Set__string):
            self._cpp_obj = (<Set__string> items)._cpp_obj
        else:
            self._cpp_obj = move(Set__string._make_instance(items))

    @staticmethod
    cdef create(shared_ptr[cset[string]] c_items):
        inst = <Set__string>Set__string.__new__(Set__string)
        inst._cpp_obj = c_items
        return inst

    @staticmethod
    cdef unique_ptr[cset[string]] _make_instance(object items) except *:
        cdef unique_ptr[cset[string]] c_inst = make_unique[cset[string]]()
        if items is not None:
            for item in items:
                if not isinstance(item, str):
                    raise TypeError(f"{item!r} is not of type str")
                deref(c_inst).insert(item.encode('UTF-8'))
        return move_unique(c_inst)

    def __contains__(self, item):
        if not self or item is None:
            return False
        if not isinstance(item, str):
            return False
        return pbool(deref(self._cpp_obj).count(item.encode('UTF-8')))


    def __len__(self):
        return deref(self._cpp_obj).size()

    def __iter__(self):
        if not self:
            raise StopIteration
        for citem in deref(self._cpp_obj):
            yield bytes(citem).decode('UTF-8')

    def __repr__(self):
        if not self:
            return 'iset()'
        return f'i{{{", ".join(map(repr, self))}}}'

    def __richcmp__(self, other, op):
        cdef int cop = op
        cdef cset[string] cself, cother
        cdef cbool retval
        if (isinstance(self, Set__string) and
                isinstance(other, Set__string)):
            cself = deref((<Set__string> self)._cpp_obj)
            cother = deref((<Set__string> other)._cpp_obj)
            # C level comparisons
            if cop == 0:    # Less Than (strict subset)
                if not cself.size() < cother.size():
                    return False
                for item in cself:
                    if not cother.count(item):
                        return False
                return True
            elif cop == 1:  # Less Than or Equal To  (subset)
                for item in cself:
                    if not cother.count(item):
                        return False
                return True
            elif cop == 2:  # Equivalent
                if cself.size() != cother.size():
                    return False
                for item in cself:
                    if not cother.count(item):
                        return False
                return True
            elif cop == 3:  # Not Equivalent
                for item in cself:
                    if not cother.count(item):
                        return True
                return cself.size() != cother.size()
            elif cop == 4:  # Greater Than (strict superset)
                if not cself.size() > cother.size():
                    return False
                for item in cother:
                    if not cself.count(item):
                        return False
                return True
            elif cop == 5:  # Greater Than or Equal To (superset)
                for item in cother:
                    if not cself.count(item):
                        return False
                return True

        # Python level comparisons
        if cop == 0:
            return Set.__lt__(self, other)
        elif cop == 1:
            return Set.__le__(self, other)
        elif cop == 2:
            return Set.__eq__(self, other)
        elif cop == 3:
            return Set.__ne__(self, other)
        elif cop == 4:
            return Set.__gt__(self, other)
        elif cop == 5:
            return Set.__ge__(self, other)

    def __hash__(self):
        if not self.__hash:
            self.__hash = hash(tuple(self))
        return self.__hash

    def __and__(self, other):
        if not isinstance(self, Set__string):
            self = Set__string(self)
        if not isinstance(other, Set__string):
            other = Set__string(other)

        cdef shared_ptr[cset[string]] shretval = \
            make_shared[cset[string]]()
        for citem in deref((<Set__string> self)._cpp_obj):
            if deref((<Set__string> other)._cpp_obj).count(citem) > 0:
                deref(shretval).insert(citem)
        return Set__string.create(shretval)

    def __sub__(self, other):
        if not isinstance(self, Set__string):
            self = Set__string(self)
        if not isinstance(other, Set__string):
            other = Set__string(other)

        cdef shared_ptr[cset[string]] shretval = \
            make_shared[cset[string]]()
        for citem in deref((<Set__string> self)._cpp_obj):
            if deref((<Set__string> other)._cpp_obj).count(citem) == 0:
                deref(shretval).insert(citem)
        return Set__string.create(shretval)

    def __or__(self, other):
        if not isinstance(self, Set__string):
            self = Set__string(self)
        if not isinstance(other, Set__string):
            other = Set__string(other)

        cdef shared_ptr[cset[string]] shretval = \
            make_shared[cset[string]]()
        for citem in deref((<Set__string> self)._cpp_obj):
                deref(shretval).insert(citem)
        for citem in deref((<Set__string> other)._cpp_obj):
                deref(shretval).insert(citem)
        return Set__string.create(shretval)

    def __xor__(self, other):
        if not isinstance(self, Set__string):
            self = Set__string(self)
        if not isinstance(other, Set__string):
            other = Set__string(other)

        cdef shared_ptr[cset[string]] shretval = \
            make_shared[cset[string]]()
        for citem in deref((<Set__string> self)._cpp_obj):
            if deref((<Set__string> other)._cpp_obj).count(citem) == 0:
                deref(shretval).insert(citem)
        for citem in deref((<Set__string> other)._cpp_obj):
            if deref((<Set__string> self)._cpp_obj).count(citem) == 0:
                deref(shretval).insert(citem)
        return Set__string.create(shretval)

    def isdisjoint(self, other):
        return len(self & other) == 0

    def union(self, other):
        return self | other

    def intersection(self, other):
        return self & other

    def difference(self, other):
        return self - other

    def symmetric_difference(self, other):
        return self ^ other

    def issubset(self, other):
        return self <= other

    def issuperset(self, other):
        return self >= other


Set.register(Set__string)

cdef class Map__i32_i32:
    def __init__(self, items=None):
        if isinstance(items, Map__i32_i32):
            self._cpp_obj = (<Map__i32_i32> items)._cpp_obj
        else:
            self._cpp_obj = move(Map__i32_i32._make_instance(items))

    @staticmethod
    cdef create(shared_ptr[cmap[int32_t,int32_t]] c_items):
        inst = <Map__i32_i32>Map__i32_i32.__new__(Map__i32_i32)
        inst._cpp_obj = c_items
        return inst

    @staticmethod
    cdef unique_ptr[cmap[int32_t,int32_t]] _make_instance(object items) except *:
        cdef unique_ptr[cmap[int32_t,int32_t]] c_inst = make_unique[cmap[int32_t,int32_t]]()
        if items is not None:
            for key, item in items.items():
                if not isinstance(key, int):
                    raise TypeError(f"{key!r} is not of type int")
                key = <int32_t> key
                if not isinstance(item, int):
                    raise TypeError(f"{item!r} is not of type int")
                item = <int32_t> item

                deref(c_inst).insert(cpair[int32_t,int32_t](key,item))
        return move_unique(c_inst)

    def __getitem__(self, key):
        err = KeyError(f'{key}')
        if not self or key is None:
            raise err
        if not isinstance(key, int):
            raise err
        cdef int32_t ckey = key
        cdef cmap[int32_t,int32_t].iterator iter = deref(
            self._cpp_obj).find(ckey)
        if iter == deref(self._cpp_obj).end():
            raise err
        cdef int32_t citem = deref(iter).second
        return citem

    def __len__(self):
        return deref(self._cpp_obj).size()

    def __iter__(self):
        if not self:
            raise StopIteration
        cdef int32_t citem
        for pair in deref(self._cpp_obj):
            citem = pair.first
            yield citem

    def __richcmp__(self, other, op):
        cdef int cop = op
        if cop not in (2, 3):
            raise TypeError("unorderable types: {}, {}".format(type(self), type(other)))
        if not (isinstance(self, Mapping) and isinstance(other, Mapping)):
            return cop != 2
        if (len(self) != len(other)):
            return cop != 2

        for key in self:
            if key not in other:
                return cop != 2
            if other[key] != self[key]:
                return cop != 2

        return cop == 2

    def __hash__(self):
        if not self.__hash:
            self.__hash = hash(tuple(self.items()))
        return self.__hash

    def __repr__(self):
        if not self:
            return 'i{}'
        return f'i{{{", ".join(map(lambda i: f"{repr(i[0])}: {repr(i[1])}", self.items()))}}}'

    def __contains__(self, key):
        if not self or key is None:
            return False
        if not isinstance(key, int):
            return False
        cdef int32_t ckey = key
        return deref(self._cpp_obj).count(ckey) > 0

    def get(self, key, default=None):
        if not self or key is None:
            return default
        try:
            if not isinstance(key, int):
                key = int(key)
        except Exception:
            return default
        if not isinstance(key, int):
            return default
        if key not in self:
            return default
        return self[key]

    def keys(self):
        return self.__iter__()

    def values(self):
        if not self:
            raise StopIteration
        cdef int32_t citem
        for pair in deref(self._cpp_obj):
            citem = pair.second
            yield citem

    def items(self):
        if not self:
            raise StopIteration
        cdef int32_t ckey
        cdef int32_t citem
        for pair in deref(self._cpp_obj):
            ckey = pair.first
            citem = pair.second

            yield (ckey, citem)



Mapping.register(Map__i32_i32)

cdef class Map__i32_string:
    def __init__(self, items=None):
        if isinstance(items, Map__i32_string):
            self._cpp_obj = (<Map__i32_string> items)._cpp_obj
        else:
            self._cpp_obj = move(Map__i32_string._make_instance(items))

    @staticmethod
    cdef create(shared_ptr[cmap[int32_t,string]] c_items):
        inst = <Map__i32_string>Map__i32_string.__new__(Map__i32_string)
        inst._cpp_obj = c_items
        return inst

    @staticmethod
    cdef unique_ptr[cmap[int32_t,string]] _make_instance(object items) except *:
        cdef unique_ptr[cmap[int32_t,string]] c_inst = make_unique[cmap[int32_t,string]]()
        if items is not None:
            for key, item in items.items():
                if not isinstance(key, int):
                    raise TypeError(f"{key!r} is not of type int")
                key = <int32_t> key
                if not isinstance(item, str):
                    raise TypeError(f"{item!r} is not of type str")

                deref(c_inst).insert(cpair[int32_t,string](key,item.encode('UTF-8')))
        return move_unique(c_inst)

    def __getitem__(self, key):
        err = KeyError(f'{key}')
        if not self or key is None:
            raise err
        if not isinstance(key, int):
            raise err
        cdef int32_t ckey = key
        cdef cmap[int32_t,string].iterator iter = deref(
            self._cpp_obj).find(ckey)
        if iter == deref(self._cpp_obj).end():
            raise err
        cdef string citem = deref(iter).second
        return bytes(citem).decode('UTF-8')

    def __len__(self):
        return deref(self._cpp_obj).size()

    def __iter__(self):
        if not self:
            raise StopIteration
        cdef int32_t citem
        for pair in deref(self._cpp_obj):
            citem = pair.first
            yield citem

    def __richcmp__(self, other, op):
        cdef int cop = op
        if cop not in (2, 3):
            raise TypeError("unorderable types: {}, {}".format(type(self), type(other)))
        if not (isinstance(self, Mapping) and isinstance(other, Mapping)):
            return cop != 2
        if (len(self) != len(other)):
            return cop != 2

        for key in self:
            if key not in other:
                return cop != 2
            if other[key] != self[key]:
                return cop != 2

        return cop == 2

    def __hash__(self):
        if not self.__hash:
            self.__hash = hash(tuple(self.items()))
        return self.__hash

    def __repr__(self):
        if not self:
            return 'i{}'
        return f'i{{{", ".join(map(lambda i: f"{repr(i[0])}: {repr(i[1])}", self.items()))}}}'

    def __contains__(self, key):
        if not self or key is None:
            return False
        if not isinstance(key, int):
            return False
        cdef int32_t ckey = key
        return deref(self._cpp_obj).count(ckey) > 0

    def get(self, key, default=None):
        if not self or key is None:
            return default
        try:
            if not isinstance(key, int):
                key = int(key)
        except Exception:
            return default
        if not isinstance(key, int):
            return default
        if key not in self:
            return default
        return self[key]

    def keys(self):
        return self.__iter__()

    def values(self):
        if not self:
            raise StopIteration
        cdef string citem
        for pair in deref(self._cpp_obj):
            citem = pair.second
            yield bytes(citem).decode('UTF-8')

    def items(self):
        if not self:
            raise StopIteration
        cdef int32_t ckey
        cdef string citem
        for pair in deref(self._cpp_obj):
            ckey = pair.first
            citem = pair.second

            yield (ckey, bytes(citem).decode('UTF-8'))



Mapping.register(Map__i32_string)

cdef class Map__string_string:
    def __init__(self, items=None):
        if isinstance(items, Map__string_string):
            self._cpp_obj = (<Map__string_string> items)._cpp_obj
        else:
            self._cpp_obj = move(Map__string_string._make_instance(items))

    @staticmethod
    cdef create(shared_ptr[cmap[string,string]] c_items):
        inst = <Map__string_string>Map__string_string.__new__(Map__string_string)
        inst._cpp_obj = c_items
        return inst

    @staticmethod
    cdef unique_ptr[cmap[string,string]] _make_instance(object items) except *:
        cdef unique_ptr[cmap[string,string]] c_inst = make_unique[cmap[string,string]]()
        if items is not None:
            for key, item in items.items():
                if not isinstance(key, str):
                    raise TypeError(f"{key!r} is not of type str")
                if not isinstance(item, str):
                    raise TypeError(f"{item!r} is not of type str")

                deref(c_inst).insert(cpair[string,string](key.encode('UTF-8'),item.encode('UTF-8')))
        return move_unique(c_inst)

    def __getitem__(self, key):
        err = KeyError(f'{key}')
        if not self or key is None:
            raise err
        if not isinstance(key, str):
            raise err
        cdef string ckey = key.encode('UTF-8')
        cdef cmap[string,string].iterator iter = deref(
            self._cpp_obj).find(ckey)
        if iter == deref(self._cpp_obj).end():
            raise err
        cdef string citem = deref(iter).second
        return bytes(citem).decode('UTF-8')

    def __len__(self):
        return deref(self._cpp_obj).size()

    def __iter__(self):
        if not self:
            raise StopIteration
        cdef string citem
        for pair in deref(self._cpp_obj):
            citem = pair.first
            yield bytes(citem).decode('UTF-8')

    def __richcmp__(self, other, op):
        cdef int cop = op
        if cop not in (2, 3):
            raise TypeError("unorderable types: {}, {}".format(type(self), type(other)))
        if not (isinstance(self, Mapping) and isinstance(other, Mapping)):
            return cop != 2
        if (len(self) != len(other)):
            return cop != 2

        for key in self:
            if key not in other:
                return cop != 2
            if other[key] != self[key]:
                return cop != 2

        return cop == 2

    def __hash__(self):
        if not self.__hash:
            self.__hash = hash(tuple(self.items()))
        return self.__hash

    def __repr__(self):
        if not self:
            return 'i{}'
        return f'i{{{", ".join(map(lambda i: f"{repr(i[0])}: {repr(i[1])}", self.items()))}}}'

    def __contains__(self, key):
        if not self or key is None:
            return False
        if not isinstance(key, str):
            return False
        cdef string ckey = key.encode('UTF-8')
        return deref(self._cpp_obj).count(ckey) > 0

    def get(self, key, default=None):
        if not self or key is None:
            return default
        try:
            if not isinstance(key, str):
                key = str(key)
        except Exception:
            return default
        if not isinstance(key, str):
            return default
        if key not in self:
            return default
        return self[key]

    def keys(self):
        return self.__iter__()

    def values(self):
        if not self:
            raise StopIteration
        cdef string citem
        for pair in deref(self._cpp_obj):
            citem = pair.second
            yield bytes(citem).decode('UTF-8')

    def items(self):
        if not self:
            raise StopIteration
        cdef string ckey
        cdef string citem
        for pair in deref(self._cpp_obj):
            ckey = pair.first
            citem = pair.second

            yield (ckey.decode('UTF-8'), bytes(citem).decode('UTF-8'))



Mapping.register(Map__string_string)

myInt = 1337
name = cname().decode('UTF-8')
states = List__Map__string_i32.create(make_shared[vector[cmap[string,int32_t]]](cstates()))
x = 1.0
y = 1000000.0
z = 1000000000.0
zeroDoubleValue = 0.0
longDoubleValue = 0.000026
instagram = Internship.create(make_shared[cInternship](cinstagram()))
kRanges = List__Range.create(make_shared[vector[cRange]](ckRanges()))
internList = List__Internship.create(make_shared[vector[cInternship]](cinternList()))
pod_0 = struct1.create(make_shared[cstruct1](cpod_0()))
pod_1 = struct1.create(make_shared[cstruct1](cpod_1()))
pod_2 = struct2.create(make_shared[cstruct2](cpod_2()))
pod_3 = struct3.create(make_shared[cstruct3](cpod_3()))
u_1_1 = union1.create(make_shared[cunion1](cu_1_1()))
u_1_2 = union1.create(make_shared[cunion1](cu_1_2()))
u_1_3 = union1.create(make_shared[cunion1](cu_1_3()))
u_2_1 = union2.create(make_shared[cunion2](cu_2_1()))
u_2_2 = union2.create(make_shared[cunion2](cu_2_2()))
u_2_3 = union2.create(make_shared[cunion2](cu_2_3()))
u_2_4 = union2.create(make_shared[cunion2](cu_2_4()))
u_2_5 = union2.create(make_shared[cunion2](cu_2_5()))
u_2_6 = union2.create(make_shared[cunion2](cu_2_6()))
apostrophe = capostrophe().decode('UTF-8')
tripleApostrophe = ctripleApostrophe().decode('UTF-8')
quotationMark = cquotationMark().decode('UTF-8')
backslash = cbackslash().decode('UTF-8')
escaped_a = cescaped_a().decode('UTF-8')
char2ascii = Map__string_i32.create(make_shared[cmap[string,int32_t]](cchar2ascii()))
escaped_strings = List__string.create(make_shared[vector[string]](cescaped_strings()))
false_c = False
true_c = True
zero_byte = 0
zero16 = 0
zero32 = 0
zero64 = 0
zero_dot_zero = 0.0
empty_string = cempty_string().decode('UTF-8')
empty_int_list = List__i32.create(make_shared[vector[int32_t]](cempty_int_list()))
empty_string_list = List__string.create(make_shared[vector[string]](cempty_string_list()))
empty_int_set = Set__i32.create(make_shared[cset[int32_t]](cempty_int_set()))
empty_string_set = Set__string.create(make_shared[cset[string]](cempty_string_set()))
empty_int_int_map = Map__i32_i32.create(make_shared[cmap[int32_t,int32_t]](cempty_int_int_map()))
empty_int_string_map = Map__i32_string.create(make_shared[cmap[int32_t,string]](cempty_int_string_map()))
empty_string_int_map = Map__string_i32.create(make_shared[cmap[string,int32_t]](cempty_string_int_map()))
empty_string_string_map = Map__string_string.create(make_shared[cmap[string,string]](cempty_string_string_map()))
