#
# Autogenerated by Thrift
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#  @generated
#

from libcpp.memory cimport shared_ptr, make_shared, unique_ptr, make_unique
from libcpp.string cimport string
from libcpp cimport bool as cbool
from libcpp.iterator cimport inserter as cinserter
from cpython cimport bool as pbool
from libc.stdint cimport int8_t, int16_t, int32_t, int64_t, uint32_t
from cython.operator cimport dereference as deref, preincrement as inc, address as ptr_address
import thrift.py3.types
cimport thrift.py3.types
cimport thrift.py3.exceptions
from thrift.py3.types import NOTSET as __NOTSET
from thrift.py3.types cimport translate_cpp_enum_to_python
cimport thrift.py3.std_libcpp as std_libcpp
from thrift.py3.serializer import Protocol
cimport thrift.py3.serializer as serializer
from thrift.py3.serializer import deserialize, serialize
import folly.iobuf as __iobuf
from folly.optional cimport cOptional

import sys
import itertools
from collections import Sequence, Set, Mapping, Iterable
import enum as __enum
import warnings
import builtins as _builtins




cdef class List__i32:
    def __init__(self, items=None):
        if isinstance(items, List__i32):
            self._cpp_obj = (<List__i32> items)._cpp_obj
        else:
            self._cpp_obj = move(List__i32._make_instance(items))

    @staticmethod
    cdef create(shared_ptr[vector[int32_t]] c_items):
        inst = <List__i32>List__i32.__new__(List__i32)
        inst._cpp_obj = c_items
        return inst

    @staticmethod
    cdef unique_ptr[vector[int32_t]] _make_instance(object items) except *:
        cdef unique_ptr[vector[int32_t]] c_inst = make_unique[vector[int32_t]]()
        if items is not None:
            for item in items:
                if not isinstance(item, int):
                    raise TypeError(f"{item!r} is not of type int")
                item = <int32_t> item
                deref(c_inst).push_back(item)
        return move_unique(c_inst)

    def __add__(object self, object other):
        return type(self)(itertools.chain(self, other))

    def __getitem__(self, object index_obj):
        cdef shared_ptr[vector[int32_t]] c_inst
        cdef int32_t citem
        if isinstance(index_obj, slice):
            c_inst = make_shared[vector[int32_t]]()
            sz = deref(self._cpp_obj).size()
            for index in range(*index_obj.indices(sz)):
                citem = deref(self._cpp_obj.get())[index]
                deref(c_inst).push_back(citem)
            return List__i32.create(c_inst)
        else:
            index = <int?>index_obj
            size = len(self)
            # Convert a negative index
            if index < 0:
                index = size + index
            if index >= size or index < 0:
                raise IndexError('list index out of range')
            citem = deref(self._cpp_obj.get())[index]
            return citem

    def __len__(self):
        return deref(self._cpp_obj).size()

    def __richcmp__(self, other, op):
        cdef int cop = op
        if cop not in (2, 3):
            raise TypeError("unorderable types: {}, {}".format(type(self), type(other)))
        if not (isinstance(self, Iterable) and isinstance(other, Iterable)):
            return cop != 2
        if (len(self) != len(other)):
            return cop != 2

        for one, two in zip(self, other):
            if one != two:
                return cop != 2

        return cop == 2

    def __hash__(self):
        if not self.__hash:
            self.__hash = hash(tuple(self))
        return self.__hash

    def __contains__(self, item):
        if not self or item is None:
            return False
        if not isinstance(item, int):
            return False
        cdef int32_t citem = item
        cdef vector[int32_t] vec = deref(
            self._cpp_obj.get())
        return std_libcpp.find(vec.begin(), vec.end(), citem) != vec.end()

    def __iter__(self):
        if not self:
            raise StopIteration
        cdef int32_t citem
        for citem in deref(self._cpp_obj):
            yield citem

    def __repr__(self):
        if not self:
            return 'i[]'
        return f'i[{", ".join(map(repr, self))}]'

    def __reversed__(self):
        if not self:
            raise StopIteration
        cdef int32_t citem
        cdef vector[int32_t] vec = deref(
            self._cpp_obj.get())
        cdef vector[int32_t].reverse_iterator loc = vec.rbegin()
        while loc != vec.rend():
            citem = deref(loc)
            yield citem
            inc(loc)

    def index(self, item, start not None=__NOTSET, stop not None=__NOTSET):
        err = ValueError(f'{item} is not in list')
        if not self or item is None:
            raise err
        offset_begin = offset_end = 0
        if stop is not __NOTSET or start is not __NOTSET:
            # Like self[start:stop].index(item)
            size = len(self)
            stop = stop if stop is not __NOTSET else size
            start = start if start is not __NOTSET else 0
            # Convert stop to a negative position.
            if stop > 0:
                stop = min(stop - size, 0)
            if stop <= -size:
                raise err  # List would be empty
            offset_end = -stop
            # Convert start to always be positive
            if start < 0:
                start = max(size + start, 0)
            if start >= size:
                raise err  # past end of list
            offset_begin = start

        if not isinstance(item, int):
            raise err
        cdef int32_t citem = item
        cdef vector[int32_t] vec = deref(self._cpp_obj.get())
        cdef vector[int32_t].iterator end = std_libcpp.prev(vec.end(), <int64_t>offset_end)
        cdef vector[int32_t].iterator loc = std_libcpp.find(
            std_libcpp.next(vec.begin(), <int64_t>offset_begin),
            end,
            citem
        )
        if loc != end:
            return <int64_t> std_libcpp.distance(vec.begin(), loc)
        raise err

    def count(self, item):
        if not self or item is None:
            return 0
        if not isinstance(item, int):
            return 0
        cdef int32_t citem = item
        cdef vector[int32_t] vec = deref(self._cpp_obj.get())
        return <int64_t> std_libcpp.count(vec.begin(), vec.end(), citem)


Sequence.register(List__i32)

cdef class Map__i32_List__i32:
    def __init__(self, items=None):
        if isinstance(items, Map__i32_List__i32):
            self._cpp_obj = (<Map__i32_List__i32> items)._cpp_obj
        else:
            self._cpp_obj = move(Map__i32_List__i32._make_instance(items))

    @staticmethod
    cdef create(shared_ptr[cmap[int32_t,vector[int32_t]]] c_items):
        inst = <Map__i32_List__i32>Map__i32_List__i32.__new__(Map__i32_List__i32)
        inst._cpp_obj = c_items
        return inst

    @staticmethod
    cdef unique_ptr[cmap[int32_t,vector[int32_t]]] _make_instance(object items) except *:
        cdef unique_ptr[cmap[int32_t,vector[int32_t]]] c_inst = make_unique[cmap[int32_t,vector[int32_t]]]()
        if items is not None:
            for key, item in items.items():
                if not isinstance(key, int):
                    raise TypeError(f"{key!r} is not of type int")
                key = <int32_t> key
                if item is None:
                    raise TypeError("None is not of type _typing.Sequence[int]")
                if not isinstance(item, List__i32):
                    item = List__i32(item)

                deref(c_inst).insert(cpair[int32_t,vector[int32_t]](key,vector[int32_t](deref(List__i32(item)._cpp_obj.get()))))
        return move_unique(c_inst)

    def __getitem__(self, key):
        err = KeyError(f'{key}')
        if not self or key is None:
            raise err
        if not isinstance(key, int):
            raise err
        cdef int32_t ckey = key
        cdef cmap[int32_t,vector[int32_t]].iterator iter = deref(
            self._cpp_obj).find(ckey)
        if iter == deref(self._cpp_obj).end():
            raise err
        cdef vector[int32_t] citem = deref(iter).second
        return List__i32.create(
    make_shared[vector[int32_t]](citem))

    def __len__(self):
        return deref(self._cpp_obj).size()

    def __iter__(self):
        if not self:
            raise StopIteration
        cdef int32_t citem
        for pair in deref(self._cpp_obj):
            citem = pair.first
            yield citem

    def __richcmp__(self, other, op):
        cdef int cop = op
        if cop not in (2, 3):
            raise TypeError("unorderable types: {}, {}".format(type(self), type(other)))
        if not (isinstance(self, Mapping) and isinstance(other, Mapping)):
            return cop != 2
        if (len(self) != len(other)):
            return cop != 2

        for key in self:
            if key not in other:
                return cop != 2
            if other[key] != self[key]:
                return cop != 2

        return cop == 2

    def __hash__(self):
        if not self.__hash:
            self.__hash = hash(tuple(self.items()))
        return self.__hash

    def __repr__(self):
        if not self:
            return 'i{}'
        return f'i{{{", ".join(map(lambda i: f"{repr(i[0])}: {repr(i[1])}", self.items()))}}}'

    def __contains__(self, key):
        if not self or key is None:
            return False
        if not isinstance(key, int):
            return False
        cdef int32_t ckey = key
        return deref(self._cpp_obj).count(ckey) > 0

    def get(self, key, default=None):
        if not self or key is None:
            return default
        try:
            if not isinstance(key, int):
                key = int(key)
        except Exception:
            return default
        if not isinstance(key, int):
            return default
        if key not in self:
            return default
        return self[key]

    def keys(self):
        return self.__iter__()

    def values(self):
        if not self:
            raise StopIteration
        cdef vector[int32_t] citem
        for pair in deref(self._cpp_obj):
            citem = pair.second
            yield List__i32.create(
    make_shared[vector[int32_t]](citem))

    def items(self):
        if not self:
            raise StopIteration
        cdef int32_t ckey
        cdef vector[int32_t] citem
        for pair in deref(self._cpp_obj):
            ckey = pair.first
            citem = pair.second

            yield (ckey, List__i32.create(
    make_shared[vector[int32_t]](citem)))



Mapping.register(Map__i32_List__i32)

cdef class Set__i32:
    def __init__(self, items=None):
        if isinstance(items, Set__i32):
            self._cpp_obj = (<Set__i32> items)._cpp_obj
        else:
            self._cpp_obj = move(Set__i32._make_instance(items))

    @staticmethod
    cdef create(shared_ptr[cset[int32_t]] c_items):
        inst = <Set__i32>Set__i32.__new__(Set__i32)
        inst._cpp_obj = c_items
        return inst

    @staticmethod
    cdef unique_ptr[cset[int32_t]] _make_instance(object items) except *:
        cdef unique_ptr[cset[int32_t]] c_inst = make_unique[cset[int32_t]]()
        if items is not None:
            for item in items:
                if not isinstance(item, int):
                    raise TypeError(f"{item!r} is not of type int")
                item = <int32_t> item
                deref(c_inst).insert(item)
        return move_unique(c_inst)

    def __contains__(self, item):
        if not self or item is None:
            return False
        if not isinstance(item, int):
            return False
        return pbool(deref(self._cpp_obj).count(item))


    def __len__(self):
        return deref(self._cpp_obj).size()

    def __iter__(self):
        if not self:
            raise StopIteration
        for citem in deref(self._cpp_obj):
            yield citem

    def __repr__(self):
        if not self:
            return 'iset()'
        return f'i{{{", ".join(map(repr, self))}}}'

    def __richcmp__(self, other, op):
        cdef int cop = op
        cdef cset[int32_t] cself, cother
        cdef cbool retval
        if (isinstance(self, Set__i32) and
                isinstance(other, Set__i32)):
            cself = deref((<Set__i32> self)._cpp_obj)
            cother = deref((<Set__i32> other)._cpp_obj)
            # C level comparisons
            if cop == 0:    # Less Than (strict subset)
                if not cself.size() < cother.size():
                    return False
                for item in cself:
                    if not cother.count(item):
                        return False
                return True
            elif cop == 1:  # Less Than or Equal To  (subset)
                for item in cself:
                    if not cother.count(item):
                        return False
                return True
            elif cop == 2:  # Equivalent
                if cself.size() != cother.size():
                    return False
                for item in cself:
                    if not cother.count(item):
                        return False
                return True
            elif cop == 3:  # Not Equivalent
                for item in cself:
                    if not cother.count(item):
                        return True
                return cself.size() != cother.size()
            elif cop == 4:  # Greater Than (strict superset)
                if not cself.size() > cother.size():
                    return False
                for item in cother:
                    if not cself.count(item):
                        return False
                return True
            elif cop == 5:  # Greater Than or Equal To (superset)
                for item in cother:
                    if not cself.count(item):
                        return False
                return True

        # Python level comparisons
        if cop == 0:
            return Set.__lt__(self, other)
        elif cop == 1:
            return Set.__le__(self, other)
        elif cop == 2:
            return Set.__eq__(self, other)
        elif cop == 3:
            return Set.__ne__(self, other)
        elif cop == 4:
            return Set.__gt__(self, other)
        elif cop == 5:
            return Set.__ge__(self, other)

    def __hash__(self):
        if not self.__hash:
            self.__hash = hash(tuple(self))
        return self.__hash

    def __and__(self, other):
        if not isinstance(self, Set__i32):
            self = Set__i32(self)
        if not isinstance(other, Set__i32):
            other = Set__i32(other)

        cdef shared_ptr[cset[int32_t]] shretval = \
            make_shared[cset[int32_t]]()
        for citem in deref((<Set__i32> self)._cpp_obj):
            if deref((<Set__i32> other)._cpp_obj).count(citem) > 0:
                deref(shretval).insert(citem)
        return Set__i32.create(shretval)

    def __sub__(self, other):
        if not isinstance(self, Set__i32):
            self = Set__i32(self)
        if not isinstance(other, Set__i32):
            other = Set__i32(other)

        cdef shared_ptr[cset[int32_t]] shretval = \
            make_shared[cset[int32_t]]()
        for citem in deref((<Set__i32> self)._cpp_obj):
            if deref((<Set__i32> other)._cpp_obj).count(citem) == 0:
                deref(shretval).insert(citem)
        return Set__i32.create(shretval)

    def __or__(self, other):
        if not isinstance(self, Set__i32):
            self = Set__i32(self)
        if not isinstance(other, Set__i32):
            other = Set__i32(other)

        cdef shared_ptr[cset[int32_t]] shretval = \
            make_shared[cset[int32_t]]()
        for citem in deref((<Set__i32> self)._cpp_obj):
                deref(shretval).insert(citem)
        for citem in deref((<Set__i32> other)._cpp_obj):
                deref(shretval).insert(citem)
        return Set__i32.create(shretval)

    def __xor__(self, other):
        if not isinstance(self, Set__i32):
            self = Set__i32(self)
        if not isinstance(other, Set__i32):
            other = Set__i32(other)

        cdef shared_ptr[cset[int32_t]] shretval = \
            make_shared[cset[int32_t]]()
        for citem in deref((<Set__i32> self)._cpp_obj):
            if deref((<Set__i32> other)._cpp_obj).count(citem) == 0:
                deref(shretval).insert(citem)
        for citem in deref((<Set__i32> other)._cpp_obj):
            if deref((<Set__i32> self)._cpp_obj).count(citem) == 0:
                deref(shretval).insert(citem)
        return Set__i32.create(shretval)

    def isdisjoint(self, other):
        return len(self & other) == 0

    def union(self, other):
        return self | other

    def intersection(self, other):
        return self & other

    def difference(self, other):
        return self - other

    def symmetric_difference(self, other):
        return self ^ other

    def issubset(self, other):
        return self <= other

    def issuperset(self, other):
        return self >= other


Set.register(Set__i32)

cdef class Map__i32_Set__i32:
    def __init__(self, items=None):
        if isinstance(items, Map__i32_Set__i32):
            self._cpp_obj = (<Map__i32_Set__i32> items)._cpp_obj
        else:
            self._cpp_obj = move(Map__i32_Set__i32._make_instance(items))

    @staticmethod
    cdef create(shared_ptr[cmap[int32_t,cset[int32_t]]] c_items):
        inst = <Map__i32_Set__i32>Map__i32_Set__i32.__new__(Map__i32_Set__i32)
        inst._cpp_obj = c_items
        return inst

    @staticmethod
    cdef unique_ptr[cmap[int32_t,cset[int32_t]]] _make_instance(object items) except *:
        cdef unique_ptr[cmap[int32_t,cset[int32_t]]] c_inst = make_unique[cmap[int32_t,cset[int32_t]]]()
        if items is not None:
            for key, item in items.items():
                if not isinstance(key, int):
                    raise TypeError(f"{key!r} is not of type int")
                key = <int32_t> key
                if item is None:
                    raise TypeError("None is not of type _typing.AbstractSet[int]")
                if not isinstance(item, Set__i32):
                    item = Set__i32(item)

                deref(c_inst).insert(cpair[int32_t,cset[int32_t]](key,cset[int32_t](deref(Set__i32(item)._cpp_obj.get()))))
        return move_unique(c_inst)

    def __getitem__(self, key):
        err = KeyError(f'{key}')
        if not self or key is None:
            raise err
        if not isinstance(key, int):
            raise err
        cdef int32_t ckey = key
        cdef cmap[int32_t,cset[int32_t]].iterator iter = deref(
            self._cpp_obj).find(ckey)
        if iter == deref(self._cpp_obj).end():
            raise err
        cdef cset[int32_t] citem = deref(iter).second
        return Set__i32.create(
    make_shared[cset[int32_t]](citem))

    def __len__(self):
        return deref(self._cpp_obj).size()

    def __iter__(self):
        if not self:
            raise StopIteration
        cdef int32_t citem
        for pair in deref(self._cpp_obj):
            citem = pair.first
            yield citem

    def __richcmp__(self, other, op):
        cdef int cop = op
        if cop not in (2, 3):
            raise TypeError("unorderable types: {}, {}".format(type(self), type(other)))
        if not (isinstance(self, Mapping) and isinstance(other, Mapping)):
            return cop != 2
        if (len(self) != len(other)):
            return cop != 2

        for key in self:
            if key not in other:
                return cop != 2
            if other[key] != self[key]:
                return cop != 2

        return cop == 2

    def __hash__(self):
        if not self.__hash:
            self.__hash = hash(tuple(self.items()))
        return self.__hash

    def __repr__(self):
        if not self:
            return 'i{}'
        return f'i{{{", ".join(map(lambda i: f"{repr(i[0])}: {repr(i[1])}", self.items()))}}}'

    def __contains__(self, key):
        if not self or key is None:
            return False
        if not isinstance(key, int):
            return False
        cdef int32_t ckey = key
        return deref(self._cpp_obj).count(ckey) > 0

    def get(self, key, default=None):
        if not self or key is None:
            return default
        try:
            if not isinstance(key, int):
                key = int(key)
        except Exception:
            return default
        if not isinstance(key, int):
            return default
        if key not in self:
            return default
        return self[key]

    def keys(self):
        return self.__iter__()

    def values(self):
        if not self:
            raise StopIteration
        cdef cset[int32_t] citem
        for pair in deref(self._cpp_obj):
            citem = pair.second
            yield Set__i32.create(
    make_shared[cset[int32_t]](citem))

    def items(self):
        if not self:
            raise StopIteration
        cdef int32_t ckey
        cdef cset[int32_t] citem
        for pair in deref(self._cpp_obj):
            ckey = pair.first
            citem = pair.second

            yield (ckey, Set__i32.create(
    make_shared[cset[int32_t]](citem)))



Mapping.register(Map__i32_Set__i32)

cdef class Map__i32_i32:
    def __init__(self, items=None):
        if isinstance(items, Map__i32_i32):
            self._cpp_obj = (<Map__i32_i32> items)._cpp_obj
        else:
            self._cpp_obj = move(Map__i32_i32._make_instance(items))

    @staticmethod
    cdef create(shared_ptr[cmap[int32_t,int32_t]] c_items):
        inst = <Map__i32_i32>Map__i32_i32.__new__(Map__i32_i32)
        inst._cpp_obj = c_items
        return inst

    @staticmethod
    cdef unique_ptr[cmap[int32_t,int32_t]] _make_instance(object items) except *:
        cdef unique_ptr[cmap[int32_t,int32_t]] c_inst = make_unique[cmap[int32_t,int32_t]]()
        if items is not None:
            for key, item in items.items():
                if not isinstance(key, int):
                    raise TypeError(f"{key!r} is not of type int")
                key = <int32_t> key
                if not isinstance(item, int):
                    raise TypeError(f"{item!r} is not of type int")
                item = <int32_t> item

                deref(c_inst).insert(cpair[int32_t,int32_t](key,item))
        return move_unique(c_inst)

    def __getitem__(self, key):
        err = KeyError(f'{key}')
        if not self or key is None:
            raise err
        if not isinstance(key, int):
            raise err
        cdef int32_t ckey = key
        cdef cmap[int32_t,int32_t].iterator iter = deref(
            self._cpp_obj).find(ckey)
        if iter == deref(self._cpp_obj).end():
            raise err
        cdef int32_t citem = deref(iter).second
        return citem

    def __len__(self):
        return deref(self._cpp_obj).size()

    def __iter__(self):
        if not self:
            raise StopIteration
        cdef int32_t citem
        for pair in deref(self._cpp_obj):
            citem = pair.first
            yield citem

    def __richcmp__(self, other, op):
        cdef int cop = op
        if cop not in (2, 3):
            raise TypeError("unorderable types: {}, {}".format(type(self), type(other)))
        if not (isinstance(self, Mapping) and isinstance(other, Mapping)):
            return cop != 2
        if (len(self) != len(other)):
            return cop != 2

        for key in self:
            if key not in other:
                return cop != 2
            if other[key] != self[key]:
                return cop != 2

        return cop == 2

    def __hash__(self):
        if not self.__hash:
            self.__hash = hash(tuple(self.items()))
        return self.__hash

    def __repr__(self):
        if not self:
            return 'i{}'
        return f'i{{{", ".join(map(lambda i: f"{repr(i[0])}: {repr(i[1])}", self.items()))}}}'

    def __contains__(self, key):
        if not self or key is None:
            return False
        if not isinstance(key, int):
            return False
        cdef int32_t ckey = key
        return deref(self._cpp_obj).count(ckey) > 0

    def get(self, key, default=None):
        if not self or key is None:
            return default
        try:
            if not isinstance(key, int):
                key = int(key)
        except Exception:
            return default
        if not isinstance(key, int):
            return default
        if key not in self:
            return default
        return self[key]

    def keys(self):
        return self.__iter__()

    def values(self):
        if not self:
            raise StopIteration
        cdef int32_t citem
        for pair in deref(self._cpp_obj):
            citem = pair.second
            yield citem

    def items(self):
        if not self:
            raise StopIteration
        cdef int32_t ckey
        cdef int32_t citem
        for pair in deref(self._cpp_obj):
            ckey = pair.first
            citem = pair.second

            yield (ckey, citem)



Mapping.register(Map__i32_i32)

cdef class List__Map__i32_i32:
    def __init__(self, items=None):
        if isinstance(items, List__Map__i32_i32):
            self._cpp_obj = (<List__Map__i32_i32> items)._cpp_obj
        else:
            self._cpp_obj = move(List__Map__i32_i32._make_instance(items))

    @staticmethod
    cdef create(shared_ptr[vector[cmap[int32_t,int32_t]]] c_items):
        inst = <List__Map__i32_i32>List__Map__i32_i32.__new__(List__Map__i32_i32)
        inst._cpp_obj = c_items
        return inst

    @staticmethod
    cdef unique_ptr[vector[cmap[int32_t,int32_t]]] _make_instance(object items) except *:
        cdef unique_ptr[vector[cmap[int32_t,int32_t]]] c_inst = make_unique[vector[cmap[int32_t,int32_t]]]()
        if items is not None:
            for item in items:
                if item is None:
                    raise TypeError("None is not of the type _typing.Mapping[int, int]")
                if not isinstance(item, Map__i32_i32):
                    item = Map__i32_i32(item)
                deref(c_inst).push_back(cmap[int32_t,int32_t](deref(Map__i32_i32(item)._cpp_obj.get())))
        return move_unique(c_inst)

    def __add__(object self, object other):
        return type(self)(itertools.chain(self, other))

    def __getitem__(self, object index_obj):
        cdef shared_ptr[vector[cmap[int32_t,int32_t]]] c_inst
        cdef cmap[int32_t,int32_t] citem
        if isinstance(index_obj, slice):
            c_inst = make_shared[vector[cmap[int32_t,int32_t]]]()
            sz = deref(self._cpp_obj).size()
            for index in range(*index_obj.indices(sz)):
                citem = deref(self._cpp_obj.get())[index]
                deref(c_inst).push_back(citem)
            return List__Map__i32_i32.create(c_inst)
        else:
            index = <int?>index_obj
            size = len(self)
            # Convert a negative index
            if index < 0:
                index = size + index
            if index >= size or index < 0:
                raise IndexError('list index out of range')
            citem = deref(self._cpp_obj.get())[index]
            return Map__i32_i32.create(
    make_shared[cmap[int32_t,int32_t]](citem))

    def __len__(self):
        return deref(self._cpp_obj).size()

    def __richcmp__(self, other, op):
        cdef int cop = op
        if cop not in (2, 3):
            raise TypeError("unorderable types: {}, {}".format(type(self), type(other)))
        if not (isinstance(self, Iterable) and isinstance(other, Iterable)):
            return cop != 2
        if (len(self) != len(other)):
            return cop != 2

        for one, two in zip(self, other):
            if one != two:
                return cop != 2

        return cop == 2

    def __hash__(self):
        if not self.__hash:
            self.__hash = hash(tuple(self))
        return self.__hash

    def __contains__(self, item):
        if not self or item is None:
            return False
        try:
            if not isinstance(item, Map__i32_i32):
                item = Map__i32_i32(item)
        except Exception:
            return False
        if not isinstance(item, Map__i32_i32):
            return False
        cdef cmap[int32_t,int32_t] citem = cmap[int32_t,int32_t](deref(Map__i32_i32(item)._cpp_obj.get()))
        cdef vector[cmap[int32_t,int32_t]] vec = deref(
            self._cpp_obj.get())
        return std_libcpp.find(vec.begin(), vec.end(), citem) != vec.end()

    def __iter__(self):
        if not self:
            raise StopIteration
        cdef cmap[int32_t,int32_t] citem
        for citem in deref(self._cpp_obj):
            yield Map__i32_i32.create(
    make_shared[cmap[int32_t,int32_t]](citem))

    def __repr__(self):
        if not self:
            return 'i[]'
        return f'i[{", ".join(map(repr, self))}]'

    def __reversed__(self):
        if not self:
            raise StopIteration
        cdef cmap[int32_t,int32_t] citem
        cdef vector[cmap[int32_t,int32_t]] vec = deref(
            self._cpp_obj.get())
        cdef vector[cmap[int32_t,int32_t]].reverse_iterator loc = vec.rbegin()
        while loc != vec.rend():
            citem = deref(loc)
            yield Map__i32_i32.create(
    make_shared[cmap[int32_t,int32_t]](citem))
            inc(loc)

    def index(self, item, start not None=__NOTSET, stop not None=__NOTSET):
        err = ValueError(f'{item} is not in list')
        if not self or item is None:
            raise err
        offset_begin = offset_end = 0
        if stop is not __NOTSET or start is not __NOTSET:
            # Like self[start:stop].index(item)
            size = len(self)
            stop = stop if stop is not __NOTSET else size
            start = start if start is not __NOTSET else 0
            # Convert stop to a negative position.
            if stop > 0:
                stop = min(stop - size, 0)
            if stop <= -size:
                raise err  # List would be empty
            offset_end = -stop
            # Convert start to always be positive
            if start < 0:
                start = max(size + start, 0)
            if start >= size:
                raise err  # past end of list
            offset_begin = start

        try:
            if not isinstance(item, Map__i32_i32):
                item = Map__i32_i32(item)
        except Exception:
            raise err from None
        if not isinstance(item, Map__i32_i32):
            raise err
        cdef cmap[int32_t,int32_t] citem = cmap[int32_t,int32_t](deref(Map__i32_i32(item)._cpp_obj.get()))
        cdef vector[cmap[int32_t,int32_t]] vec = deref(self._cpp_obj.get())
        cdef vector[cmap[int32_t,int32_t]].iterator end = std_libcpp.prev(vec.end(), <int64_t>offset_end)
        cdef vector[cmap[int32_t,int32_t]].iterator loc = std_libcpp.find(
            std_libcpp.next(vec.begin(), <int64_t>offset_begin),
            end,
            citem
        )
        if loc != end:
            return <int64_t> std_libcpp.distance(vec.begin(), loc)
        raise err

    def count(self, item):
        if not self or item is None:
            return 0
        try:
            if not isinstance(item, Map__i32_i32):
                item = Map__i32_i32(item)
        except Exception:
            return 0
        if not isinstance(item, Map__i32_i32):
            return 0
        cdef cmap[int32_t,int32_t] citem = cmap[int32_t,int32_t](deref(Map__i32_i32(item)._cpp_obj.get()))
        cdef vector[cmap[int32_t,int32_t]] vec = deref(self._cpp_obj.get())
        return <int64_t> std_libcpp.count(vec.begin(), vec.end(), citem)


Sequence.register(List__Map__i32_i32)

cdef class List__Set__i32:
    def __init__(self, items=None):
        if isinstance(items, List__Set__i32):
            self._cpp_obj = (<List__Set__i32> items)._cpp_obj
        else:
            self._cpp_obj = move(List__Set__i32._make_instance(items))

    @staticmethod
    cdef create(shared_ptr[vector[cset[int32_t]]] c_items):
        inst = <List__Set__i32>List__Set__i32.__new__(List__Set__i32)
        inst._cpp_obj = c_items
        return inst

    @staticmethod
    cdef unique_ptr[vector[cset[int32_t]]] _make_instance(object items) except *:
        cdef unique_ptr[vector[cset[int32_t]]] c_inst = make_unique[vector[cset[int32_t]]]()
        if items is not None:
            for item in items:
                if item is None:
                    raise TypeError("None is not of the type _typing.AbstractSet[int]")
                if not isinstance(item, Set__i32):
                    item = Set__i32(item)
                deref(c_inst).push_back(cset[int32_t](deref(Set__i32(item)._cpp_obj.get())))
        return move_unique(c_inst)

    def __add__(object self, object other):
        return type(self)(itertools.chain(self, other))

    def __getitem__(self, object index_obj):
        cdef shared_ptr[vector[cset[int32_t]]] c_inst
        cdef cset[int32_t] citem
        if isinstance(index_obj, slice):
            c_inst = make_shared[vector[cset[int32_t]]]()
            sz = deref(self._cpp_obj).size()
            for index in range(*index_obj.indices(sz)):
                citem = deref(self._cpp_obj.get())[index]
                deref(c_inst).push_back(citem)
            return List__Set__i32.create(c_inst)
        else:
            index = <int?>index_obj
            size = len(self)
            # Convert a negative index
            if index < 0:
                index = size + index
            if index >= size or index < 0:
                raise IndexError('list index out of range')
            citem = deref(self._cpp_obj.get())[index]
            return Set__i32.create(
    make_shared[cset[int32_t]](citem))

    def __len__(self):
        return deref(self._cpp_obj).size()

    def __richcmp__(self, other, op):
        cdef int cop = op
        if cop not in (2, 3):
            raise TypeError("unorderable types: {}, {}".format(type(self), type(other)))
        if not (isinstance(self, Iterable) and isinstance(other, Iterable)):
            return cop != 2
        if (len(self) != len(other)):
            return cop != 2

        for one, two in zip(self, other):
            if one != two:
                return cop != 2

        return cop == 2

    def __hash__(self):
        if not self.__hash:
            self.__hash = hash(tuple(self))
        return self.__hash

    def __contains__(self, item):
        if not self or item is None:
            return False
        try:
            if not isinstance(item, Set__i32):
                item = Set__i32(item)
        except Exception:
            return False
        if not isinstance(item, Set__i32):
            return False
        cdef cset[int32_t] citem = cset[int32_t](deref(Set__i32(item)._cpp_obj.get()))
        cdef vector[cset[int32_t]] vec = deref(
            self._cpp_obj.get())
        return std_libcpp.find(vec.begin(), vec.end(), citem) != vec.end()

    def __iter__(self):
        if not self:
            raise StopIteration
        cdef cset[int32_t] citem
        for citem in deref(self._cpp_obj):
            yield Set__i32.create(
    make_shared[cset[int32_t]](citem))

    def __repr__(self):
        if not self:
            return 'i[]'
        return f'i[{", ".join(map(repr, self))}]'

    def __reversed__(self):
        if not self:
            raise StopIteration
        cdef cset[int32_t] citem
        cdef vector[cset[int32_t]] vec = deref(
            self._cpp_obj.get())
        cdef vector[cset[int32_t]].reverse_iterator loc = vec.rbegin()
        while loc != vec.rend():
            citem = deref(loc)
            yield Set__i32.create(
    make_shared[cset[int32_t]](citem))
            inc(loc)

    def index(self, item, start not None=__NOTSET, stop not None=__NOTSET):
        err = ValueError(f'{item} is not in list')
        if not self or item is None:
            raise err
        offset_begin = offset_end = 0
        if stop is not __NOTSET or start is not __NOTSET:
            # Like self[start:stop].index(item)
            size = len(self)
            stop = stop if stop is not __NOTSET else size
            start = start if start is not __NOTSET else 0
            # Convert stop to a negative position.
            if stop > 0:
                stop = min(stop - size, 0)
            if stop <= -size:
                raise err  # List would be empty
            offset_end = -stop
            # Convert start to always be positive
            if start < 0:
                start = max(size + start, 0)
            if start >= size:
                raise err  # past end of list
            offset_begin = start

        try:
            if not isinstance(item, Set__i32):
                item = Set__i32(item)
        except Exception:
            raise err from None
        if not isinstance(item, Set__i32):
            raise err
        cdef cset[int32_t] citem = cset[int32_t](deref(Set__i32(item)._cpp_obj.get()))
        cdef vector[cset[int32_t]] vec = deref(self._cpp_obj.get())
        cdef vector[cset[int32_t]].iterator end = std_libcpp.prev(vec.end(), <int64_t>offset_end)
        cdef vector[cset[int32_t]].iterator loc = std_libcpp.find(
            std_libcpp.next(vec.begin(), <int64_t>offset_begin),
            end,
            citem
        )
        if loc != end:
            return <int64_t> std_libcpp.distance(vec.begin(), loc)
        raise err

    def count(self, item):
        if not self or item is None:
            return 0
        try:
            if not isinstance(item, Set__i32):
                item = Set__i32(item)
        except Exception:
            return 0
        if not isinstance(item, Set__i32):
            return 0
        cdef cset[int32_t] citem = cset[int32_t](deref(Set__i32(item)._cpp_obj.get()))
        cdef vector[cset[int32_t]] vec = deref(self._cpp_obj.get())
        return <int64_t> std_libcpp.count(vec.begin(), vec.end(), citem)


Sequence.register(List__Set__i32)

cdef class Map__i32_Map__i32_Set__i32:
    def __init__(self, items=None):
        if isinstance(items, Map__i32_Map__i32_Set__i32):
            self._cpp_obj = (<Map__i32_Map__i32_Set__i32> items)._cpp_obj
        else:
            self._cpp_obj = move(Map__i32_Map__i32_Set__i32._make_instance(items))

    @staticmethod
    cdef create(shared_ptr[cmap[int32_t,cmap[int32_t,cset[int32_t]]]] c_items):
        inst = <Map__i32_Map__i32_Set__i32>Map__i32_Map__i32_Set__i32.__new__(Map__i32_Map__i32_Set__i32)
        inst._cpp_obj = c_items
        return inst

    @staticmethod
    cdef unique_ptr[cmap[int32_t,cmap[int32_t,cset[int32_t]]]] _make_instance(object items) except *:
        cdef unique_ptr[cmap[int32_t,cmap[int32_t,cset[int32_t]]]] c_inst = make_unique[cmap[int32_t,cmap[int32_t,cset[int32_t]]]]()
        if items is not None:
            for key, item in items.items():
                if not isinstance(key, int):
                    raise TypeError(f"{key!r} is not of type int")
                key = <int32_t> key
                if item is None:
                    raise TypeError("None is not of type _typing.Mapping[int, _typing.AbstractSet[int]]")
                if not isinstance(item, Map__i32_Set__i32):
                    item = Map__i32_Set__i32(item)

                deref(c_inst).insert(cpair[int32_t,cmap[int32_t,cset[int32_t]]](key,cmap[int32_t,cset[int32_t]](deref(Map__i32_Set__i32(item)._cpp_obj.get()))))
        return move_unique(c_inst)

    def __getitem__(self, key):
        err = KeyError(f'{key}')
        if not self or key is None:
            raise err
        if not isinstance(key, int):
            raise err
        cdef int32_t ckey = key
        cdef cmap[int32_t,cmap[int32_t,cset[int32_t]]].iterator iter = deref(
            self._cpp_obj).find(ckey)
        if iter == deref(self._cpp_obj).end():
            raise err
        cdef cmap[int32_t,cset[int32_t]] citem = deref(iter).second
        return Map__i32_Set__i32.create(
    make_shared[cmap[int32_t,cset[int32_t]]](citem))

    def __len__(self):
        return deref(self._cpp_obj).size()

    def __iter__(self):
        if not self:
            raise StopIteration
        cdef int32_t citem
        for pair in deref(self._cpp_obj):
            citem = pair.first
            yield citem

    def __richcmp__(self, other, op):
        cdef int cop = op
        if cop not in (2, 3):
            raise TypeError("unorderable types: {}, {}".format(type(self), type(other)))
        if not (isinstance(self, Mapping) and isinstance(other, Mapping)):
            return cop != 2
        if (len(self) != len(other)):
            return cop != 2

        for key in self:
            if key not in other:
                return cop != 2
            if other[key] != self[key]:
                return cop != 2

        return cop == 2

    def __hash__(self):
        if not self.__hash:
            self.__hash = hash(tuple(self.items()))
        return self.__hash

    def __repr__(self):
        if not self:
            return 'i{}'
        return f'i{{{", ".join(map(lambda i: f"{repr(i[0])}: {repr(i[1])}", self.items()))}}}'

    def __contains__(self, key):
        if not self or key is None:
            return False
        if not isinstance(key, int):
            return False
        cdef int32_t ckey = key
        return deref(self._cpp_obj).count(ckey) > 0

    def get(self, key, default=None):
        if not self or key is None:
            return default
        try:
            if not isinstance(key, int):
                key = int(key)
        except Exception:
            return default
        if not isinstance(key, int):
            return default
        if key not in self:
            return default
        return self[key]

    def keys(self):
        return self.__iter__()

    def values(self):
        if not self:
            raise StopIteration
        cdef cmap[int32_t,cset[int32_t]] citem
        for pair in deref(self._cpp_obj):
            citem = pair.second
            yield Map__i32_Set__i32.create(
    make_shared[cmap[int32_t,cset[int32_t]]](citem))

    def items(self):
        if not self:
            raise StopIteration
        cdef int32_t ckey
        cdef cmap[int32_t,cset[int32_t]] citem
        for pair in deref(self._cpp_obj):
            ckey = pair.first
            citem = pair.second

            yield (ckey, Map__i32_Set__i32.create(
    make_shared[cmap[int32_t,cset[int32_t]]](citem)))



Mapping.register(Map__i32_Map__i32_Set__i32)

cdef class List__Map__i32_Map__i32_Set__i32:
    def __init__(self, items=None):
        if isinstance(items, List__Map__i32_Map__i32_Set__i32):
            self._cpp_obj = (<List__Map__i32_Map__i32_Set__i32> items)._cpp_obj
        else:
            self._cpp_obj = move(List__Map__i32_Map__i32_Set__i32._make_instance(items))

    @staticmethod
    cdef create(shared_ptr[vector[cmap[int32_t,cmap[int32_t,cset[int32_t]]]]] c_items):
        inst = <List__Map__i32_Map__i32_Set__i32>List__Map__i32_Map__i32_Set__i32.__new__(List__Map__i32_Map__i32_Set__i32)
        inst._cpp_obj = c_items
        return inst

    @staticmethod
    cdef unique_ptr[vector[cmap[int32_t,cmap[int32_t,cset[int32_t]]]]] _make_instance(object items) except *:
        cdef unique_ptr[vector[cmap[int32_t,cmap[int32_t,cset[int32_t]]]]] c_inst = make_unique[vector[cmap[int32_t,cmap[int32_t,cset[int32_t]]]]]()
        if items is not None:
            for item in items:
                if item is None:
                    raise TypeError("None is not of the type _typing.Mapping[int, _typing.Mapping[int, _typing.AbstractSet[int]]]")
                if not isinstance(item, Map__i32_Map__i32_Set__i32):
                    item = Map__i32_Map__i32_Set__i32(item)
                deref(c_inst).push_back(cmap[int32_t,cmap[int32_t,cset[int32_t]]](deref(Map__i32_Map__i32_Set__i32(item)._cpp_obj.get())))
        return move_unique(c_inst)

    def __add__(object self, object other):
        return type(self)(itertools.chain(self, other))

    def __getitem__(self, object index_obj):
        cdef shared_ptr[vector[cmap[int32_t,cmap[int32_t,cset[int32_t]]]]] c_inst
        cdef cmap[int32_t,cmap[int32_t,cset[int32_t]]] citem
        if isinstance(index_obj, slice):
            c_inst = make_shared[vector[cmap[int32_t,cmap[int32_t,cset[int32_t]]]]]()
            sz = deref(self._cpp_obj).size()
            for index in range(*index_obj.indices(sz)):
                citem = deref(self._cpp_obj.get())[index]
                deref(c_inst).push_back(citem)
            return List__Map__i32_Map__i32_Set__i32.create(c_inst)
        else:
            index = <int?>index_obj
            size = len(self)
            # Convert a negative index
            if index < 0:
                index = size + index
            if index >= size or index < 0:
                raise IndexError('list index out of range')
            citem = deref(self._cpp_obj.get())[index]
            return Map__i32_Map__i32_Set__i32.create(
    make_shared[cmap[int32_t,cmap[int32_t,cset[int32_t]]]](citem))

    def __len__(self):
        return deref(self._cpp_obj).size()

    def __richcmp__(self, other, op):
        cdef int cop = op
        if cop not in (2, 3):
            raise TypeError("unorderable types: {}, {}".format(type(self), type(other)))
        if not (isinstance(self, Iterable) and isinstance(other, Iterable)):
            return cop != 2
        if (len(self) != len(other)):
            return cop != 2

        for one, two in zip(self, other):
            if one != two:
                return cop != 2

        return cop == 2

    def __hash__(self):
        if not self.__hash:
            self.__hash = hash(tuple(self))
        return self.__hash

    def __contains__(self, item):
        if not self or item is None:
            return False
        try:
            if not isinstance(item, Map__i32_Map__i32_Set__i32):
                item = Map__i32_Map__i32_Set__i32(item)
        except Exception:
            return False
        if not isinstance(item, Map__i32_Map__i32_Set__i32):
            return False
        cdef cmap[int32_t,cmap[int32_t,cset[int32_t]]] citem = cmap[int32_t,cmap[int32_t,cset[int32_t]]](deref(Map__i32_Map__i32_Set__i32(item)._cpp_obj.get()))
        cdef vector[cmap[int32_t,cmap[int32_t,cset[int32_t]]]] vec = deref(
            self._cpp_obj.get())
        return std_libcpp.find(vec.begin(), vec.end(), citem) != vec.end()

    def __iter__(self):
        if not self:
            raise StopIteration
        cdef cmap[int32_t,cmap[int32_t,cset[int32_t]]] citem
        for citem in deref(self._cpp_obj):
            yield Map__i32_Map__i32_Set__i32.create(
    make_shared[cmap[int32_t,cmap[int32_t,cset[int32_t]]]](citem))

    def __repr__(self):
        if not self:
            return 'i[]'
        return f'i[{", ".join(map(repr, self))}]'

    def __reversed__(self):
        if not self:
            raise StopIteration
        cdef cmap[int32_t,cmap[int32_t,cset[int32_t]]] citem
        cdef vector[cmap[int32_t,cmap[int32_t,cset[int32_t]]]] vec = deref(
            self._cpp_obj.get())
        cdef vector[cmap[int32_t,cmap[int32_t,cset[int32_t]]]].reverse_iterator loc = vec.rbegin()
        while loc != vec.rend():
            citem = deref(loc)
            yield Map__i32_Map__i32_Set__i32.create(
    make_shared[cmap[int32_t,cmap[int32_t,cset[int32_t]]]](citem))
            inc(loc)

    def index(self, item, start not None=__NOTSET, stop not None=__NOTSET):
        err = ValueError(f'{item} is not in list')
        if not self or item is None:
            raise err
        offset_begin = offset_end = 0
        if stop is not __NOTSET or start is not __NOTSET:
            # Like self[start:stop].index(item)
            size = len(self)
            stop = stop if stop is not __NOTSET else size
            start = start if start is not __NOTSET else 0
            # Convert stop to a negative position.
            if stop > 0:
                stop = min(stop - size, 0)
            if stop <= -size:
                raise err  # List would be empty
            offset_end = -stop
            # Convert start to always be positive
            if start < 0:
                start = max(size + start, 0)
            if start >= size:
                raise err  # past end of list
            offset_begin = start

        try:
            if not isinstance(item, Map__i32_Map__i32_Set__i32):
                item = Map__i32_Map__i32_Set__i32(item)
        except Exception:
            raise err from None
        if not isinstance(item, Map__i32_Map__i32_Set__i32):
            raise err
        cdef cmap[int32_t,cmap[int32_t,cset[int32_t]]] citem = cmap[int32_t,cmap[int32_t,cset[int32_t]]](deref(Map__i32_Map__i32_Set__i32(item)._cpp_obj.get()))
        cdef vector[cmap[int32_t,cmap[int32_t,cset[int32_t]]]] vec = deref(self._cpp_obj.get())
        cdef vector[cmap[int32_t,cmap[int32_t,cset[int32_t]]]].iterator end = std_libcpp.prev(vec.end(), <int64_t>offset_end)
        cdef vector[cmap[int32_t,cmap[int32_t,cset[int32_t]]]].iterator loc = std_libcpp.find(
            std_libcpp.next(vec.begin(), <int64_t>offset_begin),
            end,
            citem
        )
        if loc != end:
            return <int64_t> std_libcpp.distance(vec.begin(), loc)
        raise err

    def count(self, item):
        if not self or item is None:
            return 0
        try:
            if not isinstance(item, Map__i32_Map__i32_Set__i32):
                item = Map__i32_Map__i32_Set__i32(item)
        except Exception:
            return 0
        if not isinstance(item, Map__i32_Map__i32_Set__i32):
            return 0
        cdef cmap[int32_t,cmap[int32_t,cset[int32_t]]] citem = cmap[int32_t,cmap[int32_t,cset[int32_t]]](deref(Map__i32_Map__i32_Set__i32(item)._cpp_obj.get()))
        cdef vector[cmap[int32_t,cmap[int32_t,cset[int32_t]]]] vec = deref(self._cpp_obj.get())
        return <int64_t> std_libcpp.count(vec.begin(), vec.end(), citem)


Sequence.register(List__Map__i32_Map__i32_Set__i32)

cdef class List__List__Map__i32_Map__i32_Set__i32:
    def __init__(self, items=None):
        if isinstance(items, List__List__Map__i32_Map__i32_Set__i32):
            self._cpp_obj = (<List__List__Map__i32_Map__i32_Set__i32> items)._cpp_obj
        else:
            self._cpp_obj = move(List__List__Map__i32_Map__i32_Set__i32._make_instance(items))

    @staticmethod
    cdef create(shared_ptr[vector[vector[cmap[int32_t,cmap[int32_t,cset[int32_t]]]]]] c_items):
        inst = <List__List__Map__i32_Map__i32_Set__i32>List__List__Map__i32_Map__i32_Set__i32.__new__(List__List__Map__i32_Map__i32_Set__i32)
        inst._cpp_obj = c_items
        return inst

    @staticmethod
    cdef unique_ptr[vector[vector[cmap[int32_t,cmap[int32_t,cset[int32_t]]]]]] _make_instance(object items) except *:
        cdef unique_ptr[vector[vector[cmap[int32_t,cmap[int32_t,cset[int32_t]]]]]] c_inst = make_unique[vector[vector[cmap[int32_t,cmap[int32_t,cset[int32_t]]]]]]()
        if items is not None:
            for item in items:
                if item is None:
                    raise TypeError("None is not of the type _typing.Sequence[_typing.Mapping[int, _typing.Mapping[int, _typing.AbstractSet[int]]]]")
                if not isinstance(item, List__Map__i32_Map__i32_Set__i32):
                    item = List__Map__i32_Map__i32_Set__i32(item)
                deref(c_inst).push_back(vector[cmap[int32_t,cmap[int32_t,cset[int32_t]]]](deref(List__Map__i32_Map__i32_Set__i32(item)._cpp_obj.get())))
        return move_unique(c_inst)

    def __add__(object self, object other):
        return type(self)(itertools.chain(self, other))

    def __getitem__(self, object index_obj):
        cdef shared_ptr[vector[vector[cmap[int32_t,cmap[int32_t,cset[int32_t]]]]]] c_inst
        cdef vector[cmap[int32_t,cmap[int32_t,cset[int32_t]]]] citem
        if isinstance(index_obj, slice):
            c_inst = make_shared[vector[vector[cmap[int32_t,cmap[int32_t,cset[int32_t]]]]]]()
            sz = deref(self._cpp_obj).size()
            for index in range(*index_obj.indices(sz)):
                citem = deref(self._cpp_obj.get())[index]
                deref(c_inst).push_back(citem)
            return List__List__Map__i32_Map__i32_Set__i32.create(c_inst)
        else:
            index = <int?>index_obj
            size = len(self)
            # Convert a negative index
            if index < 0:
                index = size + index
            if index >= size or index < 0:
                raise IndexError('list index out of range')
            citem = deref(self._cpp_obj.get())[index]
            return List__Map__i32_Map__i32_Set__i32.create(
    make_shared[vector[cmap[int32_t,cmap[int32_t,cset[int32_t]]]]](citem))

    def __len__(self):
        return deref(self._cpp_obj).size()

    def __richcmp__(self, other, op):
        cdef int cop = op
        if cop not in (2, 3):
            raise TypeError("unorderable types: {}, {}".format(type(self), type(other)))
        if not (isinstance(self, Iterable) and isinstance(other, Iterable)):
            return cop != 2
        if (len(self) != len(other)):
            return cop != 2

        for one, two in zip(self, other):
            if one != two:
                return cop != 2

        return cop == 2

    def __hash__(self):
        if not self.__hash:
            self.__hash = hash(tuple(self))
        return self.__hash

    def __contains__(self, item):
        if not self or item is None:
            return False
        try:
            if not isinstance(item, List__Map__i32_Map__i32_Set__i32):
                item = List__Map__i32_Map__i32_Set__i32(item)
        except Exception:
            return False
        if not isinstance(item, List__Map__i32_Map__i32_Set__i32):
            return False
        cdef vector[cmap[int32_t,cmap[int32_t,cset[int32_t]]]] citem = vector[cmap[int32_t,cmap[int32_t,cset[int32_t]]]](deref(List__Map__i32_Map__i32_Set__i32(item)._cpp_obj.get()))
        cdef vector[vector[cmap[int32_t,cmap[int32_t,cset[int32_t]]]]] vec = deref(
            self._cpp_obj.get())
        return std_libcpp.find(vec.begin(), vec.end(), citem) != vec.end()

    def __iter__(self):
        if not self:
            raise StopIteration
        cdef vector[cmap[int32_t,cmap[int32_t,cset[int32_t]]]] citem
        for citem in deref(self._cpp_obj):
            yield List__Map__i32_Map__i32_Set__i32.create(
    make_shared[vector[cmap[int32_t,cmap[int32_t,cset[int32_t]]]]](citem))

    def __repr__(self):
        if not self:
            return 'i[]'
        return f'i[{", ".join(map(repr, self))}]'

    def __reversed__(self):
        if not self:
            raise StopIteration
        cdef vector[cmap[int32_t,cmap[int32_t,cset[int32_t]]]] citem
        cdef vector[vector[cmap[int32_t,cmap[int32_t,cset[int32_t]]]]] vec = deref(
            self._cpp_obj.get())
        cdef vector[vector[cmap[int32_t,cmap[int32_t,cset[int32_t]]]]].reverse_iterator loc = vec.rbegin()
        while loc != vec.rend():
            citem = deref(loc)
            yield List__Map__i32_Map__i32_Set__i32.create(
    make_shared[vector[cmap[int32_t,cmap[int32_t,cset[int32_t]]]]](citem))
            inc(loc)

    def index(self, item, start not None=__NOTSET, stop not None=__NOTSET):
        err = ValueError(f'{item} is not in list')
        if not self or item is None:
            raise err
        offset_begin = offset_end = 0
        if stop is not __NOTSET or start is not __NOTSET:
            # Like self[start:stop].index(item)
            size = len(self)
            stop = stop if stop is not __NOTSET else size
            start = start if start is not __NOTSET else 0
            # Convert stop to a negative position.
            if stop > 0:
                stop = min(stop - size, 0)
            if stop <= -size:
                raise err  # List would be empty
            offset_end = -stop
            # Convert start to always be positive
            if start < 0:
                start = max(size + start, 0)
            if start >= size:
                raise err  # past end of list
            offset_begin = start

        try:
            if not isinstance(item, List__Map__i32_Map__i32_Set__i32):
                item = List__Map__i32_Map__i32_Set__i32(item)
        except Exception:
            raise err from None
        if not isinstance(item, List__Map__i32_Map__i32_Set__i32):
            raise err
        cdef vector[cmap[int32_t,cmap[int32_t,cset[int32_t]]]] citem = vector[cmap[int32_t,cmap[int32_t,cset[int32_t]]]](deref(List__Map__i32_Map__i32_Set__i32(item)._cpp_obj.get()))
        cdef vector[vector[cmap[int32_t,cmap[int32_t,cset[int32_t]]]]] vec = deref(self._cpp_obj.get())
        cdef vector[vector[cmap[int32_t,cmap[int32_t,cset[int32_t]]]]].iterator end = std_libcpp.prev(vec.end(), <int64_t>offset_end)
        cdef vector[vector[cmap[int32_t,cmap[int32_t,cset[int32_t]]]]].iterator loc = std_libcpp.find(
            std_libcpp.next(vec.begin(), <int64_t>offset_begin),
            end,
            citem
        )
        if loc != end:
            return <int64_t> std_libcpp.distance(vec.begin(), loc)
        raise err

    def count(self, item):
        if not self or item is None:
            return 0
        try:
            if not isinstance(item, List__Map__i32_Map__i32_Set__i32):
                item = List__Map__i32_Map__i32_Set__i32(item)
        except Exception:
            return 0
        if not isinstance(item, List__Map__i32_Map__i32_Set__i32):
            return 0
        cdef vector[cmap[int32_t,cmap[int32_t,cset[int32_t]]]] citem = vector[cmap[int32_t,cmap[int32_t,cset[int32_t]]]](deref(List__Map__i32_Map__i32_Set__i32(item)._cpp_obj.get()))
        cdef vector[vector[cmap[int32_t,cmap[int32_t,cset[int32_t]]]]] vec = deref(self._cpp_obj.get())
        return <int64_t> std_libcpp.count(vec.begin(), vec.end(), citem)


Sequence.register(List__List__Map__i32_Map__i32_Set__i32)

