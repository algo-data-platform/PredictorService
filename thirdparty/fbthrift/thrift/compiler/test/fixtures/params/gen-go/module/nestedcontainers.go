// Autogenerated by Thrift Compiler (facebook)
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
// @generated

package module

import (
	"bytes"
	"sync"
	"fmt"
	thrift "github.com/facebook/fbthrift-go"
)

// (needed to ensure safety because of naive import list construction.)
var _ = thrift.ZERO
var _ = fmt.Printf
var _ = sync.Mutex{}
var _ = bytes.Equal

type NestedContainers interface {
  // Parameters:
  //  - Foo
  MapList(foo map[int32][]int32) (err error)
  // Parameters:
  //  - Foo
  MapSet(foo map[int32][]int32) (err error)
  // Parameters:
  //  - Foo
  ListMap(foo []map[int32]int32) (err error)
  // Parameters:
  //  - Foo
  ListSet(foo [][]int32) (err error)
  // Parameters:
  //  - Foo
  Turtles(foo [][]map[int32]map[int32][]int32) (err error)
}

type NestedContainersClient struct {
  Transport thrift.Transport
  ProtocolFactory thrift.ProtocolFactory
  InputProtocol thrift.Protocol
  OutputProtocol thrift.Protocol
  SeqId int32
}

func (client *NestedContainersClient) Close() error {
  return client.Transport.Close()
}

func NewNestedContainersClientFactory(t thrift.Transport, f thrift.ProtocolFactory) *NestedContainersClient {
  return &NestedContainersClient{Transport: t,
    ProtocolFactory: f,
    InputProtocol: f.GetProtocol(t),
    OutputProtocol: f.GetProtocol(t),
    SeqId: 0,
  }
}

func NewNestedContainersClient(t thrift.Transport, iprot thrift.Protocol, oprot thrift.Protocol) *NestedContainersClient {
  return &NestedContainersClient{Transport: t,
    ProtocolFactory: nil,
    InputProtocol: iprot,
    OutputProtocol: oprot,
    SeqId: 0,
  }
}

// Parameters:
//  - Foo
func (p *NestedContainersClient) MapList(foo map[int32][]int32) (err error) {
  if err = p.sendMapList(foo); err != nil { return }
  return p.recvMapList()
}

func (p *NestedContainersClient) sendMapList(foo map[int32][]int32)(err error) {
  oprot := p.OutputProtocol
  if oprot == nil {
    oprot = p.ProtocolFactory.GetProtocol(p.Transport)
    p.OutputProtocol = oprot
  }
  p.SeqId++
  if err = oprot.WriteMessageBegin("mapList", thrift.CALL, p.SeqId); err != nil {
      return
  }
  args := NestedContainersMapListArgs{
  Foo : foo,
  }
  if err = args.Write(oprot); err != nil {
      return
  }
  if err = oprot.WriteMessageEnd(); err != nil {
      return
  }
  return oprot.Flush()
}


func (p *NestedContainersClient) recvMapList() (err error) {
  iprot := p.InputProtocol
  if iprot == nil {
    iprot = p.ProtocolFactory.GetProtocol(p.Transport)
    p.InputProtocol = iprot
  }
  method, mTypeId, seqId, err := iprot.ReadMessageBegin()
  if err != nil {
    return
  }
  if method != "mapList" {
    err = thrift.NewApplicationException(thrift.WRONG_METHOD_NAME, "mapList failed: wrong method name")
    return
  }
  if p.SeqId != seqId {
    err = thrift.NewApplicationException(thrift.BAD_SEQUENCE_ID, "mapList failed: out of sequence response")
    return
  }
  if mTypeId == thrift.EXCEPTION {
    error0 := thrift.NewApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
    var error1 error
    error1, err = error0.Read(iprot)
    if err != nil {
      return
    }
    if err = iprot.ReadMessageEnd(); err != nil {
      return
    }
    err = error1
    return
  }
  if mTypeId != thrift.REPLY {
    err = thrift.NewApplicationException(thrift.INVALID_MESSAGE_TYPE_EXCEPTION, "mapList failed: invalid message type")
    return
  }
  result := NestedContainersMapListResult{}
  if err = result.Read(iprot); err != nil {
    return
  }
  if err = iprot.ReadMessageEnd(); err != nil {
    return
  }
  return
}

// Parameters:
//  - Foo
func (p *NestedContainersClient) MapSet(foo map[int32][]int32) (err error) {
  if err = p.sendMapSet(foo); err != nil { return }
  return p.recvMapSet()
}

func (p *NestedContainersClient) sendMapSet(foo map[int32][]int32)(err error) {
  oprot := p.OutputProtocol
  if oprot == nil {
    oprot = p.ProtocolFactory.GetProtocol(p.Transport)
    p.OutputProtocol = oprot
  }
  p.SeqId++
  if err = oprot.WriteMessageBegin("mapSet", thrift.CALL, p.SeqId); err != nil {
      return
  }
  args := NestedContainersMapSetArgs{
  Foo : foo,
  }
  if err = args.Write(oprot); err != nil {
      return
  }
  if err = oprot.WriteMessageEnd(); err != nil {
      return
  }
  return oprot.Flush()
}


func (p *NestedContainersClient) recvMapSet() (err error) {
  iprot := p.InputProtocol
  if iprot == nil {
    iprot = p.ProtocolFactory.GetProtocol(p.Transport)
    p.InputProtocol = iprot
  }
  method, mTypeId, seqId, err := iprot.ReadMessageBegin()
  if err != nil {
    return
  }
  if method != "mapSet" {
    err = thrift.NewApplicationException(thrift.WRONG_METHOD_NAME, "mapSet failed: wrong method name")
    return
  }
  if p.SeqId != seqId {
    err = thrift.NewApplicationException(thrift.BAD_SEQUENCE_ID, "mapSet failed: out of sequence response")
    return
  }
  if mTypeId == thrift.EXCEPTION {
    error2 := thrift.NewApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
    var error3 error
    error3, err = error2.Read(iprot)
    if err != nil {
      return
    }
    if err = iprot.ReadMessageEnd(); err != nil {
      return
    }
    err = error3
    return
  }
  if mTypeId != thrift.REPLY {
    err = thrift.NewApplicationException(thrift.INVALID_MESSAGE_TYPE_EXCEPTION, "mapSet failed: invalid message type")
    return
  }
  result := NestedContainersMapSetResult{}
  if err = result.Read(iprot); err != nil {
    return
  }
  if err = iprot.ReadMessageEnd(); err != nil {
    return
  }
  return
}

// Parameters:
//  - Foo
func (p *NestedContainersClient) ListMap(foo []map[int32]int32) (err error) {
  if err = p.sendListMap(foo); err != nil { return }
  return p.recvListMap()
}

func (p *NestedContainersClient) sendListMap(foo []map[int32]int32)(err error) {
  oprot := p.OutputProtocol
  if oprot == nil {
    oprot = p.ProtocolFactory.GetProtocol(p.Transport)
    p.OutputProtocol = oprot
  }
  p.SeqId++
  if err = oprot.WriteMessageBegin("listMap", thrift.CALL, p.SeqId); err != nil {
      return
  }
  args := NestedContainersListMapArgs{
  Foo : foo,
  }
  if err = args.Write(oprot); err != nil {
      return
  }
  if err = oprot.WriteMessageEnd(); err != nil {
      return
  }
  return oprot.Flush()
}


func (p *NestedContainersClient) recvListMap() (err error) {
  iprot := p.InputProtocol
  if iprot == nil {
    iprot = p.ProtocolFactory.GetProtocol(p.Transport)
    p.InputProtocol = iprot
  }
  method, mTypeId, seqId, err := iprot.ReadMessageBegin()
  if err != nil {
    return
  }
  if method != "listMap" {
    err = thrift.NewApplicationException(thrift.WRONG_METHOD_NAME, "listMap failed: wrong method name")
    return
  }
  if p.SeqId != seqId {
    err = thrift.NewApplicationException(thrift.BAD_SEQUENCE_ID, "listMap failed: out of sequence response")
    return
  }
  if mTypeId == thrift.EXCEPTION {
    error4 := thrift.NewApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
    var error5 error
    error5, err = error4.Read(iprot)
    if err != nil {
      return
    }
    if err = iprot.ReadMessageEnd(); err != nil {
      return
    }
    err = error5
    return
  }
  if mTypeId != thrift.REPLY {
    err = thrift.NewApplicationException(thrift.INVALID_MESSAGE_TYPE_EXCEPTION, "listMap failed: invalid message type")
    return
  }
  result := NestedContainersListMapResult{}
  if err = result.Read(iprot); err != nil {
    return
  }
  if err = iprot.ReadMessageEnd(); err != nil {
    return
  }
  return
}

// Parameters:
//  - Foo
func (p *NestedContainersClient) ListSet(foo [][]int32) (err error) {
  if err = p.sendListSet(foo); err != nil { return }
  return p.recvListSet()
}

func (p *NestedContainersClient) sendListSet(foo [][]int32)(err error) {
  oprot := p.OutputProtocol
  if oprot == nil {
    oprot = p.ProtocolFactory.GetProtocol(p.Transport)
    p.OutputProtocol = oprot
  }
  p.SeqId++
  if err = oprot.WriteMessageBegin("listSet", thrift.CALL, p.SeqId); err != nil {
      return
  }
  args := NestedContainersListSetArgs{
  Foo : foo,
  }
  if err = args.Write(oprot); err != nil {
      return
  }
  if err = oprot.WriteMessageEnd(); err != nil {
      return
  }
  return oprot.Flush()
}


func (p *NestedContainersClient) recvListSet() (err error) {
  iprot := p.InputProtocol
  if iprot == nil {
    iprot = p.ProtocolFactory.GetProtocol(p.Transport)
    p.InputProtocol = iprot
  }
  method, mTypeId, seqId, err := iprot.ReadMessageBegin()
  if err != nil {
    return
  }
  if method != "listSet" {
    err = thrift.NewApplicationException(thrift.WRONG_METHOD_NAME, "listSet failed: wrong method name")
    return
  }
  if p.SeqId != seqId {
    err = thrift.NewApplicationException(thrift.BAD_SEQUENCE_ID, "listSet failed: out of sequence response")
    return
  }
  if mTypeId == thrift.EXCEPTION {
    error6 := thrift.NewApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
    var error7 error
    error7, err = error6.Read(iprot)
    if err != nil {
      return
    }
    if err = iprot.ReadMessageEnd(); err != nil {
      return
    }
    err = error7
    return
  }
  if mTypeId != thrift.REPLY {
    err = thrift.NewApplicationException(thrift.INVALID_MESSAGE_TYPE_EXCEPTION, "listSet failed: invalid message type")
    return
  }
  result := NestedContainersListSetResult{}
  if err = result.Read(iprot); err != nil {
    return
  }
  if err = iprot.ReadMessageEnd(); err != nil {
    return
  }
  return
}

// Parameters:
//  - Foo
func (p *NestedContainersClient) Turtles(foo [][]map[int32]map[int32][]int32) (err error) {
  if err = p.sendTurtles(foo); err != nil { return }
  return p.recvTurtles()
}

func (p *NestedContainersClient) sendTurtles(foo [][]map[int32]map[int32][]int32)(err error) {
  oprot := p.OutputProtocol
  if oprot == nil {
    oprot = p.ProtocolFactory.GetProtocol(p.Transport)
    p.OutputProtocol = oprot
  }
  p.SeqId++
  if err = oprot.WriteMessageBegin("turtles", thrift.CALL, p.SeqId); err != nil {
      return
  }
  args := NestedContainersTurtlesArgs{
  Foo : foo,
  }
  if err = args.Write(oprot); err != nil {
      return
  }
  if err = oprot.WriteMessageEnd(); err != nil {
      return
  }
  return oprot.Flush()
}


func (p *NestedContainersClient) recvTurtles() (err error) {
  iprot := p.InputProtocol
  if iprot == nil {
    iprot = p.ProtocolFactory.GetProtocol(p.Transport)
    p.InputProtocol = iprot
  }
  method, mTypeId, seqId, err := iprot.ReadMessageBegin()
  if err != nil {
    return
  }
  if method != "turtles" {
    err = thrift.NewApplicationException(thrift.WRONG_METHOD_NAME, "turtles failed: wrong method name")
    return
  }
  if p.SeqId != seqId {
    err = thrift.NewApplicationException(thrift.BAD_SEQUENCE_ID, "turtles failed: out of sequence response")
    return
  }
  if mTypeId == thrift.EXCEPTION {
    error8 := thrift.NewApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
    var error9 error
    error9, err = error8.Read(iprot)
    if err != nil {
      return
    }
    if err = iprot.ReadMessageEnd(); err != nil {
      return
    }
    err = error9
    return
  }
  if mTypeId != thrift.REPLY {
    err = thrift.NewApplicationException(thrift.INVALID_MESSAGE_TYPE_EXCEPTION, "turtles failed: invalid message type")
    return
  }
  result := NestedContainersTurtlesResult{}
  if err = result.Read(iprot); err != nil {
    return
  }
  if err = iprot.ReadMessageEnd(); err != nil {
    return
  }
  return
}


type NestedContainersThreadsafeClient struct {
  Transport thrift.Transport
  ProtocolFactory thrift.ProtocolFactory
  InputProtocol thrift.Protocol
  OutputProtocol thrift.Protocol
  SeqId int32
  Mu sync.Mutex
}

func NewNestedContainersThreadsafeClientFactory(t thrift.Transport, f thrift.ProtocolFactory) *NestedContainersThreadsafeClient {
  return &NestedContainersThreadsafeClient{Transport: t,
    ProtocolFactory: f,
    InputProtocol: f.GetProtocol(t),
    OutputProtocol: f.GetProtocol(t),
    SeqId: 0,
  }
}

func NewNestedContainersThreadsafeClient(t thrift.Transport, iprot thrift.Protocol, oprot thrift.Protocol) *NestedContainersThreadsafeClient {
  return &NestedContainersThreadsafeClient{Transport: t,
    ProtocolFactory: nil,
    InputProtocol: iprot,
    OutputProtocol: oprot,
    SeqId: 0,
  }
}

func (p *NestedContainersThreadsafeClient) Threadsafe() {}

// Parameters:
//  - Foo
func (p *NestedContainersThreadsafeClient) MapList(foo map[int32][]int32) (err error) {
  p.Mu.Lock()
  defer p.Mu.Unlock()
  if err = p.sendMapList(foo); err != nil { return }
  return p.recvMapList()
}

func (p *NestedContainersThreadsafeClient) sendMapList(foo map[int32][]int32)(err error) {
  oprot := p.OutputProtocol
  if oprot == nil {
    oprot = p.ProtocolFactory.GetProtocol(p.Transport)
    p.OutputProtocol = oprot
  }
  p.SeqId++
  if err = oprot.WriteMessageBegin("mapList", thrift.CALL, p.SeqId); err != nil {
      return
  }
  args := NestedContainersMapListArgs{
  Foo : foo,
  }
  if err = args.Write(oprot); err != nil {
      return
  }
  if err = oprot.WriteMessageEnd(); err != nil {
      return
  }
  return oprot.Flush()
}


func (p *NestedContainersThreadsafeClient) recvMapList() (err error) {
  iprot := p.InputProtocol
  if iprot == nil {
    iprot = p.ProtocolFactory.GetProtocol(p.Transport)
    p.InputProtocol = iprot
  }
  method, mTypeId, seqId, err := iprot.ReadMessageBegin()
  if err != nil {
    return
  }
  if method != "mapList" {
    err = thrift.NewApplicationException(thrift.WRONG_METHOD_NAME, "mapList failed: wrong method name")
    return
  }
  if p.SeqId != seqId {
    err = thrift.NewApplicationException(thrift.BAD_SEQUENCE_ID, "mapList failed: out of sequence response")
    return
  }
  if mTypeId == thrift.EXCEPTION {
    error10 := thrift.NewApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
    var error11 error
    error11, err = error10.Read(iprot)
    if err != nil {
      return
    }
    if err = iprot.ReadMessageEnd(); err != nil {
      return
    }
    err = error11
    return
  }
  if mTypeId != thrift.REPLY {
    err = thrift.NewApplicationException(thrift.INVALID_MESSAGE_TYPE_EXCEPTION, "mapList failed: invalid message type")
    return
  }
  result := NestedContainersMapListResult{}
  if err = result.Read(iprot); err != nil {
    return
  }
  if err = iprot.ReadMessageEnd(); err != nil {
    return
  }
  return
}

// Parameters:
//  - Foo
func (p *NestedContainersThreadsafeClient) MapSet(foo map[int32][]int32) (err error) {
  p.Mu.Lock()
  defer p.Mu.Unlock()
  if err = p.sendMapSet(foo); err != nil { return }
  return p.recvMapSet()
}

func (p *NestedContainersThreadsafeClient) sendMapSet(foo map[int32][]int32)(err error) {
  oprot := p.OutputProtocol
  if oprot == nil {
    oprot = p.ProtocolFactory.GetProtocol(p.Transport)
    p.OutputProtocol = oprot
  }
  p.SeqId++
  if err = oprot.WriteMessageBegin("mapSet", thrift.CALL, p.SeqId); err != nil {
      return
  }
  args := NestedContainersMapSetArgs{
  Foo : foo,
  }
  if err = args.Write(oprot); err != nil {
      return
  }
  if err = oprot.WriteMessageEnd(); err != nil {
      return
  }
  return oprot.Flush()
}


func (p *NestedContainersThreadsafeClient) recvMapSet() (err error) {
  iprot := p.InputProtocol
  if iprot == nil {
    iprot = p.ProtocolFactory.GetProtocol(p.Transport)
    p.InputProtocol = iprot
  }
  method, mTypeId, seqId, err := iprot.ReadMessageBegin()
  if err != nil {
    return
  }
  if method != "mapSet" {
    err = thrift.NewApplicationException(thrift.WRONG_METHOD_NAME, "mapSet failed: wrong method name")
    return
  }
  if p.SeqId != seqId {
    err = thrift.NewApplicationException(thrift.BAD_SEQUENCE_ID, "mapSet failed: out of sequence response")
    return
  }
  if mTypeId == thrift.EXCEPTION {
    error12 := thrift.NewApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
    var error13 error
    error13, err = error12.Read(iprot)
    if err != nil {
      return
    }
    if err = iprot.ReadMessageEnd(); err != nil {
      return
    }
    err = error13
    return
  }
  if mTypeId != thrift.REPLY {
    err = thrift.NewApplicationException(thrift.INVALID_MESSAGE_TYPE_EXCEPTION, "mapSet failed: invalid message type")
    return
  }
  result := NestedContainersMapSetResult{}
  if err = result.Read(iprot); err != nil {
    return
  }
  if err = iprot.ReadMessageEnd(); err != nil {
    return
  }
  return
}

// Parameters:
//  - Foo
func (p *NestedContainersThreadsafeClient) ListMap(foo []map[int32]int32) (err error) {
  p.Mu.Lock()
  defer p.Mu.Unlock()
  if err = p.sendListMap(foo); err != nil { return }
  return p.recvListMap()
}

func (p *NestedContainersThreadsafeClient) sendListMap(foo []map[int32]int32)(err error) {
  oprot := p.OutputProtocol
  if oprot == nil {
    oprot = p.ProtocolFactory.GetProtocol(p.Transport)
    p.OutputProtocol = oprot
  }
  p.SeqId++
  if err = oprot.WriteMessageBegin("listMap", thrift.CALL, p.SeqId); err != nil {
      return
  }
  args := NestedContainersListMapArgs{
  Foo : foo,
  }
  if err = args.Write(oprot); err != nil {
      return
  }
  if err = oprot.WriteMessageEnd(); err != nil {
      return
  }
  return oprot.Flush()
}


func (p *NestedContainersThreadsafeClient) recvListMap() (err error) {
  iprot := p.InputProtocol
  if iprot == nil {
    iprot = p.ProtocolFactory.GetProtocol(p.Transport)
    p.InputProtocol = iprot
  }
  method, mTypeId, seqId, err := iprot.ReadMessageBegin()
  if err != nil {
    return
  }
  if method != "listMap" {
    err = thrift.NewApplicationException(thrift.WRONG_METHOD_NAME, "listMap failed: wrong method name")
    return
  }
  if p.SeqId != seqId {
    err = thrift.NewApplicationException(thrift.BAD_SEQUENCE_ID, "listMap failed: out of sequence response")
    return
  }
  if mTypeId == thrift.EXCEPTION {
    error14 := thrift.NewApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
    var error15 error
    error15, err = error14.Read(iprot)
    if err != nil {
      return
    }
    if err = iprot.ReadMessageEnd(); err != nil {
      return
    }
    err = error15
    return
  }
  if mTypeId != thrift.REPLY {
    err = thrift.NewApplicationException(thrift.INVALID_MESSAGE_TYPE_EXCEPTION, "listMap failed: invalid message type")
    return
  }
  result := NestedContainersListMapResult{}
  if err = result.Read(iprot); err != nil {
    return
  }
  if err = iprot.ReadMessageEnd(); err != nil {
    return
  }
  return
}

// Parameters:
//  - Foo
func (p *NestedContainersThreadsafeClient) ListSet(foo [][]int32) (err error) {
  p.Mu.Lock()
  defer p.Mu.Unlock()
  if err = p.sendListSet(foo); err != nil { return }
  return p.recvListSet()
}

func (p *NestedContainersThreadsafeClient) sendListSet(foo [][]int32)(err error) {
  oprot := p.OutputProtocol
  if oprot == nil {
    oprot = p.ProtocolFactory.GetProtocol(p.Transport)
    p.OutputProtocol = oprot
  }
  p.SeqId++
  if err = oprot.WriteMessageBegin("listSet", thrift.CALL, p.SeqId); err != nil {
      return
  }
  args := NestedContainersListSetArgs{
  Foo : foo,
  }
  if err = args.Write(oprot); err != nil {
      return
  }
  if err = oprot.WriteMessageEnd(); err != nil {
      return
  }
  return oprot.Flush()
}


func (p *NestedContainersThreadsafeClient) recvListSet() (err error) {
  iprot := p.InputProtocol
  if iprot == nil {
    iprot = p.ProtocolFactory.GetProtocol(p.Transport)
    p.InputProtocol = iprot
  }
  method, mTypeId, seqId, err := iprot.ReadMessageBegin()
  if err != nil {
    return
  }
  if method != "listSet" {
    err = thrift.NewApplicationException(thrift.WRONG_METHOD_NAME, "listSet failed: wrong method name")
    return
  }
  if p.SeqId != seqId {
    err = thrift.NewApplicationException(thrift.BAD_SEQUENCE_ID, "listSet failed: out of sequence response")
    return
  }
  if mTypeId == thrift.EXCEPTION {
    error16 := thrift.NewApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
    var error17 error
    error17, err = error16.Read(iprot)
    if err != nil {
      return
    }
    if err = iprot.ReadMessageEnd(); err != nil {
      return
    }
    err = error17
    return
  }
  if mTypeId != thrift.REPLY {
    err = thrift.NewApplicationException(thrift.INVALID_MESSAGE_TYPE_EXCEPTION, "listSet failed: invalid message type")
    return
  }
  result := NestedContainersListSetResult{}
  if err = result.Read(iprot); err != nil {
    return
  }
  if err = iprot.ReadMessageEnd(); err != nil {
    return
  }
  return
}

// Parameters:
//  - Foo
func (p *NestedContainersThreadsafeClient) Turtles(foo [][]map[int32]map[int32][]int32) (err error) {
  p.Mu.Lock()
  defer p.Mu.Unlock()
  if err = p.sendTurtles(foo); err != nil { return }
  return p.recvTurtles()
}

func (p *NestedContainersThreadsafeClient) sendTurtles(foo [][]map[int32]map[int32][]int32)(err error) {
  oprot := p.OutputProtocol
  if oprot == nil {
    oprot = p.ProtocolFactory.GetProtocol(p.Transport)
    p.OutputProtocol = oprot
  }
  p.SeqId++
  if err = oprot.WriteMessageBegin("turtles", thrift.CALL, p.SeqId); err != nil {
      return
  }
  args := NestedContainersTurtlesArgs{
  Foo : foo,
  }
  if err = args.Write(oprot); err != nil {
      return
  }
  if err = oprot.WriteMessageEnd(); err != nil {
      return
  }
  return oprot.Flush()
}


func (p *NestedContainersThreadsafeClient) recvTurtles() (err error) {
  iprot := p.InputProtocol
  if iprot == nil {
    iprot = p.ProtocolFactory.GetProtocol(p.Transport)
    p.InputProtocol = iprot
  }
  method, mTypeId, seqId, err := iprot.ReadMessageBegin()
  if err != nil {
    return
  }
  if method != "turtles" {
    err = thrift.NewApplicationException(thrift.WRONG_METHOD_NAME, "turtles failed: wrong method name")
    return
  }
  if p.SeqId != seqId {
    err = thrift.NewApplicationException(thrift.BAD_SEQUENCE_ID, "turtles failed: out of sequence response")
    return
  }
  if mTypeId == thrift.EXCEPTION {
    error18 := thrift.NewApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
    var error19 error
    error19, err = error18.Read(iprot)
    if err != nil {
      return
    }
    if err = iprot.ReadMessageEnd(); err != nil {
      return
    }
    err = error19
    return
  }
  if mTypeId != thrift.REPLY {
    err = thrift.NewApplicationException(thrift.INVALID_MESSAGE_TYPE_EXCEPTION, "turtles failed: invalid message type")
    return
  }
  result := NestedContainersTurtlesResult{}
  if err = result.Read(iprot); err != nil {
    return
  }
  if err = iprot.ReadMessageEnd(); err != nil {
    return
  }
  return
}


type NestedContainersProcessor struct {
  processorMap map[string]thrift.ProcessorFunction
  handler NestedContainers
}

func (p *NestedContainersProcessor) AddToProcessorMap(key string, processor thrift.ProcessorFunction) {
  p.processorMap[key] = processor
}

func (p *NestedContainersProcessor) GetProcessorFunction(key string) (processor thrift.ProcessorFunction, err error) {
  if processor, ok := p.processorMap[key]; ok {
    return processor, nil
  }
  return nil, nil // generic error message will be sent
}

func (p *NestedContainersProcessor) ProcessorMap() map[string]thrift.ProcessorFunction {
  return p.processorMap
}

func NewNestedContainersProcessor(handler NestedContainers) *NestedContainersProcessor {
  self20 := &NestedContainersProcessor{handler:handler, processorMap:make(map[string]thrift.ProcessorFunction)}
  self20.processorMap["mapList"] = &nestedContainersProcessorMapList{handler:handler}
  self20.processorMap["mapSet"] = &nestedContainersProcessorMapSet{handler:handler}
  self20.processorMap["listMap"] = &nestedContainersProcessorListMap{handler:handler}
  self20.processorMap["listSet"] = &nestedContainersProcessorListSet{handler:handler}
  self20.processorMap["turtles"] = &nestedContainersProcessorTurtles{handler:handler}
  return self20
}

type nestedContainersProcessorMapList struct {
  handler NestedContainers
}

func (p *nestedContainersProcessorMapList) Read(iprot thrift.Protocol) (thrift.Struct, thrift.Exception) {
  args := NestedContainersMapListArgs{}
  if err := args.Read(iprot); err != nil {
    return nil, err
  }
  iprot.ReadMessageEnd()
  return &args, nil
}

func (p *nestedContainersProcessorMapList) Write(seqId int32, result thrift.WritableStruct, oprot thrift.Protocol) (err thrift.Exception) {
  var err2 error
  messageType := thrift.REPLY
  switch result.(type) {
  case thrift.ApplicationException:
    messageType = thrift.EXCEPTION
  }
  if err2 = oprot.WriteMessageBegin("mapList", messageType, seqId); err2 != nil {
    err = err2
  }
  if err2 = result.Write(oprot); err == nil && err2 != nil {
    err = err2
  }
  if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
    err = err2
  }
  if err2 = oprot.Flush(); err == nil && err2 != nil {
    err = err2
  }
  return err
}

func (p *nestedContainersProcessorMapList) Run(argStruct thrift.Struct) (thrift.WritableStruct, thrift.ApplicationException) {
  args := argStruct.(*NestedContainersMapListArgs)
  var result NestedContainersMapListResult
  if err := p.handler.MapList(args.Foo); err != nil {
    switch err.(type) {
    default:
      x := thrift.NewApplicationException(thrift.INTERNAL_ERROR, "Internal error processing mapList: " + err.Error())
      return x, x
    }
  }
  return &result, nil
}

type nestedContainersProcessorMapSet struct {
  handler NestedContainers
}

func (p *nestedContainersProcessorMapSet) Read(iprot thrift.Protocol) (thrift.Struct, thrift.Exception) {
  args := NestedContainersMapSetArgs{}
  if err := args.Read(iprot); err != nil {
    return nil, err
  }
  iprot.ReadMessageEnd()
  return &args, nil
}

func (p *nestedContainersProcessorMapSet) Write(seqId int32, result thrift.WritableStruct, oprot thrift.Protocol) (err thrift.Exception) {
  var err2 error
  messageType := thrift.REPLY
  switch result.(type) {
  case thrift.ApplicationException:
    messageType = thrift.EXCEPTION
  }
  if err2 = oprot.WriteMessageBegin("mapSet", messageType, seqId); err2 != nil {
    err = err2
  }
  if err2 = result.Write(oprot); err == nil && err2 != nil {
    err = err2
  }
  if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
    err = err2
  }
  if err2 = oprot.Flush(); err == nil && err2 != nil {
    err = err2
  }
  return err
}

func (p *nestedContainersProcessorMapSet) Run(argStruct thrift.Struct) (thrift.WritableStruct, thrift.ApplicationException) {
  args := argStruct.(*NestedContainersMapSetArgs)
  var result NestedContainersMapSetResult
  if err := p.handler.MapSet(args.Foo); err != nil {
    switch err.(type) {
    default:
      x := thrift.NewApplicationException(thrift.INTERNAL_ERROR, "Internal error processing mapSet: " + err.Error())
      return x, x
    }
  }
  return &result, nil
}

type nestedContainersProcessorListMap struct {
  handler NestedContainers
}

func (p *nestedContainersProcessorListMap) Read(iprot thrift.Protocol) (thrift.Struct, thrift.Exception) {
  args := NestedContainersListMapArgs{}
  if err := args.Read(iprot); err != nil {
    return nil, err
  }
  iprot.ReadMessageEnd()
  return &args, nil
}

func (p *nestedContainersProcessorListMap) Write(seqId int32, result thrift.WritableStruct, oprot thrift.Protocol) (err thrift.Exception) {
  var err2 error
  messageType := thrift.REPLY
  switch result.(type) {
  case thrift.ApplicationException:
    messageType = thrift.EXCEPTION
  }
  if err2 = oprot.WriteMessageBegin("listMap", messageType, seqId); err2 != nil {
    err = err2
  }
  if err2 = result.Write(oprot); err == nil && err2 != nil {
    err = err2
  }
  if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
    err = err2
  }
  if err2 = oprot.Flush(); err == nil && err2 != nil {
    err = err2
  }
  return err
}

func (p *nestedContainersProcessorListMap) Run(argStruct thrift.Struct) (thrift.WritableStruct, thrift.ApplicationException) {
  args := argStruct.(*NestedContainersListMapArgs)
  var result NestedContainersListMapResult
  if err := p.handler.ListMap(args.Foo); err != nil {
    switch err.(type) {
    default:
      x := thrift.NewApplicationException(thrift.INTERNAL_ERROR, "Internal error processing listMap: " + err.Error())
      return x, x
    }
  }
  return &result, nil
}

type nestedContainersProcessorListSet struct {
  handler NestedContainers
}

func (p *nestedContainersProcessorListSet) Read(iprot thrift.Protocol) (thrift.Struct, thrift.Exception) {
  args := NestedContainersListSetArgs{}
  if err := args.Read(iprot); err != nil {
    return nil, err
  }
  iprot.ReadMessageEnd()
  return &args, nil
}

func (p *nestedContainersProcessorListSet) Write(seqId int32, result thrift.WritableStruct, oprot thrift.Protocol) (err thrift.Exception) {
  var err2 error
  messageType := thrift.REPLY
  switch result.(type) {
  case thrift.ApplicationException:
    messageType = thrift.EXCEPTION
  }
  if err2 = oprot.WriteMessageBegin("listSet", messageType, seqId); err2 != nil {
    err = err2
  }
  if err2 = result.Write(oprot); err == nil && err2 != nil {
    err = err2
  }
  if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
    err = err2
  }
  if err2 = oprot.Flush(); err == nil && err2 != nil {
    err = err2
  }
  return err
}

func (p *nestedContainersProcessorListSet) Run(argStruct thrift.Struct) (thrift.WritableStruct, thrift.ApplicationException) {
  args := argStruct.(*NestedContainersListSetArgs)
  var result NestedContainersListSetResult
  if err := p.handler.ListSet(args.Foo); err != nil {
    switch err.(type) {
    default:
      x := thrift.NewApplicationException(thrift.INTERNAL_ERROR, "Internal error processing listSet: " + err.Error())
      return x, x
    }
  }
  return &result, nil
}

type nestedContainersProcessorTurtles struct {
  handler NestedContainers
}

func (p *nestedContainersProcessorTurtles) Read(iprot thrift.Protocol) (thrift.Struct, thrift.Exception) {
  args := NestedContainersTurtlesArgs{}
  if err := args.Read(iprot); err != nil {
    return nil, err
  }
  iprot.ReadMessageEnd()
  return &args, nil
}

func (p *nestedContainersProcessorTurtles) Write(seqId int32, result thrift.WritableStruct, oprot thrift.Protocol) (err thrift.Exception) {
  var err2 error
  messageType := thrift.REPLY
  switch result.(type) {
  case thrift.ApplicationException:
    messageType = thrift.EXCEPTION
  }
  if err2 = oprot.WriteMessageBegin("turtles", messageType, seqId); err2 != nil {
    err = err2
  }
  if err2 = result.Write(oprot); err == nil && err2 != nil {
    err = err2
  }
  if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
    err = err2
  }
  if err2 = oprot.Flush(); err == nil && err2 != nil {
    err = err2
  }
  return err
}

func (p *nestedContainersProcessorTurtles) Run(argStruct thrift.Struct) (thrift.WritableStruct, thrift.ApplicationException) {
  args := argStruct.(*NestedContainersTurtlesArgs)
  var result NestedContainersTurtlesResult
  if err := p.handler.Turtles(args.Foo); err != nil {
    switch err.(type) {
    default:
      x := thrift.NewApplicationException(thrift.INTERNAL_ERROR, "Internal error processing turtles: " + err.Error())
      return x, x
    }
  }
  return &result, nil
}


// HELPER FUNCTIONS AND STRUCTURES

// Attributes:
//  - Foo
type NestedContainersMapListArgs struct {
  Foo map[int32][]int32 `thrift:"foo,1" db:"foo" json:"foo"`
}

func NewNestedContainersMapListArgs() *NestedContainersMapListArgs {
  return &NestedContainersMapListArgs{}
}


func (p *NestedContainersMapListArgs) GetFoo() map[int32][]int32 {
  return p.Foo
}
func (p *NestedContainersMapListArgs) Read(iprot thrift.Protocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if err := p.ReadField1(iprot); err != nil {
        return err
      }
    default:
      if err := iprot.Skip(fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *NestedContainersMapListArgs)  ReadField1(iprot thrift.Protocol) error {
  _, _, size, err := iprot.ReadMapBegin()
  if err != nil {
    return thrift.PrependError("error reading map begin: ", err)
  }
  tMap := make(map[int32][]int32, size)
  p.Foo =  tMap
  for i := 0; i < size; i ++ {
var _key22 int32
    if v, err := iprot.ReadI32(); err != nil {
    return thrift.PrependError("error reading field 0: ", err)
} else {
    _key22 = v
}
    _, size, err := iprot.ReadListBegin()
    if err != nil {
      return thrift.PrependError("error reading list begin: ", err)
    }
    tSlice := make([]int32, 0, size)
    _val23 :=  tSlice
    for i := 0; i < size; i ++ {
var _elem24 int32
      if v, err := iprot.ReadI32(); err != nil {
      return thrift.PrependError("error reading field 0: ", err)
} else {
      _elem24 = v
}
      _val23 = append(_val23, _elem24)
    }
    if err := iprot.ReadListEnd(); err != nil {
      return thrift.PrependError("error reading list end: ", err)
    }
    p.Foo[_key22] = _val23
  }
  if err := iprot.ReadMapEnd(); err != nil {
    return thrift.PrependError("error reading map end: ", err)
  }
  return nil
}

func (p *NestedContainersMapListArgs) Write(oprot thrift.Protocol) error {
  if err := oprot.WriteStructBegin("mapList_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if err := p.writeField1(oprot); err != nil { return err }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *NestedContainersMapListArgs) writeField1(oprot thrift.Protocol) (err error) {
  if err := oprot.WriteFieldBegin("foo", thrift.MAP, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:foo: ", p), err) }
  if err := oprot.WriteMapBegin(thrift.I32, thrift.LIST, len(p.Foo)); err != nil {
    return thrift.PrependError("error writing map begin: ", err)
  }
  for k, v := range p.Foo {
    if err := oprot.WriteI32(int32(k)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err) }
    if err := oprot.WriteListBegin(thrift.I32, len(v)); err != nil {
      return thrift.PrependError("error writing list begin: ", err)
    }
    for _, v := range v {
      if err := oprot.WriteI32(int32(v)); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err) }
    }
    if err := oprot.WriteListEnd(); err != nil {
      return thrift.PrependError("error writing list end: ", err)
    }
  }
  if err := oprot.WriteMapEnd(); err != nil {
    return thrift.PrependError("error writing map end: ", err)
  }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:foo: ", p), err) }
  return err
}

func (p *NestedContainersMapListArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("NestedContainersMapListArgs(%+v)", *p)
}

type NestedContainersMapListResult struct {
}

func NewNestedContainersMapListResult() *NestedContainersMapListResult {
  return &NestedContainersMapListResult{}
}

func (p *NestedContainersMapListResult) Read(iprot thrift.Protocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *NestedContainersMapListResult) Write(oprot thrift.Protocol) error {
  if err := oprot.WriteStructBegin("mapList_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *NestedContainersMapListResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("NestedContainersMapListResult(%+v)", *p)
}

// Attributes:
//  - Foo
type NestedContainersMapSetArgs struct {
  Foo map[int32][]int32 `thrift:"foo,1" db:"foo" json:"foo"`
}

func NewNestedContainersMapSetArgs() *NestedContainersMapSetArgs {
  return &NestedContainersMapSetArgs{}
}


func (p *NestedContainersMapSetArgs) GetFoo() map[int32][]int32 {
  return p.Foo
}
func (p *NestedContainersMapSetArgs) Read(iprot thrift.Protocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if err := p.ReadField1(iprot); err != nil {
        return err
      }
    default:
      if err := iprot.Skip(fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *NestedContainersMapSetArgs)  ReadField1(iprot thrift.Protocol) error {
  _, _, size, err := iprot.ReadMapBegin()
  if err != nil {
    return thrift.PrependError("error reading map begin: ", err)
  }
  tMap := make(map[int32][]int32, size)
  p.Foo =  tMap
  for i := 0; i < size; i ++ {
var _key25 int32
    if v, err := iprot.ReadI32(); err != nil {
    return thrift.PrependError("error reading field 0: ", err)
} else {
    _key25 = v
}
    _, size, err := iprot.ReadSetBegin()
    if err != nil {
      return thrift.PrependError("error reading set begin: ", err)
    }
    tSet := make([]int32, 0, size)
    _val26 :=  tSet
    for i := 0; i < size; i ++ {
var _elem27 int32
      if v, err := iprot.ReadI32(); err != nil {
      return thrift.PrependError("error reading field 0: ", err)
} else {
      _elem27 = v
}
      _val26 = append(_val26, _elem27)
    }
    if err := iprot.ReadSetEnd(); err != nil {
      return thrift.PrependError("error reading set end: ", err)
    }
    p.Foo[_key25] = _val26
  }
  if err := iprot.ReadMapEnd(); err != nil {
    return thrift.PrependError("error reading map end: ", err)
  }
  return nil
}

func (p *NestedContainersMapSetArgs) Write(oprot thrift.Protocol) error {
  if err := oprot.WriteStructBegin("mapSet_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if err := p.writeField1(oprot); err != nil { return err }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *NestedContainersMapSetArgs) writeField1(oprot thrift.Protocol) (err error) {
  if err := oprot.WriteFieldBegin("foo", thrift.MAP, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:foo: ", p), err) }
  if err := oprot.WriteMapBegin(thrift.I32, thrift.SET, len(p.Foo)); err != nil {
    return thrift.PrependError("error writing map begin: ", err)
  }
  for k, v := range p.Foo {
    if err := oprot.WriteI32(int32(k)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err) }
    if err := oprot.WriteSetBegin(thrift.I32, len(v)); err != nil {
      return thrift.PrependError("error writing set begin: ", err)
    }
    set := make(map[int32]bool, len(v))
    for _, v := range v {
      if ok := set[v]; ok {
        return thrift.PrependError("", fmt.Errorf("%T error writing set field: slice is not unique", v))
      }
      set[v] = true
    }
    for _, v := range v {
      if err := oprot.WriteI32(int32(v)); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err) }
    }
    if err := oprot.WriteSetEnd(); err != nil {
      return thrift.PrependError("error writing set end: ", err)
    }
  }
  if err := oprot.WriteMapEnd(); err != nil {
    return thrift.PrependError("error writing map end: ", err)
  }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:foo: ", p), err) }
  return err
}

func (p *NestedContainersMapSetArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("NestedContainersMapSetArgs(%+v)", *p)
}

type NestedContainersMapSetResult struct {
}

func NewNestedContainersMapSetResult() *NestedContainersMapSetResult {
  return &NestedContainersMapSetResult{}
}

func (p *NestedContainersMapSetResult) Read(iprot thrift.Protocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *NestedContainersMapSetResult) Write(oprot thrift.Protocol) error {
  if err := oprot.WriteStructBegin("mapSet_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *NestedContainersMapSetResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("NestedContainersMapSetResult(%+v)", *p)
}

// Attributes:
//  - Foo
type NestedContainersListMapArgs struct {
  Foo []map[int32]int32 `thrift:"foo,1" db:"foo" json:"foo"`
}

func NewNestedContainersListMapArgs() *NestedContainersListMapArgs {
  return &NestedContainersListMapArgs{}
}


func (p *NestedContainersListMapArgs) GetFoo() []map[int32]int32 {
  return p.Foo
}
func (p *NestedContainersListMapArgs) Read(iprot thrift.Protocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if err := p.ReadField1(iprot); err != nil {
        return err
      }
    default:
      if err := iprot.Skip(fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *NestedContainersListMapArgs)  ReadField1(iprot thrift.Protocol) error {
  _, size, err := iprot.ReadListBegin()
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make([]map[int32]int32, 0, size)
  p.Foo =  tSlice
  for i := 0; i < size; i ++ {
    _, _, size, err := iprot.ReadMapBegin()
    if err != nil {
      return thrift.PrependError("error reading map begin: ", err)
    }
    tMap := make(map[int32]int32, size)
    _elem28 :=  tMap
    for i := 0; i < size; i ++ {
var _key29 int32
      if v, err := iprot.ReadI32(); err != nil {
      return thrift.PrependError("error reading field 0: ", err)
} else {
      _key29 = v
}
var _val30 int32
      if v, err := iprot.ReadI32(); err != nil {
      return thrift.PrependError("error reading field 0: ", err)
} else {
      _val30 = v
}
      _elem28[_key29] = _val30
    }
    if err := iprot.ReadMapEnd(); err != nil {
      return thrift.PrependError("error reading map end: ", err)
    }
    p.Foo = append(p.Foo, _elem28)
  }
  if err := iprot.ReadListEnd(); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *NestedContainersListMapArgs) Write(oprot thrift.Protocol) error {
  if err := oprot.WriteStructBegin("listMap_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if err := p.writeField1(oprot); err != nil { return err }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *NestedContainersListMapArgs) writeField1(oprot thrift.Protocol) (err error) {
  if err := oprot.WriteFieldBegin("foo", thrift.LIST, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:foo: ", p), err) }
  if err := oprot.WriteListBegin(thrift.MAP, len(p.Foo)); err != nil {
    return thrift.PrependError("error writing list begin: ", err)
  }
  for _, v := range p.Foo {
    if err := oprot.WriteMapBegin(thrift.I32, thrift.I32, len(v)); err != nil {
      return thrift.PrependError("error writing map begin: ", err)
    }
    for k, v := range v {
      if err := oprot.WriteI32(int32(k)); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err) }
      if err := oprot.WriteI32(int32(v)); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err) }
    }
    if err := oprot.WriteMapEnd(); err != nil {
      return thrift.PrependError("error writing map end: ", err)
    }
  }
  if err := oprot.WriteListEnd(); err != nil {
    return thrift.PrependError("error writing list end: ", err)
  }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:foo: ", p), err) }
  return err
}

func (p *NestedContainersListMapArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("NestedContainersListMapArgs(%+v)", *p)
}

type NestedContainersListMapResult struct {
}

func NewNestedContainersListMapResult() *NestedContainersListMapResult {
  return &NestedContainersListMapResult{}
}

func (p *NestedContainersListMapResult) Read(iprot thrift.Protocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *NestedContainersListMapResult) Write(oprot thrift.Protocol) error {
  if err := oprot.WriteStructBegin("listMap_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *NestedContainersListMapResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("NestedContainersListMapResult(%+v)", *p)
}

// Attributes:
//  - Foo
type NestedContainersListSetArgs struct {
  Foo [][]int32 `thrift:"foo,1" db:"foo" json:"foo"`
}

func NewNestedContainersListSetArgs() *NestedContainersListSetArgs {
  return &NestedContainersListSetArgs{}
}


func (p *NestedContainersListSetArgs) GetFoo() [][]int32 {
  return p.Foo
}
func (p *NestedContainersListSetArgs) Read(iprot thrift.Protocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if err := p.ReadField1(iprot); err != nil {
        return err
      }
    default:
      if err := iprot.Skip(fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *NestedContainersListSetArgs)  ReadField1(iprot thrift.Protocol) error {
  _, size, err := iprot.ReadListBegin()
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make([][]int32, 0, size)
  p.Foo =  tSlice
  for i := 0; i < size; i ++ {
    _, size, err := iprot.ReadSetBegin()
    if err != nil {
      return thrift.PrependError("error reading set begin: ", err)
    }
    tSet := make([]int32, 0, size)
    _elem31 :=  tSet
    for i := 0; i < size; i ++ {
var _elem32 int32
      if v, err := iprot.ReadI32(); err != nil {
      return thrift.PrependError("error reading field 0: ", err)
} else {
      _elem32 = v
}
      _elem31 = append(_elem31, _elem32)
    }
    if err := iprot.ReadSetEnd(); err != nil {
      return thrift.PrependError("error reading set end: ", err)
    }
    p.Foo = append(p.Foo, _elem31)
  }
  if err := iprot.ReadListEnd(); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *NestedContainersListSetArgs) Write(oprot thrift.Protocol) error {
  if err := oprot.WriteStructBegin("listSet_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if err := p.writeField1(oprot); err != nil { return err }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *NestedContainersListSetArgs) writeField1(oprot thrift.Protocol) (err error) {
  if err := oprot.WriteFieldBegin("foo", thrift.LIST, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:foo: ", p), err) }
  if err := oprot.WriteListBegin(thrift.SET, len(p.Foo)); err != nil {
    return thrift.PrependError("error writing list begin: ", err)
  }
  for _, v := range p.Foo {
    if err := oprot.WriteSetBegin(thrift.I32, len(v)); err != nil {
      return thrift.PrependError("error writing set begin: ", err)
    }
    set := make(map[int32]bool, len(v))
    for _, v := range v {
      if ok := set[v]; ok {
        return thrift.PrependError("", fmt.Errorf("%T error writing set field: slice is not unique", v))
      }
      set[v] = true
    }
    for _, v := range v {
      if err := oprot.WriteI32(int32(v)); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err) }
    }
    if err := oprot.WriteSetEnd(); err != nil {
      return thrift.PrependError("error writing set end: ", err)
    }
  }
  if err := oprot.WriteListEnd(); err != nil {
    return thrift.PrependError("error writing list end: ", err)
  }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:foo: ", p), err) }
  return err
}

func (p *NestedContainersListSetArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("NestedContainersListSetArgs(%+v)", *p)
}

type NestedContainersListSetResult struct {
}

func NewNestedContainersListSetResult() *NestedContainersListSetResult {
  return &NestedContainersListSetResult{}
}

func (p *NestedContainersListSetResult) Read(iprot thrift.Protocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *NestedContainersListSetResult) Write(oprot thrift.Protocol) error {
  if err := oprot.WriteStructBegin("listSet_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *NestedContainersListSetResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("NestedContainersListSetResult(%+v)", *p)
}

// Attributes:
//  - Foo
type NestedContainersTurtlesArgs struct {
  Foo [][]map[int32]map[int32][]int32 `thrift:"foo,1" db:"foo" json:"foo"`
}

func NewNestedContainersTurtlesArgs() *NestedContainersTurtlesArgs {
  return &NestedContainersTurtlesArgs{}
}


func (p *NestedContainersTurtlesArgs) GetFoo() [][]map[int32]map[int32][]int32 {
  return p.Foo
}
func (p *NestedContainersTurtlesArgs) Read(iprot thrift.Protocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if err := p.ReadField1(iprot); err != nil {
        return err
      }
    default:
      if err := iprot.Skip(fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *NestedContainersTurtlesArgs)  ReadField1(iprot thrift.Protocol) error {
  _, size, err := iprot.ReadListBegin()
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make([][]map[int32]map[int32][]int32, 0, size)
  p.Foo =  tSlice
  for i := 0; i < size; i ++ {
    _, size, err := iprot.ReadListBegin()
    if err != nil {
      return thrift.PrependError("error reading list begin: ", err)
    }
    tSlice := make([]map[int32]map[int32][]int32, 0, size)
    _elem33 :=  tSlice
    for i := 0; i < size; i ++ {
      _, _, size, err := iprot.ReadMapBegin()
      if err != nil {
        return thrift.PrependError("error reading map begin: ", err)
      }
      tMap := make(map[int32]map[int32][]int32, size)
      _elem34 :=  tMap
      for i := 0; i < size; i ++ {
var _key35 int32
        if v, err := iprot.ReadI32(); err != nil {
        return thrift.PrependError("error reading field 0: ", err)
} else {
        _key35 = v
}
        _, _, size, err := iprot.ReadMapBegin()
        if err != nil {
          return thrift.PrependError("error reading map begin: ", err)
        }
        tMap := make(map[int32][]int32, size)
        _val36 :=  tMap
        for i := 0; i < size; i ++ {
var _key37 int32
          if v, err := iprot.ReadI32(); err != nil {
          return thrift.PrependError("error reading field 0: ", err)
} else {
          _key37 = v
}
          _, size, err := iprot.ReadSetBegin()
          if err != nil {
            return thrift.PrependError("error reading set begin: ", err)
          }
          tSet := make([]int32, 0, size)
          _val38 :=  tSet
          for i := 0; i < size; i ++ {
var _elem39 int32
            if v, err := iprot.ReadI32(); err != nil {
            return thrift.PrependError("error reading field 0: ", err)
} else {
            _elem39 = v
}
            _val38 = append(_val38, _elem39)
          }
          if err := iprot.ReadSetEnd(); err != nil {
            return thrift.PrependError("error reading set end: ", err)
          }
          _val36[_key37] = _val38
        }
        if err := iprot.ReadMapEnd(); err != nil {
          return thrift.PrependError("error reading map end: ", err)
        }
        _elem34[_key35] = _val36
      }
      if err := iprot.ReadMapEnd(); err != nil {
        return thrift.PrependError("error reading map end: ", err)
      }
      _elem33 = append(_elem33, _elem34)
    }
    if err := iprot.ReadListEnd(); err != nil {
      return thrift.PrependError("error reading list end: ", err)
    }
    p.Foo = append(p.Foo, _elem33)
  }
  if err := iprot.ReadListEnd(); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *NestedContainersTurtlesArgs) Write(oprot thrift.Protocol) error {
  if err := oprot.WriteStructBegin("turtles_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if err := p.writeField1(oprot); err != nil { return err }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *NestedContainersTurtlesArgs) writeField1(oprot thrift.Protocol) (err error) {
  if err := oprot.WriteFieldBegin("foo", thrift.LIST, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:foo: ", p), err) }
  if err := oprot.WriteListBegin(thrift.LIST, len(p.Foo)); err != nil {
    return thrift.PrependError("error writing list begin: ", err)
  }
  for _, v := range p.Foo {
    if err := oprot.WriteListBegin(thrift.MAP, len(v)); err != nil {
      return thrift.PrependError("error writing list begin: ", err)
    }
    for _, v := range v {
      if err := oprot.WriteMapBegin(thrift.I32, thrift.MAP, len(v)); err != nil {
        return thrift.PrependError("error writing map begin: ", err)
      }
      for k, v := range v {
        if err := oprot.WriteI32(int32(k)); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err) }
        if err := oprot.WriteMapBegin(thrift.I32, thrift.SET, len(v)); err != nil {
          return thrift.PrependError("error writing map begin: ", err)
        }
        for k, v := range v {
          if err := oprot.WriteI32(int32(k)); err != nil {
          return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err) }
          if err := oprot.WriteSetBegin(thrift.I32, len(v)); err != nil {
            return thrift.PrependError("error writing set begin: ", err)
          }
          set := make(map[int32]bool, len(v))
          for _, v := range v {
            if ok := set[v]; ok {
              return thrift.PrependError("", fmt.Errorf("%T error writing set field: slice is not unique", v))
            }
            set[v] = true
          }
          for _, v := range v {
            if err := oprot.WriteI32(int32(v)); err != nil {
            return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err) }
          }
          if err := oprot.WriteSetEnd(); err != nil {
            return thrift.PrependError("error writing set end: ", err)
          }
        }
        if err := oprot.WriteMapEnd(); err != nil {
          return thrift.PrependError("error writing map end: ", err)
        }
      }
      if err := oprot.WriteMapEnd(); err != nil {
        return thrift.PrependError("error writing map end: ", err)
      }
    }
    if err := oprot.WriteListEnd(); err != nil {
      return thrift.PrependError("error writing list end: ", err)
    }
  }
  if err := oprot.WriteListEnd(); err != nil {
    return thrift.PrependError("error writing list end: ", err)
  }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:foo: ", p), err) }
  return err
}

func (p *NestedContainersTurtlesArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("NestedContainersTurtlesArgs(%+v)", *p)
}

type NestedContainersTurtlesResult struct {
}

func NewNestedContainersTurtlesResult() *NestedContainersTurtlesResult {
  return &NestedContainersTurtlesResult{}
}

func (p *NestedContainersTurtlesResult) Read(iprot thrift.Protocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *NestedContainersTurtlesResult) Write(oprot thrift.Protocol) error {
  if err := oprot.WriteStructBegin("turtles_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *NestedContainersTurtlesResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("NestedContainersTurtlesResult(%+v)", *p)
}


