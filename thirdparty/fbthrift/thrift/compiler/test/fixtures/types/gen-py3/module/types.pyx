#
# Autogenerated by Thrift
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#  @generated
#

from libcpp.memory cimport shared_ptr, make_shared, unique_ptr, make_unique
from libcpp.string cimport string
from libcpp cimport bool as cbool
from libcpp.iterator cimport inserter as cinserter
from cpython cimport bool as pbool
from libc.stdint cimport int8_t, int16_t, int32_t, int64_t, uint32_t
from cython.operator cimport dereference as deref, preincrement as inc, address as ptr_address
import thrift.py3.types
cimport thrift.py3.types
cimport thrift.py3.exceptions
from thrift.py3.types import NOTSET as __NOTSET
from thrift.py3.types cimport translate_cpp_enum_to_python
cimport thrift.py3.std_libcpp as std_libcpp
from thrift.py3.serializer import Protocol
cimport thrift.py3.serializer as serializer
from thrift.py3.serializer import deserialize, serialize
import folly.iobuf as __iobuf
from folly.optional cimport cOptional

import sys
import itertools
from collections import Sequence, Set, Mapping, Iterable
import enum as __enum
import warnings
import builtins as _builtins
cimport include.types as _include_types
import include.types as _include_types


class has_bitwise_ops(__enum.Enum):
    none = 0
    zero = 1
    one = 2
    two = 4
    three = 8

    __hash__ = __enum.Enum.__hash__

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            warnings.warn(f"comparison not supported between instances of {type(self)} and {type(other)}", RuntimeWarning, stacklevel=2)
            return False
        return self.value == other.value

    def __int__(self):
        return self.value

cdef inline chas_bitwise_ops has_bitwise_ops_to_cpp(value):
    cdef int cvalue = value.value
    if cvalue == 0:
        return has_bitwise_ops__none
    elif cvalue == 1:
        return has_bitwise_ops__zero
    elif cvalue == 2:
        return has_bitwise_ops__one
    elif cvalue == 4:
        return has_bitwise_ops__two
    elif cvalue == 8:
        return has_bitwise_ops__three
class is_unscoped(__enum.Enum):
    hello = 0
    world = 1

    __hash__ = __enum.Enum.__hash__

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            warnings.warn(f"comparison not supported between instances of {type(self)} and {type(other)}", RuntimeWarning, stacklevel=2)
            return False
        return self.value == other.value

    def __int__(self):
        return self.value

cdef inline cis_unscoped is_unscoped_to_cpp(value):
    cdef int cvalue = value.value
    if cvalue == 0:
        return is_unscoped__hello
    elif cvalue == 1:
        return is_unscoped__world
class MyForwardRefEnum(__enum.Enum):
    ZERO = 0
    NONZERO = 12

    __hash__ = __enum.Enum.__hash__

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            warnings.warn(f"comparison not supported between instances of {type(self)} and {type(other)}", RuntimeWarning, stacklevel=2)
            return False
        return self.value == other.value

    def __int__(self):
        return self.value

cdef inline cMyForwardRefEnum MyForwardRefEnum_to_cpp(value):
    cdef int cvalue = value.value
    if cvalue == 0:
        return MyForwardRefEnum__ZERO
    elif cvalue == 12:
        return MyForwardRefEnum__NONZERO


cdef cdecorated_struct _decorated_struct_defaults = cdecorated_struct()

cdef class decorated_struct(thrift.py3.types.Struct):

    def __init__(
        decorated_struct self, *,
        str field=None
    ):
        self._cpp_obj = move(decorated_struct._make_instance(
          NULL,
          field,
        ))

    def __call__(
        decorated_struct self,
        field=__NOTSET
    ):
        changes = any((
            field is not __NOTSET,
        ))

        if not changes:
            return self

        if None is not field is not __NOTSET:
            if not isinstance(field, str):
                raise TypeError(f'field is not a { str !r}.')

        inst = <decorated_struct>decorated_struct.__new__(decorated_struct)
        inst._cpp_obj = move(decorated_struct._make_instance(
          self._cpp_obj.get(),
          field,
        ))
        return inst

    @staticmethod
    cdef unique_ptr[cdecorated_struct] _make_instance(
        cdecorated_struct* base_instance,
        object field
    ) except *:
        cdef unique_ptr[cdecorated_struct] c_inst
        if base_instance:
            c_inst = make_unique[cdecorated_struct](deref(base_instance))
        else:
            c_inst = make_unique[cdecorated_struct]()

        if base_instance:
            # Convert None's to default value. (or unset)
            if field is None:
                deref(c_inst).field = _decorated_struct_defaults.field
                deref(c_inst).__isset.field = False
                pass
            elif field is __NOTSET:
                field = None

        if field is not None:
            deref(c_inst).field = field.encode('UTF-8')
            deref(c_inst).__isset.field = True
        # in C++ you don't have to call move(), but this doesn't translate
        # into a C++ return statement, so you do here
        return move_unique(c_inst)

    def __iter__(self):
        yield 'field', self.field

    def __bool__(self):
        return True

    @staticmethod
    cdef create(shared_ptr[cdecorated_struct] cpp_obj):
        inst = <decorated_struct>decorated_struct.__new__(decorated_struct)
        inst._cpp_obj = cpp_obj
        return inst

    @property
    def field(self):

        return (<bytes>self._cpp_obj.get().field).decode('UTF-8')


    def __hash__(decorated_struct self):
        if not self.__hash:
            self.__hash = hash((
            self.field,
            ))
        return self.__hash

    def __repr__(decorated_struct self):
        return f'decorated_struct(field={repr(self.field)})'
    def __richcmp__(self, other, op):
        cdef int cop = op
        if cop not in (2, 3):
            raise TypeError("unorderable types: {}, {}".format(self, other))
        if not (
                isinstance(self, decorated_struct) and
                isinstance(other, decorated_struct)):
            if cop == 2:  # different types are never equal
                return False
            else:         # different types are always notequal
                return True

        cdef cdecorated_struct cself = deref((<decorated_struct>self)._cpp_obj)
        cdef cdecorated_struct cother = deref((<decorated_struct>other)._cpp_obj)
        cdef cbool cmp = cself == cother
        if cop == 2:
            return cmp
        return not cmp

    cdef __iobuf.IOBuf _serialize(decorated_struct self, proto):
        cdef __iobuf.cIOBufQueue queue = __iobuf.cIOBufQueue(__iobuf.cacheChainLength())
        cdef cdecorated_struct* cpp_obj = self._cpp_obj.get()
        if proto is Protocol.COMPACT:
            with nogil:
                serializer.CompactSerialize[cdecorated_struct](deref(cpp_obj), &queue, serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is Protocol.BINARY:
            with nogil:
                serializer.BinarySerialize[cdecorated_struct](deref(cpp_obj), &queue, serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is Protocol.JSON:
            with nogil:
                serializer.JSONSerialize[cdecorated_struct](deref(cpp_obj), &queue, serializer.SHARE_EXTERNAL_BUFFER)
        return __iobuf.from_unique_ptr(queue.move())

    cdef uint32_t _deserialize(decorated_struct self, const __iobuf.cIOBuf* buf, proto) except? 0:
        cdef uint32_t needed
        self._cpp_obj = make_shared[cdecorated_struct]()
        cdef cdecorated_struct* cpp_obj = self._cpp_obj.get()
        if proto is Protocol.COMPACT:
            with nogil:
                needed = serializer.CompactDeserialize[cdecorated_struct](buf, deref(cpp_obj), serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is Protocol.BINARY:
            with nogil:
                needed = serializer.BinaryDeserialize[cdecorated_struct](buf, deref(cpp_obj), serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is Protocol.JSON:
            with nogil:
                needed = serializer.JSONDeserialize[cdecorated_struct](buf, deref(cpp_obj), serializer.SHARE_EXTERNAL_BUFFER)
        return needed

    def __reduce__(self):
        return (deserialize, (decorated_struct, serialize(self)))


cdef cContainerStruct _ContainerStruct_defaults = cContainerStruct()

cdef class ContainerStruct(thrift.py3.types.Struct):

    def __init__(
        ContainerStruct self, *,
        fieldA=None,
        fieldB=None,
        fieldC=None,
        fieldD=None,
        fieldE=None,
        fieldF=None,
        fieldG=None,
        fieldH=None
    ):
        self._cpp_obj = move(ContainerStruct._make_instance(
          NULL,
          fieldA,
          fieldB,
          fieldC,
          fieldD,
          fieldE,
          fieldF,
          fieldG,
          fieldH,
        ))

    def __call__(
        ContainerStruct self,
        fieldA=__NOTSET,
        fieldB=__NOTSET,
        fieldC=__NOTSET,
        fieldD=__NOTSET,
        fieldE=__NOTSET,
        fieldF=__NOTSET,
        fieldG=__NOTSET,
        fieldH=__NOTSET
    ):
        changes = any((
            fieldA is not __NOTSET,

            fieldB is not __NOTSET,

            fieldC is not __NOTSET,

            fieldD is not __NOTSET,

            fieldE is not __NOTSET,

            fieldF is not __NOTSET,

            fieldG is not __NOTSET,

            fieldH is not __NOTSET,
        ))

        if not changes:
            return self

        inst = <ContainerStruct>ContainerStruct.__new__(ContainerStruct)
        inst._cpp_obj = move(ContainerStruct._make_instance(
          self._cpp_obj.get(),
          fieldA,
          fieldB,
          fieldC,
          fieldD,
          fieldE,
          fieldF,
          fieldG,
          fieldH,
        ))
        return inst

    @staticmethod
    cdef unique_ptr[cContainerStruct] _make_instance(
        cContainerStruct* base_instance,
        object fieldA,
        object fieldB,
        object fieldC,
        object fieldD,
        object fieldE,
        object fieldF,
        object fieldG,
        object fieldH
    ) except *:
        cdef unique_ptr[cContainerStruct] c_inst
        if base_instance:
            c_inst = make_unique[cContainerStruct](deref(base_instance))
        else:
            c_inst = make_unique[cContainerStruct]()

        if base_instance:
            # Convert None's to default value. (or unset)
            if fieldA is None:
                deref(c_inst).fieldA = _ContainerStruct_defaults.fieldA
                deref(c_inst).__isset.fieldA = False
                pass
            elif fieldA is __NOTSET:
                fieldA = None

            if fieldB is None:
                deref(c_inst).fieldB = _ContainerStruct_defaults.fieldB
                deref(c_inst).__isset.fieldB = False
                pass
            elif fieldB is __NOTSET:
                fieldB = None

            if fieldC is None:
                deref(c_inst).fieldC = _ContainerStruct_defaults.fieldC
                deref(c_inst).__isset.fieldC = False
                pass
            elif fieldC is __NOTSET:
                fieldC = None

            if fieldD is None:
                deref(c_inst).fieldD = _ContainerStruct_defaults.fieldD
                deref(c_inst).__isset.fieldD = False
                pass
            elif fieldD is __NOTSET:
                fieldD = None

            if fieldE is None:
                deref(c_inst).fieldE = _ContainerStruct_defaults.fieldE
                deref(c_inst).__isset.fieldE = False
                pass
            elif fieldE is __NOTSET:
                fieldE = None

            if fieldF is None:
                deref(c_inst).fieldF = _ContainerStruct_defaults.fieldF
                deref(c_inst).__isset.fieldF = False
                pass
            elif fieldF is __NOTSET:
                fieldF = None

            if fieldG is None:
                deref(c_inst).fieldG = _ContainerStruct_defaults.fieldG
                deref(c_inst).__isset.fieldG = False
                pass
            elif fieldG is __NOTSET:
                fieldG = None

            if fieldH is None:
                deref(c_inst).fieldH = _ContainerStruct_defaults.fieldH
                deref(c_inst).__isset.fieldH = False
                pass
            elif fieldH is __NOTSET:
                fieldH = None

        if fieldA is not None:
            deref(c_inst).fieldA = deref(List__i32(fieldA)._cpp_obj)
            deref(c_inst).__isset.fieldA = True
        if fieldB is not None:
            deref(c_inst).fieldB = deref(std_list__List__i32(fieldB)._cpp_obj)
            deref(c_inst).__isset.fieldB = True
        if fieldC is not None:
            deref(c_inst).fieldC = deref(std_deque__List__i32(fieldC)._cpp_obj)
            deref(c_inst).__isset.fieldC = True
        if fieldD is not None:
            deref(c_inst).fieldD = deref(folly_fbvector__List__i32(fieldD)._cpp_obj)
            deref(c_inst).__isset.fieldD = True
        if fieldE is not None:
            deref(c_inst).fieldE = deref(folly_small_vector__List__i32(fieldE)._cpp_obj)
            deref(c_inst).__isset.fieldE = True
        if fieldF is not None:
            deref(c_inst).fieldF = deref(folly_sorted_vector_set__Set__i32(fieldF)._cpp_obj)
            deref(c_inst).__isset.fieldF = True
        if fieldG is not None:
            deref(c_inst).fieldG = deref(folly_sorted_vector_map__Map__i32_string(fieldG)._cpp_obj)
            deref(c_inst).__isset.fieldG = True
        if fieldH is not None:
            deref(c_inst).fieldH = deref(std_unordered_map__Map__i32_string(fieldH)._cpp_obj)
            deref(c_inst).__isset.fieldH = True
        # in C++ you don't have to call move(), but this doesn't translate
        # into a C++ return statement, so you do here
        return move_unique(c_inst)

    def __iter__(self):
        yield 'fieldA', self.fieldA
        yield 'fieldB', self.fieldB
        yield 'fieldC', self.fieldC
        yield 'fieldD', self.fieldD
        yield 'fieldE', self.fieldE
        yield 'fieldF', self.fieldF
        yield 'fieldG', self.fieldG
        yield 'fieldH', self.fieldH

    def __bool__(self):
        return True or True or True or True or True or True or True or True

    @staticmethod
    cdef create(shared_ptr[cContainerStruct] cpp_obj):
        inst = <ContainerStruct>ContainerStruct.__new__(ContainerStruct)
        inst._cpp_obj = cpp_obj
        return inst

    @property
    def fieldA(self):

        if self.__fieldA is None:
            self.__fieldA = List__i32.create(make_shared[vector[int32_t]](deref(self._cpp_obj).fieldA))
        return self.__fieldA

    @property
    def fieldB(self):

        if self.__fieldB is None:
            self.__fieldB = std_list__List__i32.create(make_shared[std_list[int32_t]](deref(self._cpp_obj).fieldB))
        return self.__fieldB

    @property
    def fieldC(self):

        if self.__fieldC is None:
            self.__fieldC = std_deque__List__i32.create(make_shared[std_deque[int32_t]](deref(self._cpp_obj).fieldC))
        return self.__fieldC

    @property
    def fieldD(self):

        if self.__fieldD is None:
            self.__fieldD = folly_fbvector__List__i32.create(make_shared[folly_fbvector[int32_t]](deref(self._cpp_obj).fieldD))
        return self.__fieldD

    @property
    def fieldE(self):

        if self.__fieldE is None:
            self.__fieldE = folly_small_vector__List__i32.create(make_shared[folly_small_vector[int32_t]](deref(self._cpp_obj).fieldE))
        return self.__fieldE

    @property
    def fieldF(self):

        if self.__fieldF is None:
            self.__fieldF = folly_sorted_vector_set__Set__i32.create(make_shared[folly_sorted_vector_set[int32_t]](deref(self._cpp_obj).fieldF))
        return self.__fieldF

    @property
    def fieldG(self):

        if self.__fieldG is None:
            self.__fieldG = folly_sorted_vector_map__Map__i32_string.create(make_shared[folly_sorted_vector_map[int32_t,string]](deref(self._cpp_obj).fieldG))
        return self.__fieldG

    @property
    def fieldH(self):

        if self.__fieldH is None:
            self.__fieldH = std_unordered_map__Map__i32_string.create(make_shared[std_unordered_map[int32_t,string]](deref(self._cpp_obj).fieldH))
        return self.__fieldH


    def __hash__(ContainerStruct self):
        if not self.__hash:
            self.__hash = hash((
            self.fieldA,
            self.fieldB,
            self.fieldC,
            self.fieldD,
            self.fieldE,
            self.fieldF,
            self.fieldG,
            self.fieldH,
            ))
        return self.__hash

    def __repr__(ContainerStruct self):
        return f'ContainerStruct(fieldA={repr(self.fieldA)}, fieldB={repr(self.fieldB)}, fieldC={repr(self.fieldC)}, fieldD={repr(self.fieldD)}, fieldE={repr(self.fieldE)}, fieldF={repr(self.fieldF)}, fieldG={repr(self.fieldG)}, fieldH={repr(self.fieldH)})'
    def __richcmp__(self, other, op):
        cdef int cop = op
        if cop not in (2, 3):
            raise TypeError("unorderable types: {}, {}".format(self, other))
        if not (
                isinstance(self, ContainerStruct) and
                isinstance(other, ContainerStruct)):
            if cop == 2:  # different types are never equal
                return False
            else:         # different types are always notequal
                return True

        cdef cContainerStruct cself = deref((<ContainerStruct>self)._cpp_obj)
        cdef cContainerStruct cother = deref((<ContainerStruct>other)._cpp_obj)
        cdef cbool cmp = cself == cother
        if cop == 2:
            return cmp
        return not cmp

    cdef __iobuf.IOBuf _serialize(ContainerStruct self, proto):
        cdef __iobuf.cIOBufQueue queue = __iobuf.cIOBufQueue(__iobuf.cacheChainLength())
        cdef cContainerStruct* cpp_obj = self._cpp_obj.get()
        if proto is Protocol.COMPACT:
            with nogil:
                serializer.CompactSerialize[cContainerStruct](deref(cpp_obj), &queue, serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is Protocol.BINARY:
            with nogil:
                serializer.BinarySerialize[cContainerStruct](deref(cpp_obj), &queue, serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is Protocol.JSON:
            with nogil:
                serializer.JSONSerialize[cContainerStruct](deref(cpp_obj), &queue, serializer.SHARE_EXTERNAL_BUFFER)
        return __iobuf.from_unique_ptr(queue.move())

    cdef uint32_t _deserialize(ContainerStruct self, const __iobuf.cIOBuf* buf, proto) except? 0:
        cdef uint32_t needed
        self._cpp_obj = make_shared[cContainerStruct]()
        cdef cContainerStruct* cpp_obj = self._cpp_obj.get()
        if proto is Protocol.COMPACT:
            with nogil:
                needed = serializer.CompactDeserialize[cContainerStruct](buf, deref(cpp_obj), serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is Protocol.BINARY:
            with nogil:
                needed = serializer.BinaryDeserialize[cContainerStruct](buf, deref(cpp_obj), serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is Protocol.JSON:
            with nogil:
                needed = serializer.JSONDeserialize[cContainerStruct](buf, deref(cpp_obj), serializer.SHARE_EXTERNAL_BUFFER)
        return needed

    def __reduce__(self):
        return (deserialize, (ContainerStruct, serialize(self)))


cdef cCppTypeStruct _CppTypeStruct_defaults = cCppTypeStruct()

cdef class CppTypeStruct(thrift.py3.types.Struct):

    def __init__(
        CppTypeStruct self, *,
        fieldA=None
    ):
        self._cpp_obj = move(CppTypeStruct._make_instance(
          NULL,
          fieldA,
        ))

    def __call__(
        CppTypeStruct self,
        fieldA=__NOTSET
    ):
        changes = any((
            fieldA is not __NOTSET,
        ))

        if not changes:
            return self

        inst = <CppTypeStruct>CppTypeStruct.__new__(CppTypeStruct)
        inst._cpp_obj = move(CppTypeStruct._make_instance(
          self._cpp_obj.get(),
          fieldA,
        ))
        return inst

    @staticmethod
    cdef unique_ptr[cCppTypeStruct] _make_instance(
        cCppTypeStruct* base_instance,
        object fieldA
    ) except *:
        cdef unique_ptr[cCppTypeStruct] c_inst
        if base_instance:
            c_inst = make_unique[cCppTypeStruct](deref(base_instance))
        else:
            c_inst = make_unique[cCppTypeStruct]()

        if base_instance:
            # Convert None's to default value. (or unset)
            if fieldA is None:
                deref(c_inst).fieldA = _CppTypeStruct_defaults.fieldA
                deref(c_inst).__isset.fieldA = False
                pass
            elif fieldA is __NOTSET:
                fieldA = None

        if fieldA is not None:
            deref(c_inst).fieldA = deref(std_list_int32_t__List__i32(fieldA)._cpp_obj)
            deref(c_inst).__isset.fieldA = True
        # in C++ you don't have to call move(), but this doesn't translate
        # into a C++ return statement, so you do here
        return move_unique(c_inst)

    def __iter__(self):
        yield 'fieldA', self.fieldA

    def __bool__(self):
        return True

    @staticmethod
    cdef create(shared_ptr[cCppTypeStruct] cpp_obj):
        inst = <CppTypeStruct>CppTypeStruct.__new__(CppTypeStruct)
        inst._cpp_obj = cpp_obj
        return inst

    @property
    def fieldA(self):

        if self.__fieldA is None:
            self.__fieldA = std_list_int32_t__List__i32.create(make_shared[std_list_int32_t](deref(self._cpp_obj).fieldA))
        return self.__fieldA


    def __hash__(CppTypeStruct self):
        if not self.__hash:
            self.__hash = hash((
            self.fieldA,
            ))
        return self.__hash

    def __repr__(CppTypeStruct self):
        return f'CppTypeStruct(fieldA={repr(self.fieldA)})'
    def __richcmp__(self, other, op):
        cdef int cop = op
        if cop not in (2, 3):
            raise TypeError("unorderable types: {}, {}".format(self, other))
        if not (
                isinstance(self, CppTypeStruct) and
                isinstance(other, CppTypeStruct)):
            if cop == 2:  # different types are never equal
                return False
            else:         # different types are always notequal
                return True

        cdef cCppTypeStruct cself = deref((<CppTypeStruct>self)._cpp_obj)
        cdef cCppTypeStruct cother = deref((<CppTypeStruct>other)._cpp_obj)
        cdef cbool cmp = cself == cother
        if cop == 2:
            return cmp
        return not cmp

    cdef __iobuf.IOBuf _serialize(CppTypeStruct self, proto):
        cdef __iobuf.cIOBufQueue queue = __iobuf.cIOBufQueue(__iobuf.cacheChainLength())
        cdef cCppTypeStruct* cpp_obj = self._cpp_obj.get()
        if proto is Protocol.COMPACT:
            with nogil:
                serializer.CompactSerialize[cCppTypeStruct](deref(cpp_obj), &queue, serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is Protocol.BINARY:
            with nogil:
                serializer.BinarySerialize[cCppTypeStruct](deref(cpp_obj), &queue, serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is Protocol.JSON:
            with nogil:
                serializer.JSONSerialize[cCppTypeStruct](deref(cpp_obj), &queue, serializer.SHARE_EXTERNAL_BUFFER)
        return __iobuf.from_unique_ptr(queue.move())

    cdef uint32_t _deserialize(CppTypeStruct self, const __iobuf.cIOBuf* buf, proto) except? 0:
        cdef uint32_t needed
        self._cpp_obj = make_shared[cCppTypeStruct]()
        cdef cCppTypeStruct* cpp_obj = self._cpp_obj.get()
        if proto is Protocol.COMPACT:
            with nogil:
                needed = serializer.CompactDeserialize[cCppTypeStruct](buf, deref(cpp_obj), serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is Protocol.BINARY:
            with nogil:
                needed = serializer.BinaryDeserialize[cCppTypeStruct](buf, deref(cpp_obj), serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is Protocol.JSON:
            with nogil:
                needed = serializer.JSONDeserialize[cCppTypeStruct](buf, deref(cpp_obj), serializer.SHARE_EXTERNAL_BUFFER)
        return needed

    def __reduce__(self):
        return (deserialize, (CppTypeStruct, serialize(self)))


cdef cVirtualStruct _VirtualStruct_defaults = cVirtualStruct()

cdef class VirtualStruct(thrift.py3.types.Struct):

    def __init__(
        VirtualStruct self, *,
        MyIntField=None
    ):
        if MyIntField is not None:
            if not isinstance(MyIntField, int):
                raise TypeError(f'MyIntField is not a { int !r}.')
            MyIntField = <int64_t> MyIntField

        self._cpp_obj = move(VirtualStruct._make_instance(
          NULL,
          MyIntField,
        ))

    def __call__(
        VirtualStruct self,
        MyIntField=__NOTSET
    ):
        changes = any((
            MyIntField is not __NOTSET,
        ))

        if not changes:
            return self

        if None is not MyIntField is not __NOTSET:
            if not isinstance(MyIntField, int):
                raise TypeError(f'MyIntField is not a { int !r}.')
            MyIntField = <int64_t> MyIntField

        inst = <VirtualStruct>VirtualStruct.__new__(VirtualStruct)
        inst._cpp_obj = move(VirtualStruct._make_instance(
          self._cpp_obj.get(),
          MyIntField,
        ))
        return inst

    @staticmethod
    cdef unique_ptr[cVirtualStruct] _make_instance(
        cVirtualStruct* base_instance,
        object MyIntField
    ) except *:
        cdef unique_ptr[cVirtualStruct] c_inst
        if base_instance:
            c_inst = make_unique[cVirtualStruct](deref(base_instance))
        else:
            c_inst = make_unique[cVirtualStruct]()

        if base_instance:
            # Convert None's to default value. (or unset)
            if MyIntField is None:
                deref(c_inst).MyIntField = _VirtualStruct_defaults.MyIntField
                deref(c_inst).__isset.MyIntField = False
                pass
            elif MyIntField is __NOTSET:
                MyIntField = None

        if MyIntField is not None:
            deref(c_inst).MyIntField = MyIntField
            deref(c_inst).__isset.MyIntField = True
        # in C++ you don't have to call move(), but this doesn't translate
        # into a C++ return statement, so you do here
        return move_unique(c_inst)

    def __iter__(self):
        yield 'MyIntField', self.MyIntField

    def __bool__(self):
        return True

    @staticmethod
    cdef create(shared_ptr[cVirtualStruct] cpp_obj):
        inst = <VirtualStruct>VirtualStruct.__new__(VirtualStruct)
        inst._cpp_obj = cpp_obj
        return inst

    @property
    def MyIntField(self):

        return self._cpp_obj.get().MyIntField


    def __hash__(VirtualStruct self):
        if not self.__hash:
            self.__hash = hash((
            self.MyIntField,
            ))
        return self.__hash

    def __repr__(VirtualStruct self):
        return f'VirtualStruct(MyIntField={repr(self.MyIntField)})'
    def __richcmp__(self, other, op):
        cdef int cop = op
        if cop not in (2, 3):
            raise TypeError("unorderable types: {}, {}".format(self, other))
        if not (
                isinstance(self, VirtualStruct) and
                isinstance(other, VirtualStruct)):
            if cop == 2:  # different types are never equal
                return False
            else:         # different types are always notequal
                return True

        cdef cVirtualStruct cself = deref((<VirtualStruct>self)._cpp_obj)
        cdef cVirtualStruct cother = deref((<VirtualStruct>other)._cpp_obj)
        cdef cbool cmp = cself == cother
        if cop == 2:
            return cmp
        return not cmp

    cdef __iobuf.IOBuf _serialize(VirtualStruct self, proto):
        cdef __iobuf.cIOBufQueue queue = __iobuf.cIOBufQueue(__iobuf.cacheChainLength())
        cdef cVirtualStruct* cpp_obj = self._cpp_obj.get()
        if proto is Protocol.COMPACT:
            with nogil:
                serializer.CompactSerialize[cVirtualStruct](deref(cpp_obj), &queue, serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is Protocol.BINARY:
            with nogil:
                serializer.BinarySerialize[cVirtualStruct](deref(cpp_obj), &queue, serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is Protocol.JSON:
            with nogil:
                serializer.JSONSerialize[cVirtualStruct](deref(cpp_obj), &queue, serializer.SHARE_EXTERNAL_BUFFER)
        return __iobuf.from_unique_ptr(queue.move())

    cdef uint32_t _deserialize(VirtualStruct self, const __iobuf.cIOBuf* buf, proto) except? 0:
        cdef uint32_t needed
        self._cpp_obj = make_shared[cVirtualStruct]()
        cdef cVirtualStruct* cpp_obj = self._cpp_obj.get()
        if proto is Protocol.COMPACT:
            with nogil:
                needed = serializer.CompactDeserialize[cVirtualStruct](buf, deref(cpp_obj), serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is Protocol.BINARY:
            with nogil:
                needed = serializer.BinaryDeserialize[cVirtualStruct](buf, deref(cpp_obj), serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is Protocol.JSON:
            with nogil:
                needed = serializer.JSONDeserialize[cVirtualStruct](buf, deref(cpp_obj), serializer.SHARE_EXTERNAL_BUFFER)
        return needed

    def __reduce__(self):
        return (deserialize, (VirtualStruct, serialize(self)))


cdef cMyStructWithForwardRefEnum _MyStructWithForwardRefEnum_defaults = cMyStructWithForwardRefEnum()

cdef class MyStructWithForwardRefEnum(thrift.py3.types.Struct):

    def __init__(
        MyStructWithForwardRefEnum self, *,
        a=None,
        b=None
    ):
        if a is not None:
            if not isinstance(a, MyForwardRefEnum):
                raise TypeError(f'field a value: { a !r} is not of the enum type { MyForwardRefEnum }.')

        if b is not None:
            if not isinstance(b, MyForwardRefEnum):
                raise TypeError(f'field b value: { b !r} is not of the enum type { MyForwardRefEnum }.')

        self._cpp_obj = move(MyStructWithForwardRefEnum._make_instance(
          NULL,
          a,
          b,
        ))

    def __call__(
        MyStructWithForwardRefEnum self,
        a=__NOTSET,
        b=__NOTSET
    ):
        changes = any((
            a is not __NOTSET,

            b is not __NOTSET,
        ))

        if not changes:
            return self

        if None is not a is not __NOTSET:
            if not isinstance(a, MyForwardRefEnum):
                raise TypeError(f'field a value: { a !r} is not of the enum type { MyForwardRefEnum }.')

        if None is not b is not __NOTSET:
            if not isinstance(b, MyForwardRefEnum):
                raise TypeError(f'field b value: { b !r} is not of the enum type { MyForwardRefEnum }.')

        inst = <MyStructWithForwardRefEnum>MyStructWithForwardRefEnum.__new__(MyStructWithForwardRefEnum)
        inst._cpp_obj = move(MyStructWithForwardRefEnum._make_instance(
          self._cpp_obj.get(),
          a,
          b,
        ))
        return inst

    @staticmethod
    cdef unique_ptr[cMyStructWithForwardRefEnum] _make_instance(
        cMyStructWithForwardRefEnum* base_instance,
        object a,
        object b
    ) except *:
        cdef unique_ptr[cMyStructWithForwardRefEnum] c_inst
        if base_instance:
            c_inst = make_unique[cMyStructWithForwardRefEnum](deref(base_instance))
        else:
            c_inst = make_unique[cMyStructWithForwardRefEnum]()

        if base_instance:
            # Convert None's to default value. (or unset)
            if a is None:
                deref(c_inst).a = _MyStructWithForwardRefEnum_defaults.a
                deref(c_inst).__isset.a = False
                pass
            elif a is __NOTSET:
                a = None

            if b is None:
                deref(c_inst).b = _MyStructWithForwardRefEnum_defaults.b
                deref(c_inst).__isset.b = False
                pass
            elif b is __NOTSET:
                b = None

        if a is not None:
            deref(c_inst).a = MyForwardRefEnum_to_cpp(a)
            deref(c_inst).__isset.a = True
        if b is not None:
            deref(c_inst).b = MyForwardRefEnum_to_cpp(b)
            deref(c_inst).__isset.b = True
        # in C++ you don't have to call move(), but this doesn't translate
        # into a C++ return statement, so you do here
        return move_unique(c_inst)

    def __iter__(self):
        yield 'a', self.a
        yield 'b', self.b

    def __bool__(self):
        return True or True

    @staticmethod
    cdef create(shared_ptr[cMyStructWithForwardRefEnum] cpp_obj):
        inst = <MyStructWithForwardRefEnum>MyStructWithForwardRefEnum.__new__(MyStructWithForwardRefEnum)
        inst._cpp_obj = cpp_obj
        return inst

    @property
    def a(self):

        return translate_cpp_enum_to_python(MyForwardRefEnum, <int>(deref(self._cpp_obj).a))

    @property
    def b(self):

        return translate_cpp_enum_to_python(MyForwardRefEnum, <int>(deref(self._cpp_obj).b))


    def __hash__(MyStructWithForwardRefEnum self):
        if not self.__hash:
            self.__hash = hash((
            self.a,
            self.b,
            ))
        return self.__hash

    def __repr__(MyStructWithForwardRefEnum self):
        return f'MyStructWithForwardRefEnum(a={repr(self.a)}, b={repr(self.b)})'
    def __richcmp__(self, other, op):
        cdef int cop = op
        if cop not in (2, 3):
            raise TypeError("unorderable types: {}, {}".format(self, other))
        if not (
                isinstance(self, MyStructWithForwardRefEnum) and
                isinstance(other, MyStructWithForwardRefEnum)):
            if cop == 2:  # different types are never equal
                return False
            else:         # different types are always notequal
                return True

        cdef cMyStructWithForwardRefEnum cself = deref((<MyStructWithForwardRefEnum>self)._cpp_obj)
        cdef cMyStructWithForwardRefEnum cother = deref((<MyStructWithForwardRefEnum>other)._cpp_obj)
        cdef cbool cmp = cself == cother
        if cop == 2:
            return cmp
        return not cmp

    cdef __iobuf.IOBuf _serialize(MyStructWithForwardRefEnum self, proto):
        cdef __iobuf.cIOBufQueue queue = __iobuf.cIOBufQueue(__iobuf.cacheChainLength())
        cdef cMyStructWithForwardRefEnum* cpp_obj = self._cpp_obj.get()
        if proto is Protocol.COMPACT:
            with nogil:
                serializer.CompactSerialize[cMyStructWithForwardRefEnum](deref(cpp_obj), &queue, serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is Protocol.BINARY:
            with nogil:
                serializer.BinarySerialize[cMyStructWithForwardRefEnum](deref(cpp_obj), &queue, serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is Protocol.JSON:
            with nogil:
                serializer.JSONSerialize[cMyStructWithForwardRefEnum](deref(cpp_obj), &queue, serializer.SHARE_EXTERNAL_BUFFER)
        return __iobuf.from_unique_ptr(queue.move())

    cdef uint32_t _deserialize(MyStructWithForwardRefEnum self, const __iobuf.cIOBuf* buf, proto) except? 0:
        cdef uint32_t needed
        self._cpp_obj = make_shared[cMyStructWithForwardRefEnum]()
        cdef cMyStructWithForwardRefEnum* cpp_obj = self._cpp_obj.get()
        if proto is Protocol.COMPACT:
            with nogil:
                needed = serializer.CompactDeserialize[cMyStructWithForwardRefEnum](buf, deref(cpp_obj), serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is Protocol.BINARY:
            with nogil:
                needed = serializer.BinaryDeserialize[cMyStructWithForwardRefEnum](buf, deref(cpp_obj), serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is Protocol.JSON:
            with nogil:
                needed = serializer.JSONDeserialize[cMyStructWithForwardRefEnum](buf, deref(cpp_obj), serializer.SHARE_EXTERNAL_BUFFER)
        return needed

    def __reduce__(self):
        return (deserialize, (MyStructWithForwardRefEnum, serialize(self)))


cdef class std_unordered_map__Map__i32_string:
    def __init__(self, items=None):
        if isinstance(items, std_unordered_map__Map__i32_string):
            self._cpp_obj = (<std_unordered_map__Map__i32_string> items)._cpp_obj
        else:
            self._cpp_obj = move(std_unordered_map__Map__i32_string._make_instance(items))

    @staticmethod
    cdef create(shared_ptr[std_unordered_map[int32_t,string]] c_items):
        inst = <std_unordered_map__Map__i32_string>std_unordered_map__Map__i32_string.__new__(std_unordered_map__Map__i32_string)
        inst._cpp_obj = c_items
        return inst

    @staticmethod
    cdef unique_ptr[std_unordered_map[int32_t,string]] _make_instance(object items) except *:
        cdef unique_ptr[std_unordered_map[int32_t,string]] c_inst = make_unique[std_unordered_map[int32_t,string]]()
        if items is not None:
            for key, item in items.items():
                if not isinstance(key, int):
                    raise TypeError(f"{key!r} is not of type int")
                key = <int32_t> key
                if not isinstance(item, str):
                    raise TypeError(f"{item!r} is not of type str")

                deref(c_inst).insert(cpair[int32_t,string](key,item.encode('UTF-8')))
        return move_unique(c_inst)

    def __getitem__(self, key):
        err = KeyError(f'{key}')
        if not self or key is None:
            raise err
        if not isinstance(key, int):
            raise err
        cdef int32_t ckey = key
        cdef std_unordered_map[int32_t,string].iterator iter = deref(
            self._cpp_obj).find(ckey)
        if iter == deref(self._cpp_obj).end():
            raise err
        cdef string citem = deref(iter).second
        return bytes(citem).decode('UTF-8')

    def __len__(self):
        return deref(self._cpp_obj).size()

    def __iter__(self):
        if not self:
            raise StopIteration
        cdef int32_t citem
        for pair in deref(self._cpp_obj):
            citem = pair.first
            yield citem

    def __richcmp__(self, other, op):
        cdef int cop = op
        if cop not in (2, 3):
            raise TypeError("unorderable types: {}, {}".format(type(self), type(other)))
        if not (isinstance(self, Mapping) and isinstance(other, Mapping)):
            return cop != 2
        if (len(self) != len(other)):
            return cop != 2

        for key in self:
            if key not in other:
                return cop != 2
            if other[key] != self[key]:
                return cop != 2

        return cop == 2

    def __hash__(self):
        if not self.__hash:
            self.__hash = hash(tuple(self.items()))
        return self.__hash

    def __repr__(self):
        if not self:
            return 'i{}'
        return f'i{{{", ".join(map(lambda i: f"{repr(i[0])}: {repr(i[1])}", self.items()))}}}'

    def __contains__(self, key):
        if not self or key is None:
            return False
        if not isinstance(key, int):
            return False
        cdef int32_t ckey = key
        return deref(self._cpp_obj).count(ckey) > 0

    def get(self, key, default=None):
        if not self or key is None:
            return default
        try:
            if not isinstance(key, int):
                key = int(key)
        except Exception:
            return default
        if not isinstance(key, int):
            return default
        if key not in self:
            return default
        return self[key]

    def keys(self):
        return self.__iter__()

    def values(self):
        if not self:
            raise StopIteration
        cdef string citem
        for pair in deref(self._cpp_obj):
            citem = pair.second
            yield bytes(citem).decode('UTF-8')

    def items(self):
        if not self:
            raise StopIteration
        cdef int32_t ckey
        cdef string citem
        for pair in deref(self._cpp_obj):
            ckey = pair.first
            citem = pair.second

            yield (ckey, bytes(citem).decode('UTF-8'))



Mapping.register(std_unordered_map__Map__i32_string)

cdef class List__i32:
    def __init__(self, items=None):
        if isinstance(items, List__i32):
            self._cpp_obj = (<List__i32> items)._cpp_obj
        else:
            self._cpp_obj = move(List__i32._make_instance(items))

    @staticmethod
    cdef create(shared_ptr[vector[int32_t]] c_items):
        inst = <List__i32>List__i32.__new__(List__i32)
        inst._cpp_obj = c_items
        return inst

    @staticmethod
    cdef unique_ptr[vector[int32_t]] _make_instance(object items) except *:
        cdef unique_ptr[vector[int32_t]] c_inst = make_unique[vector[int32_t]]()
        if items is not None:
            for item in items:
                if not isinstance(item, int):
                    raise TypeError(f"{item!r} is not of type int")
                item = <int32_t> item
                deref(c_inst).push_back(item)
        return move_unique(c_inst)

    def __add__(object self, object other):
        return type(self)(itertools.chain(self, other))

    def __getitem__(self, object index_obj):
        cdef shared_ptr[vector[int32_t]] c_inst
        cdef int32_t citem
        if isinstance(index_obj, slice):
            c_inst = make_shared[vector[int32_t]]()
            sz = deref(self._cpp_obj).size()
            for index in range(*index_obj.indices(sz)):
                citem = deref(self._cpp_obj.get())[index]
                deref(c_inst).push_back(citem)
            return List__i32.create(c_inst)
        else:
            index = <int?>index_obj
            size = len(self)
            # Convert a negative index
            if index < 0:
                index = size + index
            if index >= size or index < 0:
                raise IndexError('list index out of range')
            citem = deref(self._cpp_obj.get())[index]
            return citem

    def __len__(self):
        return deref(self._cpp_obj).size()

    def __richcmp__(self, other, op):
        cdef int cop = op
        if cop not in (2, 3):
            raise TypeError("unorderable types: {}, {}".format(type(self), type(other)))
        if not (isinstance(self, Iterable) and isinstance(other, Iterable)):
            return cop != 2
        if (len(self) != len(other)):
            return cop != 2

        for one, two in zip(self, other):
            if one != two:
                return cop != 2

        return cop == 2

    def __hash__(self):
        if not self.__hash:
            self.__hash = hash(tuple(self))
        return self.__hash

    def __contains__(self, item):
        if not self or item is None:
            return False
        if not isinstance(item, int):
            return False
        cdef int32_t citem = item
        cdef vector[int32_t] vec = deref(
            self._cpp_obj.get())
        return std_libcpp.find(vec.begin(), vec.end(), citem) != vec.end()

    def __iter__(self):
        if not self:
            raise StopIteration
        cdef int32_t citem
        for citem in deref(self._cpp_obj):
            yield citem

    def __repr__(self):
        if not self:
            return 'i[]'
        return f'i[{", ".join(map(repr, self))}]'

    def __reversed__(self):
        if not self:
            raise StopIteration
        cdef int32_t citem
        cdef vector[int32_t] vec = deref(
            self._cpp_obj.get())
        cdef vector[int32_t].reverse_iterator loc = vec.rbegin()
        while loc != vec.rend():
            citem = deref(loc)
            yield citem
            inc(loc)

    def index(self, item, start not None=__NOTSET, stop not None=__NOTSET):
        err = ValueError(f'{item} is not in list')
        if not self or item is None:
            raise err
        offset_begin = offset_end = 0
        if stop is not __NOTSET or start is not __NOTSET:
            # Like self[start:stop].index(item)
            size = len(self)
            stop = stop if stop is not __NOTSET else size
            start = start if start is not __NOTSET else 0
            # Convert stop to a negative position.
            if stop > 0:
                stop = min(stop - size, 0)
            if stop <= -size:
                raise err  # List would be empty
            offset_end = -stop
            # Convert start to always be positive
            if start < 0:
                start = max(size + start, 0)
            if start >= size:
                raise err  # past end of list
            offset_begin = start

        if not isinstance(item, int):
            raise err
        cdef int32_t citem = item
        cdef vector[int32_t] vec = deref(self._cpp_obj.get())
        cdef vector[int32_t].iterator end = std_libcpp.prev(vec.end(), <int64_t>offset_end)
        cdef vector[int32_t].iterator loc = std_libcpp.find(
            std_libcpp.next(vec.begin(), <int64_t>offset_begin),
            end,
            citem
        )
        if loc != end:
            return <int64_t> std_libcpp.distance(vec.begin(), loc)
        raise err

    def count(self, item):
        if not self or item is None:
            return 0
        if not isinstance(item, int):
            return 0
        cdef int32_t citem = item
        cdef vector[int32_t] vec = deref(self._cpp_obj.get())
        return <int64_t> std_libcpp.count(vec.begin(), vec.end(), citem)


Sequence.register(List__i32)

cdef class std_list__List__i32:
    def __init__(self, items=None):
        if isinstance(items, std_list__List__i32):
            self._cpp_obj = (<std_list__List__i32> items)._cpp_obj
        else:
            self._cpp_obj = move(std_list__List__i32._make_instance(items))

    @staticmethod
    cdef create(shared_ptr[std_list[int32_t]] c_items):
        inst = <std_list__List__i32>std_list__List__i32.__new__(std_list__List__i32)
        inst._cpp_obj = c_items
        return inst

    @staticmethod
    cdef unique_ptr[std_list[int32_t]] _make_instance(object items) except *:
        cdef unique_ptr[std_list[int32_t]] c_inst = make_unique[std_list[int32_t]]()
        if items is not None:
            for item in items:
                if not isinstance(item, int):
                    raise TypeError(f"{item!r} is not of type int")
                item = <int32_t> item
                deref(c_inst).push_back(item)
        return move_unique(c_inst)

    def __add__(object self, object other):
        return type(self)(itertools.chain(self, other))

    def __getitem__(self, object index_obj):
        cdef shared_ptr[std_list[int32_t]] c_inst
        cdef int32_t citem
        if isinstance(index_obj, slice):
            c_inst = make_shared[std_list[int32_t]]()
            sz = deref(self._cpp_obj).size()
            for index in range(*index_obj.indices(sz)):
                citem = deref(self._cpp_obj.get())[index]
                deref(c_inst).push_back(citem)
            return std_list__List__i32.create(c_inst)
        else:
            index = <int?>index_obj
            size = len(self)
            # Convert a negative index
            if index < 0:
                index = size + index
            if index >= size or index < 0:
                raise IndexError('list index out of range')
            citem = deref(self._cpp_obj.get())[index]
            return citem

    def __len__(self):
        return deref(self._cpp_obj).size()

    def __richcmp__(self, other, op):
        cdef int cop = op
        if cop not in (2, 3):
            raise TypeError("unorderable types: {}, {}".format(type(self), type(other)))
        if not (isinstance(self, Iterable) and isinstance(other, Iterable)):
            return cop != 2
        if (len(self) != len(other)):
            return cop != 2

        for one, two in zip(self, other):
            if one != two:
                return cop != 2

        return cop == 2

    def __hash__(self):
        if not self.__hash:
            self.__hash = hash(tuple(self))
        return self.__hash

    def __contains__(self, item):
        if not self or item is None:
            return False
        if not isinstance(item, int):
            return False
        cdef int32_t citem = item
        cdef std_list[int32_t] vec = deref(
            self._cpp_obj.get())
        return std_libcpp.find(vec.begin(), vec.end(), citem) != vec.end()

    def __iter__(self):
        if not self:
            raise StopIteration
        cdef int32_t citem
        for citem in deref(self._cpp_obj):
            yield citem

    def __repr__(self):
        if not self:
            return 'i[]'
        return f'i[{", ".join(map(repr, self))}]'

    def __reversed__(self):
        if not self:
            raise StopIteration
        cdef int32_t citem
        cdef std_list[int32_t] vec = deref(
            self._cpp_obj.get())
        cdef std_list[int32_t].reverse_iterator loc = vec.rbegin()
        while loc != vec.rend():
            citem = deref(loc)
            yield citem
            inc(loc)

    def index(self, item, start not None=__NOTSET, stop not None=__NOTSET):
        err = ValueError(f'{item} is not in list')
        if not self or item is None:
            raise err
        offset_begin = offset_end = 0
        if stop is not __NOTSET or start is not __NOTSET:
            # Like self[start:stop].index(item)
            size = len(self)
            stop = stop if stop is not __NOTSET else size
            start = start if start is not __NOTSET else 0
            # Convert stop to a negative position.
            if stop > 0:
                stop = min(stop - size, 0)
            if stop <= -size:
                raise err  # List would be empty
            offset_end = -stop
            # Convert start to always be positive
            if start < 0:
                start = max(size + start, 0)
            if start >= size:
                raise err  # past end of list
            offset_begin = start

        if not isinstance(item, int):
            raise err
        cdef int32_t citem = item
        cdef std_list[int32_t] vec = deref(self._cpp_obj.get())
        cdef std_list[int32_t].iterator end = std_libcpp.prev(vec.end(), <int64_t>offset_end)
        cdef std_list[int32_t].iterator loc = std_libcpp.find(
            std_libcpp.next(vec.begin(), <int64_t>offset_begin),
            end,
            citem
        )
        if loc != end:
            return <int64_t> std_libcpp.distance(vec.begin(), loc)
        raise err

    def count(self, item):
        if not self or item is None:
            return 0
        if not isinstance(item, int):
            return 0
        cdef int32_t citem = item
        cdef std_list[int32_t] vec = deref(self._cpp_obj.get())
        return <int64_t> std_libcpp.count(vec.begin(), vec.end(), citem)


Sequence.register(std_list__List__i32)

cdef class std_deque__List__i32:
    def __init__(self, items=None):
        if isinstance(items, std_deque__List__i32):
            self._cpp_obj = (<std_deque__List__i32> items)._cpp_obj
        else:
            self._cpp_obj = move(std_deque__List__i32._make_instance(items))

    @staticmethod
    cdef create(shared_ptr[std_deque[int32_t]] c_items):
        inst = <std_deque__List__i32>std_deque__List__i32.__new__(std_deque__List__i32)
        inst._cpp_obj = c_items
        return inst

    @staticmethod
    cdef unique_ptr[std_deque[int32_t]] _make_instance(object items) except *:
        cdef unique_ptr[std_deque[int32_t]] c_inst = make_unique[std_deque[int32_t]]()
        if items is not None:
            for item in items:
                if not isinstance(item, int):
                    raise TypeError(f"{item!r} is not of type int")
                item = <int32_t> item
                deref(c_inst).push_back(item)
        return move_unique(c_inst)

    def __add__(object self, object other):
        return type(self)(itertools.chain(self, other))

    def __getitem__(self, object index_obj):
        cdef shared_ptr[std_deque[int32_t]] c_inst
        cdef int32_t citem
        if isinstance(index_obj, slice):
            c_inst = make_shared[std_deque[int32_t]]()
            sz = deref(self._cpp_obj).size()
            for index in range(*index_obj.indices(sz)):
                citem = deref(self._cpp_obj.get())[index]
                deref(c_inst).push_back(citem)
            return std_deque__List__i32.create(c_inst)
        else:
            index = <int?>index_obj
            size = len(self)
            # Convert a negative index
            if index < 0:
                index = size + index
            if index >= size or index < 0:
                raise IndexError('list index out of range')
            citem = deref(self._cpp_obj.get())[index]
            return citem

    def __len__(self):
        return deref(self._cpp_obj).size()

    def __richcmp__(self, other, op):
        cdef int cop = op
        if cop not in (2, 3):
            raise TypeError("unorderable types: {}, {}".format(type(self), type(other)))
        if not (isinstance(self, Iterable) and isinstance(other, Iterable)):
            return cop != 2
        if (len(self) != len(other)):
            return cop != 2

        for one, two in zip(self, other):
            if one != two:
                return cop != 2

        return cop == 2

    def __hash__(self):
        if not self.__hash:
            self.__hash = hash(tuple(self))
        return self.__hash

    def __contains__(self, item):
        if not self or item is None:
            return False
        if not isinstance(item, int):
            return False
        cdef int32_t citem = item
        cdef std_deque[int32_t] vec = deref(
            self._cpp_obj.get())
        return std_libcpp.find(vec.begin(), vec.end(), citem) != vec.end()

    def __iter__(self):
        if not self:
            raise StopIteration
        cdef int32_t citem
        for citem in deref(self._cpp_obj):
            yield citem

    def __repr__(self):
        if not self:
            return 'i[]'
        return f'i[{", ".join(map(repr, self))}]'

    def __reversed__(self):
        if not self:
            raise StopIteration
        cdef int32_t citem
        cdef std_deque[int32_t] vec = deref(
            self._cpp_obj.get())
        cdef std_deque[int32_t].reverse_iterator loc = vec.rbegin()
        while loc != vec.rend():
            citem = deref(loc)
            yield citem
            inc(loc)

    def index(self, item, start not None=__NOTSET, stop not None=__NOTSET):
        err = ValueError(f'{item} is not in list')
        if not self or item is None:
            raise err
        offset_begin = offset_end = 0
        if stop is not __NOTSET or start is not __NOTSET:
            # Like self[start:stop].index(item)
            size = len(self)
            stop = stop if stop is not __NOTSET else size
            start = start if start is not __NOTSET else 0
            # Convert stop to a negative position.
            if stop > 0:
                stop = min(stop - size, 0)
            if stop <= -size:
                raise err  # List would be empty
            offset_end = -stop
            # Convert start to always be positive
            if start < 0:
                start = max(size + start, 0)
            if start >= size:
                raise err  # past end of list
            offset_begin = start

        if not isinstance(item, int):
            raise err
        cdef int32_t citem = item
        cdef std_deque[int32_t] vec = deref(self._cpp_obj.get())
        cdef std_deque[int32_t].iterator end = std_libcpp.prev(vec.end(), <int64_t>offset_end)
        cdef std_deque[int32_t].iterator loc = std_libcpp.find(
            std_libcpp.next(vec.begin(), <int64_t>offset_begin),
            end,
            citem
        )
        if loc != end:
            return <int64_t> std_libcpp.distance(vec.begin(), loc)
        raise err

    def count(self, item):
        if not self or item is None:
            return 0
        if not isinstance(item, int):
            return 0
        cdef int32_t citem = item
        cdef std_deque[int32_t] vec = deref(self._cpp_obj.get())
        return <int64_t> std_libcpp.count(vec.begin(), vec.end(), citem)


Sequence.register(std_deque__List__i32)

cdef class folly_fbvector__List__i32:
    def __init__(self, items=None):
        if isinstance(items, folly_fbvector__List__i32):
            self._cpp_obj = (<folly_fbvector__List__i32> items)._cpp_obj
        else:
            self._cpp_obj = move(folly_fbvector__List__i32._make_instance(items))

    @staticmethod
    cdef create(shared_ptr[folly_fbvector[int32_t]] c_items):
        inst = <folly_fbvector__List__i32>folly_fbvector__List__i32.__new__(folly_fbvector__List__i32)
        inst._cpp_obj = c_items
        return inst

    @staticmethod
    cdef unique_ptr[folly_fbvector[int32_t]] _make_instance(object items) except *:
        cdef unique_ptr[folly_fbvector[int32_t]] c_inst = make_unique[folly_fbvector[int32_t]]()
        if items is not None:
            for item in items:
                if not isinstance(item, int):
                    raise TypeError(f"{item!r} is not of type int")
                item = <int32_t> item
                deref(c_inst).push_back(item)
        return move_unique(c_inst)

    def __add__(object self, object other):
        return type(self)(itertools.chain(self, other))

    def __getitem__(self, object index_obj):
        cdef shared_ptr[folly_fbvector[int32_t]] c_inst
        cdef int32_t citem
        if isinstance(index_obj, slice):
            c_inst = make_shared[folly_fbvector[int32_t]]()
            sz = deref(self._cpp_obj).size()
            for index in range(*index_obj.indices(sz)):
                citem = deref(self._cpp_obj.get())[index]
                deref(c_inst).push_back(citem)
            return folly_fbvector__List__i32.create(c_inst)
        else:
            index = <int?>index_obj
            size = len(self)
            # Convert a negative index
            if index < 0:
                index = size + index
            if index >= size or index < 0:
                raise IndexError('list index out of range')
            citem = deref(self._cpp_obj.get())[index]
            return citem

    def __len__(self):
        return deref(self._cpp_obj).size()

    def __richcmp__(self, other, op):
        cdef int cop = op
        if cop not in (2, 3):
            raise TypeError("unorderable types: {}, {}".format(type(self), type(other)))
        if not (isinstance(self, Iterable) and isinstance(other, Iterable)):
            return cop != 2
        if (len(self) != len(other)):
            return cop != 2

        for one, two in zip(self, other):
            if one != two:
                return cop != 2

        return cop == 2

    def __hash__(self):
        if not self.__hash:
            self.__hash = hash(tuple(self))
        return self.__hash

    def __contains__(self, item):
        if not self or item is None:
            return False
        if not isinstance(item, int):
            return False
        cdef int32_t citem = item
        cdef folly_fbvector[int32_t] vec = deref(
            self._cpp_obj.get())
        return std_libcpp.find(vec.begin(), vec.end(), citem) != vec.end()

    def __iter__(self):
        if not self:
            raise StopIteration
        cdef int32_t citem
        for citem in deref(self._cpp_obj):
            yield citem

    def __repr__(self):
        if not self:
            return 'i[]'
        return f'i[{", ".join(map(repr, self))}]'

    def __reversed__(self):
        if not self:
            raise StopIteration
        cdef int32_t citem
        cdef folly_fbvector[int32_t] vec = deref(
            self._cpp_obj.get())
        cdef folly_fbvector[int32_t].reverse_iterator loc = vec.rbegin()
        while loc != vec.rend():
            citem = deref(loc)
            yield citem
            inc(loc)

    def index(self, item, start not None=__NOTSET, stop not None=__NOTSET):
        err = ValueError(f'{item} is not in list')
        if not self or item is None:
            raise err
        offset_begin = offset_end = 0
        if stop is not __NOTSET or start is not __NOTSET:
            # Like self[start:stop].index(item)
            size = len(self)
            stop = stop if stop is not __NOTSET else size
            start = start if start is not __NOTSET else 0
            # Convert stop to a negative position.
            if stop > 0:
                stop = min(stop - size, 0)
            if stop <= -size:
                raise err  # List would be empty
            offset_end = -stop
            # Convert start to always be positive
            if start < 0:
                start = max(size + start, 0)
            if start >= size:
                raise err  # past end of list
            offset_begin = start

        if not isinstance(item, int):
            raise err
        cdef int32_t citem = item
        cdef folly_fbvector[int32_t] vec = deref(self._cpp_obj.get())
        cdef folly_fbvector[int32_t].iterator end = std_libcpp.prev(vec.end(), <int64_t>offset_end)
        cdef folly_fbvector[int32_t].iterator loc = std_libcpp.find(
            std_libcpp.next(vec.begin(), <int64_t>offset_begin),
            end,
            citem
        )
        if loc != end:
            return <int64_t> std_libcpp.distance(vec.begin(), loc)
        raise err

    def count(self, item):
        if not self or item is None:
            return 0
        if not isinstance(item, int):
            return 0
        cdef int32_t citem = item
        cdef folly_fbvector[int32_t] vec = deref(self._cpp_obj.get())
        return <int64_t> std_libcpp.count(vec.begin(), vec.end(), citem)


Sequence.register(folly_fbvector__List__i32)

cdef class folly_small_vector__List__i32:
    def __init__(self, items=None):
        if isinstance(items, folly_small_vector__List__i32):
            self._cpp_obj = (<folly_small_vector__List__i32> items)._cpp_obj
        else:
            self._cpp_obj = move(folly_small_vector__List__i32._make_instance(items))

    @staticmethod
    cdef create(shared_ptr[folly_small_vector[int32_t]] c_items):
        inst = <folly_small_vector__List__i32>folly_small_vector__List__i32.__new__(folly_small_vector__List__i32)
        inst._cpp_obj = c_items
        return inst

    @staticmethod
    cdef unique_ptr[folly_small_vector[int32_t]] _make_instance(object items) except *:
        cdef unique_ptr[folly_small_vector[int32_t]] c_inst = make_unique[folly_small_vector[int32_t]]()
        if items is not None:
            for item in items:
                if not isinstance(item, int):
                    raise TypeError(f"{item!r} is not of type int")
                item = <int32_t> item
                deref(c_inst).push_back(item)
        return move_unique(c_inst)

    def __add__(object self, object other):
        return type(self)(itertools.chain(self, other))

    def __getitem__(self, object index_obj):
        cdef shared_ptr[folly_small_vector[int32_t]] c_inst
        cdef int32_t citem
        if isinstance(index_obj, slice):
            c_inst = make_shared[folly_small_vector[int32_t]]()
            sz = deref(self._cpp_obj).size()
            for index in range(*index_obj.indices(sz)):
                citem = deref(self._cpp_obj.get())[index]
                deref(c_inst).push_back(citem)
            return folly_small_vector__List__i32.create(c_inst)
        else:
            index = <int?>index_obj
            size = len(self)
            # Convert a negative index
            if index < 0:
                index = size + index
            if index >= size or index < 0:
                raise IndexError('list index out of range')
            citem = deref(self._cpp_obj.get())[index]
            return citem

    def __len__(self):
        return deref(self._cpp_obj).size()

    def __richcmp__(self, other, op):
        cdef int cop = op
        if cop not in (2, 3):
            raise TypeError("unorderable types: {}, {}".format(type(self), type(other)))
        if not (isinstance(self, Iterable) and isinstance(other, Iterable)):
            return cop != 2
        if (len(self) != len(other)):
            return cop != 2

        for one, two in zip(self, other):
            if one != two:
                return cop != 2

        return cop == 2

    def __hash__(self):
        if not self.__hash:
            self.__hash = hash(tuple(self))
        return self.__hash

    def __contains__(self, item):
        if not self or item is None:
            return False
        if not isinstance(item, int):
            return False
        cdef int32_t citem = item
        cdef folly_small_vector[int32_t] vec = deref(
            self._cpp_obj.get())
        return std_libcpp.find(vec.begin(), vec.end(), citem) != vec.end()

    def __iter__(self):
        if not self:
            raise StopIteration
        cdef int32_t citem
        for citem in deref(self._cpp_obj):
            yield citem

    def __repr__(self):
        if not self:
            return 'i[]'
        return f'i[{", ".join(map(repr, self))}]'

    def __reversed__(self):
        if not self:
            raise StopIteration
        cdef int32_t citem
        cdef folly_small_vector[int32_t] vec = deref(
            self._cpp_obj.get())
        cdef folly_small_vector[int32_t].reverse_iterator loc = vec.rbegin()
        while loc != vec.rend():
            citem = deref(loc)
            yield citem
            inc(loc)

    def index(self, item, start not None=__NOTSET, stop not None=__NOTSET):
        err = ValueError(f'{item} is not in list')
        if not self or item is None:
            raise err
        offset_begin = offset_end = 0
        if stop is not __NOTSET or start is not __NOTSET:
            # Like self[start:stop].index(item)
            size = len(self)
            stop = stop if stop is not __NOTSET else size
            start = start if start is not __NOTSET else 0
            # Convert stop to a negative position.
            if stop > 0:
                stop = min(stop - size, 0)
            if stop <= -size:
                raise err  # List would be empty
            offset_end = -stop
            # Convert start to always be positive
            if start < 0:
                start = max(size + start, 0)
            if start >= size:
                raise err  # past end of list
            offset_begin = start

        if not isinstance(item, int):
            raise err
        cdef int32_t citem = item
        cdef folly_small_vector[int32_t] vec = deref(self._cpp_obj.get())
        cdef folly_small_vector[int32_t].iterator end = std_libcpp.prev(vec.end(), <int64_t>offset_end)
        cdef folly_small_vector[int32_t].iterator loc = std_libcpp.find(
            std_libcpp.next(vec.begin(), <int64_t>offset_begin),
            end,
            citem
        )
        if loc != end:
            return <int64_t> std_libcpp.distance(vec.begin(), loc)
        raise err

    def count(self, item):
        if not self or item is None:
            return 0
        if not isinstance(item, int):
            return 0
        cdef int32_t citem = item
        cdef folly_small_vector[int32_t] vec = deref(self._cpp_obj.get())
        return <int64_t> std_libcpp.count(vec.begin(), vec.end(), citem)


Sequence.register(folly_small_vector__List__i32)

cdef class folly_sorted_vector_set__Set__i32:
    def __init__(self, items=None):
        if isinstance(items, folly_sorted_vector_set__Set__i32):
            self._cpp_obj = (<folly_sorted_vector_set__Set__i32> items)._cpp_obj
        else:
            self._cpp_obj = move(folly_sorted_vector_set__Set__i32._make_instance(items))

    @staticmethod
    cdef create(shared_ptr[folly_sorted_vector_set[int32_t]] c_items):
        inst = <folly_sorted_vector_set__Set__i32>folly_sorted_vector_set__Set__i32.__new__(folly_sorted_vector_set__Set__i32)
        inst._cpp_obj = c_items
        return inst

    @staticmethod
    cdef unique_ptr[folly_sorted_vector_set[int32_t]] _make_instance(object items) except *:
        cdef unique_ptr[folly_sorted_vector_set[int32_t]] c_inst = make_unique[folly_sorted_vector_set[int32_t]]()
        if items is not None:
            for item in items:
                if not isinstance(item, int):
                    raise TypeError(f"{item!r} is not of type int")
                item = <int32_t> item
                deref(c_inst).insert(item)
        return move_unique(c_inst)

    def __contains__(self, item):
        if not self or item is None:
            return False
        if not isinstance(item, int):
            return False
        return pbool(deref(self._cpp_obj).count(item))


    def __len__(self):
        return deref(self._cpp_obj).size()

    def __iter__(self):
        if not self:
            raise StopIteration
        for citem in deref(self._cpp_obj):
            yield citem

    def __repr__(self):
        if not self:
            return 'iset()'
        return f'i{{{", ".join(map(repr, self))}}}'

    def __richcmp__(self, other, op):
        cdef int cop = op
        cdef folly_sorted_vector_set[int32_t] cself, cother
        cdef cbool retval
        if (isinstance(self, folly_sorted_vector_set__Set__i32) and
                isinstance(other, folly_sorted_vector_set__Set__i32)):
            cself = deref((<folly_sorted_vector_set__Set__i32> self)._cpp_obj)
            cother = deref((<folly_sorted_vector_set__Set__i32> other)._cpp_obj)
            # C level comparisons
            if cop == 0:    # Less Than (strict subset)
                if not cself.size() < cother.size():
                    return False
                for item in cself:
                    if not cother.count(item):
                        return False
                return True
            elif cop == 1:  # Less Than or Equal To  (subset)
                for item in cself:
                    if not cother.count(item):
                        return False
                return True
            elif cop == 2:  # Equivalent
                if cself.size() != cother.size():
                    return False
                for item in cself:
                    if not cother.count(item):
                        return False
                return True
            elif cop == 3:  # Not Equivalent
                for item in cself:
                    if not cother.count(item):
                        return True
                return cself.size() != cother.size()
            elif cop == 4:  # Greater Than (strict superset)
                if not cself.size() > cother.size():
                    return False
                for item in cother:
                    if not cself.count(item):
                        return False
                return True
            elif cop == 5:  # Greater Than or Equal To (superset)
                for item in cother:
                    if not cself.count(item):
                        return False
                return True

        # Python level comparisons
        if cop == 0:
            return Set.__lt__(self, other)
        elif cop == 1:
            return Set.__le__(self, other)
        elif cop == 2:
            return Set.__eq__(self, other)
        elif cop == 3:
            return Set.__ne__(self, other)
        elif cop == 4:
            return Set.__gt__(self, other)
        elif cop == 5:
            return Set.__ge__(self, other)

    def __hash__(self):
        if not self.__hash:
            self.__hash = hash(tuple(self))
        return self.__hash

    def __and__(self, other):
        if not isinstance(self, folly_sorted_vector_set__Set__i32):
            self = folly_sorted_vector_set__Set__i32(self)
        if not isinstance(other, folly_sorted_vector_set__Set__i32):
            other = folly_sorted_vector_set__Set__i32(other)

        cdef shared_ptr[folly_sorted_vector_set[int32_t]] shretval = \
            make_shared[folly_sorted_vector_set[int32_t]]()
        for citem in deref((<folly_sorted_vector_set__Set__i32> self)._cpp_obj):
            if deref((<folly_sorted_vector_set__Set__i32> other)._cpp_obj).count(citem) > 0:
                deref(shretval).insert(citem)
        return folly_sorted_vector_set__Set__i32.create(shretval)

    def __sub__(self, other):
        if not isinstance(self, folly_sorted_vector_set__Set__i32):
            self = folly_sorted_vector_set__Set__i32(self)
        if not isinstance(other, folly_sorted_vector_set__Set__i32):
            other = folly_sorted_vector_set__Set__i32(other)

        cdef shared_ptr[folly_sorted_vector_set[int32_t]] shretval = \
            make_shared[folly_sorted_vector_set[int32_t]]()
        for citem in deref((<folly_sorted_vector_set__Set__i32> self)._cpp_obj):
            if deref((<folly_sorted_vector_set__Set__i32> other)._cpp_obj).count(citem) == 0:
                deref(shretval).insert(citem)
        return folly_sorted_vector_set__Set__i32.create(shretval)

    def __or__(self, other):
        if not isinstance(self, folly_sorted_vector_set__Set__i32):
            self = folly_sorted_vector_set__Set__i32(self)
        if not isinstance(other, folly_sorted_vector_set__Set__i32):
            other = folly_sorted_vector_set__Set__i32(other)

        cdef shared_ptr[folly_sorted_vector_set[int32_t]] shretval = \
            make_shared[folly_sorted_vector_set[int32_t]]()
        for citem in deref((<folly_sorted_vector_set__Set__i32> self)._cpp_obj):
                deref(shretval).insert(citem)
        for citem in deref((<folly_sorted_vector_set__Set__i32> other)._cpp_obj):
                deref(shretval).insert(citem)
        return folly_sorted_vector_set__Set__i32.create(shretval)

    def __xor__(self, other):
        if not isinstance(self, folly_sorted_vector_set__Set__i32):
            self = folly_sorted_vector_set__Set__i32(self)
        if not isinstance(other, folly_sorted_vector_set__Set__i32):
            other = folly_sorted_vector_set__Set__i32(other)

        cdef shared_ptr[folly_sorted_vector_set[int32_t]] shretval = \
            make_shared[folly_sorted_vector_set[int32_t]]()
        for citem in deref((<folly_sorted_vector_set__Set__i32> self)._cpp_obj):
            if deref((<folly_sorted_vector_set__Set__i32> other)._cpp_obj).count(citem) == 0:
                deref(shretval).insert(citem)
        for citem in deref((<folly_sorted_vector_set__Set__i32> other)._cpp_obj):
            if deref((<folly_sorted_vector_set__Set__i32> self)._cpp_obj).count(citem) == 0:
                deref(shretval).insert(citem)
        return folly_sorted_vector_set__Set__i32.create(shretval)

    def isdisjoint(self, other):
        return len(self & other) == 0

    def union(self, other):
        return self | other

    def intersection(self, other):
        return self & other

    def difference(self, other):
        return self - other

    def symmetric_difference(self, other):
        return self ^ other

    def issubset(self, other):
        return self <= other

    def issuperset(self, other):
        return self >= other


Set.register(folly_sorted_vector_set__Set__i32)

cdef class folly_sorted_vector_map__Map__i32_string:
    def __init__(self, items=None):
        if isinstance(items, folly_sorted_vector_map__Map__i32_string):
            self._cpp_obj = (<folly_sorted_vector_map__Map__i32_string> items)._cpp_obj
        else:
            self._cpp_obj = move(folly_sorted_vector_map__Map__i32_string._make_instance(items))

    @staticmethod
    cdef create(shared_ptr[folly_sorted_vector_map[int32_t,string]] c_items):
        inst = <folly_sorted_vector_map__Map__i32_string>folly_sorted_vector_map__Map__i32_string.__new__(folly_sorted_vector_map__Map__i32_string)
        inst._cpp_obj = c_items
        return inst

    @staticmethod
    cdef unique_ptr[folly_sorted_vector_map[int32_t,string]] _make_instance(object items) except *:
        cdef unique_ptr[folly_sorted_vector_map[int32_t,string]] c_inst = make_unique[folly_sorted_vector_map[int32_t,string]]()
        if items is not None:
            for key, item in items.items():
                if not isinstance(key, int):
                    raise TypeError(f"{key!r} is not of type int")
                key = <int32_t> key
                if not isinstance(item, str):
                    raise TypeError(f"{item!r} is not of type str")

                deref(c_inst).insert(cpair[int32_t,string](key,item.encode('UTF-8')))
        return move_unique(c_inst)

    def __getitem__(self, key):
        err = KeyError(f'{key}')
        if not self or key is None:
            raise err
        if not isinstance(key, int):
            raise err
        cdef int32_t ckey = key
        cdef folly_sorted_vector_map[int32_t,string].iterator iter = deref(
            self._cpp_obj).find(ckey)
        if iter == deref(self._cpp_obj).end():
            raise err
        cdef string citem = deref(iter).second
        return bytes(citem).decode('UTF-8')

    def __len__(self):
        return deref(self._cpp_obj).size()

    def __iter__(self):
        if not self:
            raise StopIteration
        cdef int32_t citem
        for pair in deref(self._cpp_obj):
            citem = pair.first
            yield citem

    def __richcmp__(self, other, op):
        cdef int cop = op
        if cop not in (2, 3):
            raise TypeError("unorderable types: {}, {}".format(type(self), type(other)))
        if not (isinstance(self, Mapping) and isinstance(other, Mapping)):
            return cop != 2
        if (len(self) != len(other)):
            return cop != 2

        for key in self:
            if key not in other:
                return cop != 2
            if other[key] != self[key]:
                return cop != 2

        return cop == 2

    def __hash__(self):
        if not self.__hash:
            self.__hash = hash(tuple(self.items()))
        return self.__hash

    def __repr__(self):
        if not self:
            return 'i{}'
        return f'i{{{", ".join(map(lambda i: f"{repr(i[0])}: {repr(i[1])}", self.items()))}}}'

    def __contains__(self, key):
        if not self or key is None:
            return False
        if not isinstance(key, int):
            return False
        cdef int32_t ckey = key
        return deref(self._cpp_obj).count(ckey) > 0

    def get(self, key, default=None):
        if not self or key is None:
            return default
        try:
            if not isinstance(key, int):
                key = int(key)
        except Exception:
            return default
        if not isinstance(key, int):
            return default
        if key not in self:
            return default
        return self[key]

    def keys(self):
        return self.__iter__()

    def values(self):
        if not self:
            raise StopIteration
        cdef string citem
        for pair in deref(self._cpp_obj):
            citem = pair.second
            yield bytes(citem).decode('UTF-8')

    def items(self):
        if not self:
            raise StopIteration
        cdef int32_t ckey
        cdef string citem
        for pair in deref(self._cpp_obj):
            ckey = pair.first
            citem = pair.second

            yield (ckey, bytes(citem).decode('UTF-8'))



Mapping.register(folly_sorted_vector_map__Map__i32_string)

cdef class std_list_int32_t__List__i32:
    def __init__(self, items=None):
        if isinstance(items, std_list_int32_t__List__i32):
            self._cpp_obj = (<std_list_int32_t__List__i32> items)._cpp_obj
        else:
            self._cpp_obj = move(std_list_int32_t__List__i32._make_instance(items))

    @staticmethod
    cdef create(shared_ptr[std_list_int32_t] c_items):
        inst = <std_list_int32_t__List__i32>std_list_int32_t__List__i32.__new__(std_list_int32_t__List__i32)
        inst._cpp_obj = c_items
        return inst

    @staticmethod
    cdef unique_ptr[std_list_int32_t] _make_instance(object items) except *:
        cdef unique_ptr[std_list_int32_t] c_inst = make_unique[std_list_int32_t]()
        if items is not None:
            for item in items:
                if not isinstance(item, int):
                    raise TypeError(f"{item!r} is not of type int")
                item = <int32_t> item
                deref(c_inst).push_back(item)
        return move_unique(c_inst)

    def __add__(object self, object other):
        return type(self)(itertools.chain(self, other))

    def __getitem__(self, object index_obj):
        cdef shared_ptr[std_list_int32_t] c_inst
        cdef int32_t citem
        if isinstance(index_obj, slice):
            c_inst = make_shared[std_list_int32_t]()
            sz = deref(self._cpp_obj).size()
            for index in range(*index_obj.indices(sz)):
                citem = deref(self._cpp_obj.get())[index]
                deref(c_inst).push_back(citem)
            return std_list_int32_t__List__i32.create(c_inst)
        else:
            index = <int?>index_obj
            size = len(self)
            # Convert a negative index
            if index < 0:
                index = size + index
            if index >= size or index < 0:
                raise IndexError('list index out of range')
            citem = deref(self._cpp_obj.get())[index]
            return citem

    def __len__(self):
        return deref(self._cpp_obj).size()

    def __richcmp__(self, other, op):
        cdef int cop = op
        if cop not in (2, 3):
            raise TypeError("unorderable types: {}, {}".format(type(self), type(other)))
        if not (isinstance(self, Iterable) and isinstance(other, Iterable)):
            return cop != 2
        if (len(self) != len(other)):
            return cop != 2

        for one, two in zip(self, other):
            if one != two:
                return cop != 2

        return cop == 2

    def __hash__(self):
        if not self.__hash:
            self.__hash = hash(tuple(self))
        return self.__hash

    def __contains__(self, item):
        if not self or item is None:
            return False
        if not isinstance(item, int):
            return False
        cdef int32_t citem = item
        cdef std_list_int32_t vec = deref(
            self._cpp_obj.get())
        return std_libcpp.find(vec.begin(), vec.end(), citem) != vec.end()

    def __iter__(self):
        if not self:
            raise StopIteration
        cdef int32_t citem
        for citem in deref(self._cpp_obj):
            yield citem

    def __repr__(self):
        if not self:
            return 'i[]'
        return f'i[{", ".join(map(repr, self))}]'

    def __reversed__(self):
        if not self:
            raise StopIteration
        cdef int32_t citem
        cdef std_list_int32_t vec = deref(
            self._cpp_obj.get())
        cdef std_list_int32_t.reverse_iterator loc = vec.rbegin()
        while loc != vec.rend():
            citem = deref(loc)
            yield citem
            inc(loc)

    def index(self, item, start not None=__NOTSET, stop not None=__NOTSET):
        err = ValueError(f'{item} is not in list')
        if not self or item is None:
            raise err
        offset_begin = offset_end = 0
        if stop is not __NOTSET or start is not __NOTSET:
            # Like self[start:stop].index(item)
            size = len(self)
            stop = stop if stop is not __NOTSET else size
            start = start if start is not __NOTSET else 0
            # Convert stop to a negative position.
            if stop > 0:
                stop = min(stop - size, 0)
            if stop <= -size:
                raise err  # List would be empty
            offset_end = -stop
            # Convert start to always be positive
            if start < 0:
                start = max(size + start, 0)
            if start >= size:
                raise err  # past end of list
            offset_begin = start

        if not isinstance(item, int):
            raise err
        cdef int32_t citem = item
        cdef std_list_int32_t vec = deref(self._cpp_obj.get())
        cdef std_list_int32_t.iterator end = std_libcpp.prev(vec.end(), <int64_t>offset_end)
        cdef std_list_int32_t.iterator loc = std_libcpp.find(
            std_libcpp.next(vec.begin(), <int64_t>offset_begin),
            end,
            citem
        )
        if loc != end:
            return <int64_t> std_libcpp.distance(vec.begin(), loc)
        raise err

    def count(self, item):
        if not self or item is None:
            return 0
        if not isinstance(item, int):
            return 0
        cdef int32_t citem = item
        cdef std_list_int32_t vec = deref(self._cpp_obj.get())
        return <int64_t> std_libcpp.count(vec.begin(), vec.end(), citem)


Sequence.register(std_list_int32_t__List__i32)

