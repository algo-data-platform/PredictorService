#
# Autogenerated by Thrift
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#  @generated
#

from libcpp.memory cimport shared_ptr, make_shared, unique_ptr, make_unique
from libcpp.string cimport string
from libcpp cimport bool as cbool
from libcpp.iterator cimport inserter as cinserter
from cpython cimport bool as pbool
from libc.stdint cimport int8_t, int16_t, int32_t, int64_t, uint32_t
from cython.operator cimport dereference as deref, preincrement as inc, address as ptr_address
import thrift.py3.types
cimport thrift.py3.types
cimport thrift.py3.exceptions
from thrift.py3.types import NOTSET as __NOTSET
from thrift.py3.types cimport translate_cpp_enum_to_python
cimport thrift.py3.std_libcpp as std_libcpp
from thrift.py3.serializer import Protocol
cimport thrift.py3.serializer as serializer
from thrift.py3.serializer import deserialize, serialize
import folly.iobuf as __iobuf
from folly.optional cimport cOptional

import sys
import itertools
from collections import Sequence, Set, Mapping, Iterable
import enum as __enum
import warnings
import builtins as _builtins


class AnEnum(__enum.Enum):
    NOTSET = 0
    ONE = 1
    TWO = 2
    THREE = 3
    FOUR = 4

    __hash__ = __enum.Enum.__hash__

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            warnings.warn(f"comparison not supported between instances of {type(self)} and {type(other)}", RuntimeWarning, stacklevel=2)
            return False
        return self.value == other.value

    def __int__(self):
        return self.value

cdef inline cAnEnum AnEnum_to_cpp(value):
    cdef int cvalue = value.value
    if cvalue == 0:
        return AnEnum__NOTSET
    elif cvalue == 1:
        return AnEnum__ONE
    elif cvalue == 2:
        return AnEnum__TWO
    elif cvalue == 3:
        return AnEnum__THREE
    elif cvalue == 4:
        return AnEnum__FOUR
class Flags(__enum.Flag):
    flag_A = 1
    flag_B = 2
    flag_C = 4
    flag_D = 8

    __hash__ = __enum.Flag.__hash__

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            warnings.warn(f"comparison not supported between instances of {type(self)} and {type(other)}", RuntimeWarning, stacklevel=2)
            return False
        return self.value == other.value

    def __int__(self):
        return self.value

cdef inline cFlags Flags_to_cpp(value):
    return <cFlags>(<int>value.value)


cdef class SimpleException(thrift.py3.exceptions.Error):

    def __init__(
        SimpleException self,
        err_code=None
    ):
        if err_code is not None:
            if not isinstance(err_code, int):
                raise TypeError(f'err_code is not a { int !r}.')
            err_code = <int16_t> err_code

        self._cpp_obj = move(SimpleException._make_instance(
          NULL,
          err_code,
        ))
        _builtins.Exception.__init__(self, self.err_code)


    @staticmethod
    cdef unique_ptr[cSimpleException] _make_instance(
        cSimpleException* base_instance,
        object err_code
    ) except *:
        cdef unique_ptr[cSimpleException] c_inst
        if base_instance:
            c_inst = make_unique[cSimpleException](deref(base_instance))
        else:
            c_inst = make_unique[cSimpleException]()

        if err_code is not None:
            deref(c_inst).err_code = err_code
            deref(c_inst).__isset.err_code = True
        # in C++ you don't have to call move(), but this doesn't translate
        # into a C++ return statement, so you do here
        return move_unique(c_inst)

    def __iter__(self):
        yield 'err_code', self.err_code

    def __bool__(self):
        return True

    @staticmethod
    cdef create(shared_ptr[cSimpleException] cpp_obj):
        inst = <SimpleException>SimpleException.__new__(SimpleException, (<bytes>deref(cpp_obj).what()).decode('utf-8'))
        inst._cpp_obj = cpp_obj
        _builtins.Exception.__init__(inst, inst.err_code)
        return inst

    @property
    def err_code(self):

        return self._cpp_obj.get().err_code


    def __hash__(SimpleException self):
        return super().__hash__()

    def __repr__(SimpleException self):
        return f'SimpleException(err_code={repr(self.err_code)})'
    def __richcmp__(self, other, op):
        cdef int cop = op
        if cop not in (2, 3):
            raise TypeError("unorderable types: {}, {}".format(self, other))
        if not (
                isinstance(self, SimpleException) and
                isinstance(other, SimpleException)):
            if cop == 2:  # different types are never equal
                return False
            else:         # different types are always notequal
                return True

        cdef cSimpleException cself = deref((<SimpleException>self)._cpp_obj)
        cdef cSimpleException cother = deref((<SimpleException>other)._cpp_obj)
        cdef cbool cmp = cself == cother
        if cop == 2:
            return cmp
        return not cmp



cdef cSimpleStruct _SimpleStruct_defaults = cSimpleStruct()

cdef class SimpleStruct(thrift.py3.types.Struct):

    def __init__(
        SimpleStruct self, *,
        pbool is_on=None,
        tiny_int=None,
        small_int=None,
        nice_sized_int=None,
        big_int=None,
        real=None,
        smaller_real=None
    ):
        if tiny_int is not None:
            if not isinstance(tiny_int, int):
                raise TypeError(f'tiny_int is not a { int !r}.')
            tiny_int = <int8_t> tiny_int

        if small_int is not None:
            if not isinstance(small_int, int):
                raise TypeError(f'small_int is not a { int !r}.')
            small_int = <int16_t> small_int

        if nice_sized_int is not None:
            if not isinstance(nice_sized_int, int):
                raise TypeError(f'nice_sized_int is not a { int !r}.')
            nice_sized_int = <int32_t> nice_sized_int

        if big_int is not None:
            if not isinstance(big_int, int):
                raise TypeError(f'big_int is not a { int !r}.')
            big_int = <int64_t> big_int

        if real is not None:
            if not isinstance(real, (float, int)):
                raise TypeError(f'real is not a { float !r}.')

        if smaller_real is not None:
            if not isinstance(smaller_real, (float, int)):
                raise TypeError(f'smaller_real is not a { float !r}.')

        self._cpp_obj = move(SimpleStruct._make_instance(
          NULL,
          is_on,
          tiny_int,
          small_int,
          nice_sized_int,
          big_int,
          real,
          smaller_real,
        ))

    def __call__(
        SimpleStruct self,
        is_on=__NOTSET,
        tiny_int=__NOTSET,
        small_int=__NOTSET,
        nice_sized_int=__NOTSET,
        big_int=__NOTSET,
        real=__NOTSET,
        smaller_real=__NOTSET
    ):
        changes = any((
            is_on is not __NOTSET,

            tiny_int is not __NOTSET,

            small_int is not __NOTSET,

            nice_sized_int is not __NOTSET,

            big_int is not __NOTSET,

            real is not __NOTSET,

            smaller_real is not __NOTSET,
        ))

        if not changes:
            return self

        if None is not is_on is not __NOTSET:
            if not isinstance(is_on, bool):
                raise TypeError(f'is_on is not a { bool !r}.')

        if None is not tiny_int is not __NOTSET:
            if not isinstance(tiny_int, int):
                raise TypeError(f'tiny_int is not a { int !r}.')
            tiny_int = <int8_t> tiny_int

        if None is not small_int is not __NOTSET:
            if not isinstance(small_int, int):
                raise TypeError(f'small_int is not a { int !r}.')
            small_int = <int16_t> small_int

        if None is not nice_sized_int is not __NOTSET:
            if not isinstance(nice_sized_int, int):
                raise TypeError(f'nice_sized_int is not a { int !r}.')
            nice_sized_int = <int32_t> nice_sized_int

        if None is not big_int is not __NOTSET:
            if not isinstance(big_int, int):
                raise TypeError(f'big_int is not a { int !r}.')
            big_int = <int64_t> big_int

        if None is not real is not __NOTSET:
            if not isinstance(real, (float, int)):
                raise TypeError(f'real is not a { float !r}.')

        if None is not smaller_real is not __NOTSET:
            if not isinstance(smaller_real, (float, int)):
                raise TypeError(f'smaller_real is not a { float !r}.')

        inst = <SimpleStruct>SimpleStruct.__new__(SimpleStruct)
        inst._cpp_obj = move(SimpleStruct._make_instance(
          self._cpp_obj.get(),
          is_on,
          tiny_int,
          small_int,
          nice_sized_int,
          big_int,
          real,
          smaller_real,
        ))
        return inst

    @staticmethod
    cdef unique_ptr[cSimpleStruct] _make_instance(
        cSimpleStruct* base_instance,
        object is_on,
        object tiny_int,
        object small_int,
        object nice_sized_int,
        object big_int,
        object real,
        object smaller_real
    ) except *:
        cdef unique_ptr[cSimpleStruct] c_inst
        if base_instance:
            c_inst = make_unique[cSimpleStruct](deref(base_instance))
        else:
            c_inst = make_unique[cSimpleStruct]()

        if base_instance:
            # Convert None's to default value. (or unset)
            if is_on is None:
                deref(c_inst).is_on = _SimpleStruct_defaults.is_on
                deref(c_inst).__isset.is_on = False
                pass
            elif is_on is __NOTSET:
                is_on = None

            if tiny_int is None:
                deref(c_inst).tiny_int = _SimpleStruct_defaults.tiny_int
                deref(c_inst).__isset.tiny_int = False
                pass
            elif tiny_int is __NOTSET:
                tiny_int = None

            if small_int is None:
                deref(c_inst).small_int = _SimpleStruct_defaults.small_int
                deref(c_inst).__isset.small_int = False
                pass
            elif small_int is __NOTSET:
                small_int = None

            if nice_sized_int is None:
                deref(c_inst).nice_sized_int = _SimpleStruct_defaults.nice_sized_int
                deref(c_inst).__isset.nice_sized_int = False
                pass
            elif nice_sized_int is __NOTSET:
                nice_sized_int = None

            if big_int is None:
                deref(c_inst).big_int = _SimpleStruct_defaults.big_int
                deref(c_inst).__isset.big_int = False
                pass
            elif big_int is __NOTSET:
                big_int = None

            if real is None:
                deref(c_inst).real = _SimpleStruct_defaults.real
                deref(c_inst).__isset.real = False
                pass
            elif real is __NOTSET:
                real = None

            if smaller_real is None:
                deref(c_inst).smaller_real = _SimpleStruct_defaults.smaller_real
                deref(c_inst).__isset.smaller_real = False
                pass
            elif smaller_real is __NOTSET:
                smaller_real = None

        if is_on is not None:
            deref(c_inst).is_on = is_on
            deref(c_inst).__isset.is_on = True
        if tiny_int is not None:
            deref(c_inst).tiny_int = tiny_int
            deref(c_inst).__isset.tiny_int = True
        if small_int is not None:
            deref(c_inst).small_int = small_int
            deref(c_inst).__isset.small_int = True
        if nice_sized_int is not None:
            deref(c_inst).nice_sized_int = nice_sized_int
            deref(c_inst).__isset.nice_sized_int = True
        if big_int is not None:
            deref(c_inst).big_int = big_int
            deref(c_inst).__isset.big_int = True
        if real is not None:
            deref(c_inst).real = real
            deref(c_inst).__isset.real = True
        if smaller_real is not None:
            deref(c_inst).smaller_real = smaller_real
            deref(c_inst).__isset.smaller_real = True
        # in C++ you don't have to call move(), but this doesn't translate
        # into a C++ return statement, so you do here
        return move_unique(c_inst)

    def __iter__(self):
        yield 'is_on', self.is_on
        yield 'tiny_int', self.tiny_int
        yield 'small_int', self.small_int
        yield 'nice_sized_int', self.nice_sized_int
        yield 'big_int', self.big_int
        yield 'real', self.real
        yield 'smaller_real', self.smaller_real

    def __bool__(self):
        return True or True or True or True or True or True or True

    @staticmethod
    cdef create(shared_ptr[cSimpleStruct] cpp_obj):
        inst = <SimpleStruct>SimpleStruct.__new__(SimpleStruct)
        inst._cpp_obj = cpp_obj
        return inst

    @property
    def is_on(self):

        return <pbool> self._cpp_obj.get().is_on

    @property
    def tiny_int(self):

        return self._cpp_obj.get().tiny_int

    @property
    def small_int(self):

        return self._cpp_obj.get().small_int

    @property
    def nice_sized_int(self):

        return self._cpp_obj.get().nice_sized_int

    @property
    def big_int(self):

        return self._cpp_obj.get().big_int

    @property
    def real(self):

        return self._cpp_obj.get().real

    @property
    def smaller_real(self):

        return self._cpp_obj.get().smaller_real


    def __hash__(SimpleStruct self):
        if not self.__hash:
            self.__hash = hash((
            self.is_on,
            self.tiny_int,
            self.small_int,
            self.nice_sized_int,
            self.big_int,
            self.real,
            self.smaller_real,
            ))
        return self.__hash

    def __repr__(SimpleStruct self):
        return f'SimpleStruct(is_on={repr(self.is_on)}, tiny_int={repr(self.tiny_int)}, small_int={repr(self.small_int)}, nice_sized_int={repr(self.nice_sized_int)}, big_int={repr(self.big_int)}, real={repr(self.real)}, smaller_real={repr(self.smaller_real)})'
    def __richcmp__(self, other, op):
        cdef int cop = op
        if cop not in (2, 3):
            raise TypeError("unorderable types: {}, {}".format(self, other))
        if not (
                isinstance(self, SimpleStruct) and
                isinstance(other, SimpleStruct)):
            if cop == 2:  # different types are never equal
                return False
            else:         # different types are always notequal
                return True

        cdef cSimpleStruct cself = deref((<SimpleStruct>self)._cpp_obj)
        cdef cSimpleStruct cother = deref((<SimpleStruct>other)._cpp_obj)
        cdef cbool cmp = cself == cother
        if cop == 2:
            return cmp
        return not cmp

    cdef __iobuf.IOBuf _serialize(SimpleStruct self, proto):
        cdef __iobuf.cIOBufQueue queue = __iobuf.cIOBufQueue(__iobuf.cacheChainLength())
        cdef cSimpleStruct* cpp_obj = self._cpp_obj.get()
        if proto is Protocol.COMPACT:
            with nogil:
                serializer.CompactSerialize[cSimpleStruct](deref(cpp_obj), &queue, serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is Protocol.BINARY:
            with nogil:
                serializer.BinarySerialize[cSimpleStruct](deref(cpp_obj), &queue, serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is Protocol.JSON:
            with nogil:
                serializer.JSONSerialize[cSimpleStruct](deref(cpp_obj), &queue, serializer.SHARE_EXTERNAL_BUFFER)
        return __iobuf.from_unique_ptr(queue.move())

    cdef uint32_t _deserialize(SimpleStruct self, const __iobuf.cIOBuf* buf, proto) except? 0:
        cdef uint32_t needed
        self._cpp_obj = make_shared[cSimpleStruct]()
        cdef cSimpleStruct* cpp_obj = self._cpp_obj.get()
        if proto is Protocol.COMPACT:
            with nogil:
                needed = serializer.CompactDeserialize[cSimpleStruct](buf, deref(cpp_obj), serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is Protocol.BINARY:
            with nogil:
                needed = serializer.BinaryDeserialize[cSimpleStruct](buf, deref(cpp_obj), serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is Protocol.JSON:
            with nogil:
                needed = serializer.JSONDeserialize[cSimpleStruct](buf, deref(cpp_obj), serializer.SHARE_EXTERNAL_BUFFER)
        return needed

    def __reduce__(self):
        return (deserialize, (SimpleStruct, serialize(self)))


cdef cComplexStruct _ComplexStruct_defaults = cComplexStruct()

cdef class ComplexStruct(thrift.py3.types.Struct):

    def __init__(
        ComplexStruct self, *,
        SimpleStruct structOne=None,
        SimpleStruct structTwo=None,
        an_integer=None,
        str name=None,
        an_enum=None,
        bytes some_bytes=None,
        str sender=None,
        str cdef_=None
    ):
        if an_integer is not None:
            if not isinstance(an_integer, int):
                raise TypeError(f'an_integer is not a { int !r}.')
            an_integer = <int32_t> an_integer

        if an_enum is not None:
            if not isinstance(an_enum, AnEnum):
                raise TypeError(f'field an_enum value: { an_enum !r} is not of the enum type { AnEnum }.')

        self._cpp_obj = move(ComplexStruct._make_instance(
          NULL,
          structOne,
          structTwo,
          an_integer,
          name,
          an_enum,
          some_bytes,
          sender,
          cdef_,
        ))

    def __call__(
        ComplexStruct self,
        structOne=__NOTSET,
        structTwo=__NOTSET,
        an_integer=__NOTSET,
        name=__NOTSET,
        an_enum=__NOTSET,
        some_bytes=__NOTSET,
        sender=__NOTSET,
        cdef_=__NOTSET
    ):
        changes = any((
            structOne is not __NOTSET,

            structTwo is not __NOTSET,

            an_integer is not __NOTSET,

            name is not __NOTSET,

            an_enum is not __NOTSET,

            some_bytes is not __NOTSET,

            sender is not __NOTSET,

            cdef_ is not __NOTSET,
        ))

        if not changes:
            return self

        if None is not structOne is not __NOTSET:
            if not isinstance(structOne, SimpleStruct):
                raise TypeError(f'structOne is not a { SimpleStruct !r}.')

        if None is not structTwo is not __NOTSET:
            if not isinstance(structTwo, SimpleStruct):
                raise TypeError(f'structTwo is not a { SimpleStruct !r}.')

        if None is not an_integer is not __NOTSET:
            if not isinstance(an_integer, int):
                raise TypeError(f'an_integer is not a { int !r}.')
            an_integer = <int32_t> an_integer

        if None is not name is not __NOTSET:
            if not isinstance(name, str):
                raise TypeError(f'name is not a { str !r}.')

        if None is not an_enum is not __NOTSET:
            if not isinstance(an_enum, AnEnum):
                raise TypeError(f'field an_enum value: { an_enum !r} is not of the enum type { AnEnum }.')

        if None is not some_bytes is not __NOTSET:
            if not isinstance(some_bytes, bytes):
                raise TypeError(f'some_bytes is not a { bytes !r}.')

        if None is not sender is not __NOTSET:
            if not isinstance(sender, str):
                raise TypeError(f'sender is not a { str !r}.')

        if None is not cdef_ is not __NOTSET:
            if not isinstance(cdef_, str):
                raise TypeError(f'cdef_ is not a { str !r}.')

        inst = <ComplexStruct>ComplexStruct.__new__(ComplexStruct)
        inst._cpp_obj = move(ComplexStruct._make_instance(
          self._cpp_obj.get(),
          structOne,
          structTwo,
          an_integer,
          name,
          an_enum,
          some_bytes,
          sender,
          cdef_,
        ))
        return inst

    @staticmethod
    cdef unique_ptr[cComplexStruct] _make_instance(
        cComplexStruct* base_instance,
        object structOne,
        object structTwo,
        object an_integer,
        object name,
        object an_enum,
        object some_bytes,
        object sender,
        object cdef_
    ) except *:
        cdef unique_ptr[cComplexStruct] c_inst
        if base_instance:
            c_inst = make_unique[cComplexStruct](deref(base_instance))
        else:
            c_inst = make_unique[cComplexStruct]()

        if base_instance:
            # Convert None's to default value. (or unset)
            if structOne is None:
                deref(c_inst).structOne = _ComplexStruct_defaults.structOne
                deref(c_inst).__isset.structOne = False
                pass
            elif structOne is __NOTSET:
                structOne = None

            if structTwo is None:
                deref(c_inst).structTwo = _ComplexStruct_defaults.structTwo
                deref(c_inst).__isset.structTwo = False
                pass
            elif structTwo is __NOTSET:
                structTwo = None

            if an_integer is None:
                deref(c_inst).an_integer = _ComplexStruct_defaults.an_integer
                deref(c_inst).__isset.an_integer = False
                pass
            elif an_integer is __NOTSET:
                an_integer = None

            if name is None:
                deref(c_inst).name = _ComplexStruct_defaults.name
                deref(c_inst).__isset.name = False
                pass
            elif name is __NOTSET:
                name = None

            if an_enum is None:
                deref(c_inst).an_enum = _ComplexStruct_defaults.an_enum
                deref(c_inst).__isset.an_enum = False
                pass
            elif an_enum is __NOTSET:
                an_enum = None

            if some_bytes is None:
                deref(c_inst).some_bytes = _ComplexStruct_defaults.some_bytes
                deref(c_inst).__isset.some_bytes = False
                pass
            elif some_bytes is __NOTSET:
                some_bytes = None

            if sender is None:
                deref(c_inst).sender = _ComplexStruct_defaults.sender
                deref(c_inst).__isset.sender = False
                pass
            elif sender is __NOTSET:
                sender = None

            if cdef_ is None:
                deref(c_inst).cdef_ = _ComplexStruct_defaults.cdef_
                deref(c_inst).__isset.cdef_ = False
                pass
            elif cdef_ is __NOTSET:
                cdef_ = None

        if structOne is not None:
            deref(c_inst).structOne = deref((<SimpleStruct?> structOne)._cpp_obj)
            deref(c_inst).__isset.structOne = True
        if structTwo is not None:
            deref(c_inst).structTwo = deref((<SimpleStruct?> structTwo)._cpp_obj)
            deref(c_inst).__isset.structTwo = True
        if an_integer is not None:
            deref(c_inst).an_integer = an_integer
            deref(c_inst).__isset.an_integer = True
        if name is not None:
            deref(c_inst).name = name.encode('UTF-8')
            deref(c_inst).__isset.name = True
        if an_enum is not None:
            deref(c_inst).an_enum = AnEnum_to_cpp(an_enum)
            deref(c_inst).__isset.an_enum = True
        if some_bytes is not None:
            deref(c_inst).some_bytes = some_bytes
            deref(c_inst).__isset.some_bytes = True
        if sender is not None:
            deref(c_inst).sender = sender.encode('UTF-8')
            deref(c_inst).__isset.sender = True
        if cdef_ is not None:
            deref(c_inst).cdef_ = cdef_.encode('UTF-8')
            deref(c_inst).__isset.cdef_ = True
        # in C++ you don't have to call move(), but this doesn't translate
        # into a C++ return statement, so you do here
        return move_unique(c_inst)

    def __iter__(self):
        yield 'structOne', self.structOne
        yield 'structTwo', self.structTwo
        yield 'an_integer', self.an_integer
        yield 'name', self.name
        yield 'an_enum', self.an_enum
        yield 'some_bytes', self.some_bytes
        yield 'sender', self.sender
        yield 'cdef_', self.cdef_

    def __bool__(self):
        return True or True or True or True or True or True or True or True

    @staticmethod
    cdef create(shared_ptr[cComplexStruct] cpp_obj):
        inst = <ComplexStruct>ComplexStruct.__new__(ComplexStruct)
        inst._cpp_obj = cpp_obj
        return inst

    @property
    def structOne(self):

        if self.__structOne is None:
            self.__structOne = SimpleStruct.create(make_shared[cSimpleStruct](deref(self._cpp_obj).structOne))
        return self.__structOne

    @property
    def structTwo(self):

        if self.__structTwo is None:
            self.__structTwo = SimpleStruct.create(make_shared[cSimpleStruct](deref(self._cpp_obj).structTwo))
        return self.__structTwo

    @property
    def an_integer(self):

        return self._cpp_obj.get().an_integer

    @property
    def name(self):

        return (<bytes>self._cpp_obj.get().name).decode('UTF-8')

    @property
    def an_enum(self):

        return translate_cpp_enum_to_python(AnEnum, <int>(deref(self._cpp_obj).an_enum))

    @property
    def some_bytes(self):

        return self._cpp_obj.get().some_bytes

    @property
    def sender(self):

        return (<bytes>self._cpp_obj.get().sender).decode('UTF-8')

    @property
    def cdef_(self):

        return (<bytes>self._cpp_obj.get().cdef_).decode('UTF-8')


    def __hash__(ComplexStruct self):
        if not self.__hash:
            self.__hash = hash((
            self.structOne,
            self.structTwo,
            self.an_integer,
            self.name,
            self.an_enum,
            self.some_bytes,
            self.sender,
            self.cdef_,
            ))
        return self.__hash

    def __repr__(ComplexStruct self):
        return f'ComplexStruct(structOne={repr(self.structOne)}, structTwo={repr(self.structTwo)}, an_integer={repr(self.an_integer)}, name={repr(self.name)}, an_enum={repr(self.an_enum)}, some_bytes={repr(self.some_bytes)}, sender={repr(self.sender)}, cdef_={repr(self.cdef_)})'
    def __richcmp__(self, other, op):
        cdef int cop = op
        if cop not in (2, 3):
            raise TypeError("unorderable types: {}, {}".format(self, other))
        if not (
                isinstance(self, ComplexStruct) and
                isinstance(other, ComplexStruct)):
            if cop == 2:  # different types are never equal
                return False
            else:         # different types are always notequal
                return True

        cdef cComplexStruct cself = deref((<ComplexStruct>self)._cpp_obj)
        cdef cComplexStruct cother = deref((<ComplexStruct>other)._cpp_obj)
        cdef cbool cmp = cself == cother
        if cop == 2:
            return cmp
        return not cmp

    cdef __iobuf.IOBuf _serialize(ComplexStruct self, proto):
        cdef __iobuf.cIOBufQueue queue = __iobuf.cIOBufQueue(__iobuf.cacheChainLength())
        cdef cComplexStruct* cpp_obj = self._cpp_obj.get()
        if proto is Protocol.COMPACT:
            with nogil:
                serializer.CompactSerialize[cComplexStruct](deref(cpp_obj), &queue, serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is Protocol.BINARY:
            with nogil:
                serializer.BinarySerialize[cComplexStruct](deref(cpp_obj), &queue, serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is Protocol.JSON:
            with nogil:
                serializer.JSONSerialize[cComplexStruct](deref(cpp_obj), &queue, serializer.SHARE_EXTERNAL_BUFFER)
        return __iobuf.from_unique_ptr(queue.move())

    cdef uint32_t _deserialize(ComplexStruct self, const __iobuf.cIOBuf* buf, proto) except? 0:
        cdef uint32_t needed
        self._cpp_obj = make_shared[cComplexStruct]()
        cdef cComplexStruct* cpp_obj = self._cpp_obj.get()
        if proto is Protocol.COMPACT:
            with nogil:
                needed = serializer.CompactDeserialize[cComplexStruct](buf, deref(cpp_obj), serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is Protocol.BINARY:
            with nogil:
                needed = serializer.BinaryDeserialize[cComplexStruct](buf, deref(cpp_obj), serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is Protocol.JSON:
            with nogil:
                needed = serializer.JSONDeserialize[cComplexStruct](buf, deref(cpp_obj), serializer.SHARE_EXTERNAL_BUFFER)
        return needed

    def __reduce__(self):
        return (deserialize, (ComplexStruct, serialize(self)))


cdef class List__i16:
    def __init__(self, items=None):
        if isinstance(items, List__i16):
            self._cpp_obj = (<List__i16> items)._cpp_obj
        else:
            self._cpp_obj = move(List__i16._make_instance(items))

    @staticmethod
    cdef create(shared_ptr[vector[int16_t]] c_items):
        inst = <List__i16>List__i16.__new__(List__i16)
        inst._cpp_obj = c_items
        return inst

    @staticmethod
    cdef unique_ptr[vector[int16_t]] _make_instance(object items) except *:
        cdef unique_ptr[vector[int16_t]] c_inst = make_unique[vector[int16_t]]()
        if items is not None:
            for item in items:
                if not isinstance(item, int):
                    raise TypeError(f"{item!r} is not of type int")
                item = <int16_t> item
                deref(c_inst).push_back(item)
        return move_unique(c_inst)

    def __add__(object self, object other):
        return type(self)(itertools.chain(self, other))

    def __getitem__(self, object index_obj):
        cdef shared_ptr[vector[int16_t]] c_inst
        cdef int16_t citem
        if isinstance(index_obj, slice):
            c_inst = make_shared[vector[int16_t]]()
            sz = deref(self._cpp_obj).size()
            for index in range(*index_obj.indices(sz)):
                citem = deref(self._cpp_obj.get())[index]
                deref(c_inst).push_back(citem)
            return List__i16.create(c_inst)
        else:
            index = <int?>index_obj
            size = len(self)
            # Convert a negative index
            if index < 0:
                index = size + index
            if index >= size or index < 0:
                raise IndexError('list index out of range')
            citem = deref(self._cpp_obj.get())[index]
            return citem

    def __len__(self):
        return deref(self._cpp_obj).size()

    def __richcmp__(self, other, op):
        cdef int cop = op
        if cop not in (2, 3):
            raise TypeError("unorderable types: {}, {}".format(type(self), type(other)))
        if not (isinstance(self, Iterable) and isinstance(other, Iterable)):
            return cop != 2
        if (len(self) != len(other)):
            return cop != 2

        for one, two in zip(self, other):
            if one != two:
                return cop != 2

        return cop == 2

    def __hash__(self):
        if not self.__hash:
            self.__hash = hash(tuple(self))
        return self.__hash

    def __contains__(self, item):
        if not self or item is None:
            return False
        if not isinstance(item, int):
            return False
        cdef int16_t citem = item
        cdef vector[int16_t] vec = deref(
            self._cpp_obj.get())
        return std_libcpp.find(vec.begin(), vec.end(), citem) != vec.end()

    def __iter__(self):
        if not self:
            raise StopIteration
        cdef int16_t citem
        for citem in deref(self._cpp_obj):
            yield citem

    def __repr__(self):
        if not self:
            return 'i[]'
        return f'i[{", ".join(map(repr, self))}]'

    def __reversed__(self):
        if not self:
            raise StopIteration
        cdef int16_t citem
        cdef vector[int16_t] vec = deref(
            self._cpp_obj.get())
        cdef vector[int16_t].reverse_iterator loc = vec.rbegin()
        while loc != vec.rend():
            citem = deref(loc)
            yield citem
            inc(loc)

    def index(self, item, start not None=__NOTSET, stop not None=__NOTSET):
        err = ValueError(f'{item} is not in list')
        if not self or item is None:
            raise err
        offset_begin = offset_end = 0
        if stop is not __NOTSET or start is not __NOTSET:
            # Like self[start:stop].index(item)
            size = len(self)
            stop = stop if stop is not __NOTSET else size
            start = start if start is not __NOTSET else 0
            # Convert stop to a negative position.
            if stop > 0:
                stop = min(stop - size, 0)
            if stop <= -size:
                raise err  # List would be empty
            offset_end = -stop
            # Convert start to always be positive
            if start < 0:
                start = max(size + start, 0)
            if start >= size:
                raise err  # past end of list
            offset_begin = start

        if not isinstance(item, int):
            raise err
        cdef int16_t citem = item
        cdef vector[int16_t] vec = deref(self._cpp_obj.get())
        cdef vector[int16_t].iterator end = std_libcpp.prev(vec.end(), <int64_t>offset_end)
        cdef vector[int16_t].iterator loc = std_libcpp.find(
            std_libcpp.next(vec.begin(), <int64_t>offset_begin),
            end,
            citem
        )
        if loc != end:
            return <int64_t> std_libcpp.distance(vec.begin(), loc)
        raise err

    def count(self, item):
        if not self or item is None:
            return 0
        if not isinstance(item, int):
            return 0
        cdef int16_t citem = item
        cdef vector[int16_t] vec = deref(self._cpp_obj.get())
        return <int64_t> std_libcpp.count(vec.begin(), vec.end(), citem)


Sequence.register(List__i16)

cdef class List__i32:
    def __init__(self, items=None):
        if isinstance(items, List__i32):
            self._cpp_obj = (<List__i32> items)._cpp_obj
        else:
            self._cpp_obj = move(List__i32._make_instance(items))

    @staticmethod
    cdef create(shared_ptr[vector[int32_t]] c_items):
        inst = <List__i32>List__i32.__new__(List__i32)
        inst._cpp_obj = c_items
        return inst

    @staticmethod
    cdef unique_ptr[vector[int32_t]] _make_instance(object items) except *:
        cdef unique_ptr[vector[int32_t]] c_inst = make_unique[vector[int32_t]]()
        if items is not None:
            for item in items:
                if not isinstance(item, int):
                    raise TypeError(f"{item!r} is not of type int")
                item = <int32_t> item
                deref(c_inst).push_back(item)
        return move_unique(c_inst)

    def __add__(object self, object other):
        return type(self)(itertools.chain(self, other))

    def __getitem__(self, object index_obj):
        cdef shared_ptr[vector[int32_t]] c_inst
        cdef int32_t citem
        if isinstance(index_obj, slice):
            c_inst = make_shared[vector[int32_t]]()
            sz = deref(self._cpp_obj).size()
            for index in range(*index_obj.indices(sz)):
                citem = deref(self._cpp_obj.get())[index]
                deref(c_inst).push_back(citem)
            return List__i32.create(c_inst)
        else:
            index = <int?>index_obj
            size = len(self)
            # Convert a negative index
            if index < 0:
                index = size + index
            if index >= size or index < 0:
                raise IndexError('list index out of range')
            citem = deref(self._cpp_obj.get())[index]
            return citem

    def __len__(self):
        return deref(self._cpp_obj).size()

    def __richcmp__(self, other, op):
        cdef int cop = op
        if cop not in (2, 3):
            raise TypeError("unorderable types: {}, {}".format(type(self), type(other)))
        if not (isinstance(self, Iterable) and isinstance(other, Iterable)):
            return cop != 2
        if (len(self) != len(other)):
            return cop != 2

        for one, two in zip(self, other):
            if one != two:
                return cop != 2

        return cop == 2

    def __hash__(self):
        if not self.__hash:
            self.__hash = hash(tuple(self))
        return self.__hash

    def __contains__(self, item):
        if not self or item is None:
            return False
        if not isinstance(item, int):
            return False
        cdef int32_t citem = item
        cdef vector[int32_t] vec = deref(
            self._cpp_obj.get())
        return std_libcpp.find(vec.begin(), vec.end(), citem) != vec.end()

    def __iter__(self):
        if not self:
            raise StopIteration
        cdef int32_t citem
        for citem in deref(self._cpp_obj):
            yield citem

    def __repr__(self):
        if not self:
            return 'i[]'
        return f'i[{", ".join(map(repr, self))}]'

    def __reversed__(self):
        if not self:
            raise StopIteration
        cdef int32_t citem
        cdef vector[int32_t] vec = deref(
            self._cpp_obj.get())
        cdef vector[int32_t].reverse_iterator loc = vec.rbegin()
        while loc != vec.rend():
            citem = deref(loc)
            yield citem
            inc(loc)

    def index(self, item, start not None=__NOTSET, stop not None=__NOTSET):
        err = ValueError(f'{item} is not in list')
        if not self or item is None:
            raise err
        offset_begin = offset_end = 0
        if stop is not __NOTSET or start is not __NOTSET:
            # Like self[start:stop].index(item)
            size = len(self)
            stop = stop if stop is not __NOTSET else size
            start = start if start is not __NOTSET else 0
            # Convert stop to a negative position.
            if stop > 0:
                stop = min(stop - size, 0)
            if stop <= -size:
                raise err  # List would be empty
            offset_end = -stop
            # Convert start to always be positive
            if start < 0:
                start = max(size + start, 0)
            if start >= size:
                raise err  # past end of list
            offset_begin = start

        if not isinstance(item, int):
            raise err
        cdef int32_t citem = item
        cdef vector[int32_t] vec = deref(self._cpp_obj.get())
        cdef vector[int32_t].iterator end = std_libcpp.prev(vec.end(), <int64_t>offset_end)
        cdef vector[int32_t].iterator loc = std_libcpp.find(
            std_libcpp.next(vec.begin(), <int64_t>offset_begin),
            end,
            citem
        )
        if loc != end:
            return <int64_t> std_libcpp.distance(vec.begin(), loc)
        raise err

    def count(self, item):
        if not self or item is None:
            return 0
        if not isinstance(item, int):
            return 0
        cdef int32_t citem = item
        cdef vector[int32_t] vec = deref(self._cpp_obj.get())
        return <int64_t> std_libcpp.count(vec.begin(), vec.end(), citem)


Sequence.register(List__i32)

cdef class List__i64:
    def __init__(self, items=None):
        if isinstance(items, List__i64):
            self._cpp_obj = (<List__i64> items)._cpp_obj
        else:
            self._cpp_obj = move(List__i64._make_instance(items))

    @staticmethod
    cdef create(shared_ptr[vector[int64_t]] c_items):
        inst = <List__i64>List__i64.__new__(List__i64)
        inst._cpp_obj = c_items
        return inst

    @staticmethod
    cdef unique_ptr[vector[int64_t]] _make_instance(object items) except *:
        cdef unique_ptr[vector[int64_t]] c_inst = make_unique[vector[int64_t]]()
        if items is not None:
            for item in items:
                if not isinstance(item, int):
                    raise TypeError(f"{item!r} is not of type int")
                item = <int64_t> item
                deref(c_inst).push_back(item)
        return move_unique(c_inst)

    def __add__(object self, object other):
        return type(self)(itertools.chain(self, other))

    def __getitem__(self, object index_obj):
        cdef shared_ptr[vector[int64_t]] c_inst
        cdef int64_t citem
        if isinstance(index_obj, slice):
            c_inst = make_shared[vector[int64_t]]()
            sz = deref(self._cpp_obj).size()
            for index in range(*index_obj.indices(sz)):
                citem = deref(self._cpp_obj.get())[index]
                deref(c_inst).push_back(citem)
            return List__i64.create(c_inst)
        else:
            index = <int?>index_obj
            size = len(self)
            # Convert a negative index
            if index < 0:
                index = size + index
            if index >= size or index < 0:
                raise IndexError('list index out of range')
            citem = deref(self._cpp_obj.get())[index]
            return citem

    def __len__(self):
        return deref(self._cpp_obj).size()

    def __richcmp__(self, other, op):
        cdef int cop = op
        if cop not in (2, 3):
            raise TypeError("unorderable types: {}, {}".format(type(self), type(other)))
        if not (isinstance(self, Iterable) and isinstance(other, Iterable)):
            return cop != 2
        if (len(self) != len(other)):
            return cop != 2

        for one, two in zip(self, other):
            if one != two:
                return cop != 2

        return cop == 2

    def __hash__(self):
        if not self.__hash:
            self.__hash = hash(tuple(self))
        return self.__hash

    def __contains__(self, item):
        if not self or item is None:
            return False
        if not isinstance(item, int):
            return False
        cdef int64_t citem = item
        cdef vector[int64_t] vec = deref(
            self._cpp_obj.get())
        return std_libcpp.find(vec.begin(), vec.end(), citem) != vec.end()

    def __iter__(self):
        if not self:
            raise StopIteration
        cdef int64_t citem
        for citem in deref(self._cpp_obj):
            yield citem

    def __repr__(self):
        if not self:
            return 'i[]'
        return f'i[{", ".join(map(repr, self))}]'

    def __reversed__(self):
        if not self:
            raise StopIteration
        cdef int64_t citem
        cdef vector[int64_t] vec = deref(
            self._cpp_obj.get())
        cdef vector[int64_t].reverse_iterator loc = vec.rbegin()
        while loc != vec.rend():
            citem = deref(loc)
            yield citem
            inc(loc)

    def index(self, item, start not None=__NOTSET, stop not None=__NOTSET):
        err = ValueError(f'{item} is not in list')
        if not self or item is None:
            raise err
        offset_begin = offset_end = 0
        if stop is not __NOTSET or start is not __NOTSET:
            # Like self[start:stop].index(item)
            size = len(self)
            stop = stop if stop is not __NOTSET else size
            start = start if start is not __NOTSET else 0
            # Convert stop to a negative position.
            if stop > 0:
                stop = min(stop - size, 0)
            if stop <= -size:
                raise err  # List would be empty
            offset_end = -stop
            # Convert start to always be positive
            if start < 0:
                start = max(size + start, 0)
            if start >= size:
                raise err  # past end of list
            offset_begin = start

        if not isinstance(item, int):
            raise err
        cdef int64_t citem = item
        cdef vector[int64_t] vec = deref(self._cpp_obj.get())
        cdef vector[int64_t].iterator end = std_libcpp.prev(vec.end(), <int64_t>offset_end)
        cdef vector[int64_t].iterator loc = std_libcpp.find(
            std_libcpp.next(vec.begin(), <int64_t>offset_begin),
            end,
            citem
        )
        if loc != end:
            return <int64_t> std_libcpp.distance(vec.begin(), loc)
        raise err

    def count(self, item):
        if not self or item is None:
            return 0
        if not isinstance(item, int):
            return 0
        cdef int64_t citem = item
        cdef vector[int64_t] vec = deref(self._cpp_obj.get())
        return <int64_t> std_libcpp.count(vec.begin(), vec.end(), citem)


Sequence.register(List__i64)

cdef class List__string:
    def __init__(self, items=None):
        if isinstance(items, List__string):
            self._cpp_obj = (<List__string> items)._cpp_obj
        else:
            self._cpp_obj = move(List__string._make_instance(items))

    @staticmethod
    cdef create(shared_ptr[vector[string]] c_items):
        inst = <List__string>List__string.__new__(List__string)
        inst._cpp_obj = c_items
        return inst

    @staticmethod
    cdef unique_ptr[vector[string]] _make_instance(object items) except *:
        cdef unique_ptr[vector[string]] c_inst = make_unique[vector[string]]()
        if items is not None:
            for item in items:
                if not isinstance(item, str):
                    raise TypeError(f"{item!r} is not of type str")
                deref(c_inst).push_back(item.encode('UTF-8'))
        return move_unique(c_inst)

    def __add__(object self, object other):
        return type(self)(itertools.chain(self, other))

    def __getitem__(self, object index_obj):
        cdef shared_ptr[vector[string]] c_inst
        cdef string citem
        if isinstance(index_obj, slice):
            c_inst = make_shared[vector[string]]()
            sz = deref(self._cpp_obj).size()
            for index in range(*index_obj.indices(sz)):
                citem = deref(self._cpp_obj.get())[index]
                deref(c_inst).push_back(citem)
            return List__string.create(c_inst)
        else:
            index = <int?>index_obj
            size = len(self)
            # Convert a negative index
            if index < 0:
                index = size + index
            if index >= size or index < 0:
                raise IndexError('list index out of range')
            citem = deref(self._cpp_obj.get())[index]
            return bytes(citem).decode('UTF-8')

    def __len__(self):
        return deref(self._cpp_obj).size()

    def __richcmp__(self, other, op):
        cdef int cop = op
        if cop not in (2, 3):
            raise TypeError("unorderable types: {}, {}".format(type(self), type(other)))
        if not (isinstance(self, Iterable) and isinstance(other, Iterable)):
            return cop != 2
        if (len(self) != len(other)):
            return cop != 2

        for one, two in zip(self, other):
            if one != two:
                return cop != 2

        return cop == 2

    def __hash__(self):
        if not self.__hash:
            self.__hash = hash(tuple(self))
        return self.__hash

    def __contains__(self, item):
        if not self or item is None:
            return False
        if not isinstance(item, str):
            return False
        cdef string citem = item.encode('UTF-8')
        cdef vector[string] vec = deref(
            self._cpp_obj.get())
        return std_libcpp.find(vec.begin(), vec.end(), citem) != vec.end()

    def __iter__(self):
        if not self:
            raise StopIteration
        cdef string citem
        for citem in deref(self._cpp_obj):
            yield bytes(citem).decode('UTF-8')

    def __repr__(self):
        if not self:
            return 'i[]'
        return f'i[{", ".join(map(repr, self))}]'

    def __reversed__(self):
        if not self:
            raise StopIteration
        cdef string citem
        cdef vector[string] vec = deref(
            self._cpp_obj.get())
        cdef vector[string].reverse_iterator loc = vec.rbegin()
        while loc != vec.rend():
            citem = deref(loc)
            yield bytes(citem).decode('UTF-8')
            inc(loc)

    def index(self, item, start not None=__NOTSET, stop not None=__NOTSET):
        err = ValueError(f'{item} is not in list')
        if not self or item is None:
            raise err
        offset_begin = offset_end = 0
        if stop is not __NOTSET or start is not __NOTSET:
            # Like self[start:stop].index(item)
            size = len(self)
            stop = stop if stop is not __NOTSET else size
            start = start if start is not __NOTSET else 0
            # Convert stop to a negative position.
            if stop > 0:
                stop = min(stop - size, 0)
            if stop <= -size:
                raise err  # List would be empty
            offset_end = -stop
            # Convert start to always be positive
            if start < 0:
                start = max(size + start, 0)
            if start >= size:
                raise err  # past end of list
            offset_begin = start

        if not isinstance(item, str):
            raise err
        cdef string citem = item.encode('UTF-8')
        cdef vector[string] vec = deref(self._cpp_obj.get())
        cdef vector[string].iterator end = std_libcpp.prev(vec.end(), <int64_t>offset_end)
        cdef vector[string].iterator loc = std_libcpp.find(
            std_libcpp.next(vec.begin(), <int64_t>offset_begin),
            end,
            citem
        )
        if loc != end:
            return <int64_t> std_libcpp.distance(vec.begin(), loc)
        raise err

    def count(self, item):
        if not self or item is None:
            return 0
        if not isinstance(item, str):
            return 0
        cdef string citem = item.encode('UTF-8')
        cdef vector[string] vec = deref(self._cpp_obj.get())
        return <int64_t> std_libcpp.count(vec.begin(), vec.end(), citem)


Sequence.register(List__string)

cdef class List__SimpleStruct:
    def __init__(self, items=None):
        if isinstance(items, List__SimpleStruct):
            self._cpp_obj = (<List__SimpleStruct> items)._cpp_obj
        else:
            self._cpp_obj = move(List__SimpleStruct._make_instance(items))

    @staticmethod
    cdef create(shared_ptr[vector[cSimpleStruct]] c_items):
        inst = <List__SimpleStruct>List__SimpleStruct.__new__(List__SimpleStruct)
        inst._cpp_obj = c_items
        return inst

    @staticmethod
    cdef unique_ptr[vector[cSimpleStruct]] _make_instance(object items) except *:
        cdef unique_ptr[vector[cSimpleStruct]] c_inst = make_unique[vector[cSimpleStruct]]()
        if items is not None:
            for item in items:
                if not isinstance(item, SimpleStruct):
                    raise TypeError(f"{item!r} is not of type 'SimpleStruct'")
                deref(c_inst).push_back(deref((<SimpleStruct>item)._cpp_obj))
        return move_unique(c_inst)

    def __add__(object self, object other):
        return type(self)(itertools.chain(self, other))

    def __getitem__(self, object index_obj):
        cdef shared_ptr[vector[cSimpleStruct]] c_inst
        cdef cSimpleStruct citem
        if isinstance(index_obj, slice):
            c_inst = make_shared[vector[cSimpleStruct]]()
            sz = deref(self._cpp_obj).size()
            for index in range(*index_obj.indices(sz)):
                citem = deref(self._cpp_obj.get())[index]
                deref(c_inst).push_back(citem)
            return List__SimpleStruct.create(c_inst)
        else:
            index = <int?>index_obj
            size = len(self)
            # Convert a negative index
            if index < 0:
                index = size + index
            if index >= size or index < 0:
                raise IndexError('list index out of range')
            citem = deref(self._cpp_obj.get())[index]
            return SimpleStruct.create(make_shared[cSimpleStruct](citem))

    def __len__(self):
        return deref(self._cpp_obj).size()

    def __richcmp__(self, other, op):
        cdef int cop = op
        if cop not in (2, 3):
            raise TypeError("unorderable types: {}, {}".format(type(self), type(other)))
        if not (isinstance(self, Iterable) and isinstance(other, Iterable)):
            return cop != 2
        if (len(self) != len(other)):
            return cop != 2

        for one, two in zip(self, other):
            if one != two:
                return cop != 2

        return cop == 2

    def __hash__(self):
        if not self.__hash:
            self.__hash = hash(tuple(self))
        return self.__hash

    def __contains__(self, item):
        if not self or item is None:
            return False
        if not isinstance(item, SimpleStruct):
            return False
        cdef cSimpleStruct citem = deref((<SimpleStruct>item)._cpp_obj)
        cdef vector[cSimpleStruct] vec = deref(
            self._cpp_obj.get())
        return std_libcpp.find(vec.begin(), vec.end(), citem) != vec.end()

    def __iter__(self):
        if not self:
            raise StopIteration
        cdef cSimpleStruct citem
        for citem in deref(self._cpp_obj):
            yield SimpleStruct.create(make_shared[cSimpleStruct](citem))

    def __repr__(self):
        if not self:
            return 'i[]'
        return f'i[{", ".join(map(repr, self))}]'

    def __reversed__(self):
        if not self:
            raise StopIteration
        cdef cSimpleStruct citem
        cdef vector[cSimpleStruct] vec = deref(
            self._cpp_obj.get())
        cdef vector[cSimpleStruct].reverse_iterator loc = vec.rbegin()
        while loc != vec.rend():
            citem = deref(loc)
            yield SimpleStruct.create(make_shared[cSimpleStruct](citem))
            inc(loc)

    def index(self, item, start not None=__NOTSET, stop not None=__NOTSET):
        err = ValueError(f'{item} is not in list')
        if not self or item is None:
            raise err
        offset_begin = offset_end = 0
        if stop is not __NOTSET or start is not __NOTSET:
            # Like self[start:stop].index(item)
            size = len(self)
            stop = stop if stop is not __NOTSET else size
            start = start if start is not __NOTSET else 0
            # Convert stop to a negative position.
            if stop > 0:
                stop = min(stop - size, 0)
            if stop <= -size:
                raise err  # List would be empty
            offset_end = -stop
            # Convert start to always be positive
            if start < 0:
                start = max(size + start, 0)
            if start >= size:
                raise err  # past end of list
            offset_begin = start

        if not isinstance(item, SimpleStruct):
            raise err
        cdef cSimpleStruct citem = deref((<SimpleStruct>item)._cpp_obj)
        cdef vector[cSimpleStruct] vec = deref(self._cpp_obj.get())
        cdef vector[cSimpleStruct].iterator end = std_libcpp.prev(vec.end(), <int64_t>offset_end)
        cdef vector[cSimpleStruct].iterator loc = std_libcpp.find(
            std_libcpp.next(vec.begin(), <int64_t>offset_begin),
            end,
            citem
        )
        if loc != end:
            return <int64_t> std_libcpp.distance(vec.begin(), loc)
        raise err

    def count(self, item):
        if not self or item is None:
            return 0
        if not isinstance(item, SimpleStruct):
            return 0
        cdef cSimpleStruct citem = deref((<SimpleStruct>item)._cpp_obj)
        cdef vector[cSimpleStruct] vec = deref(self._cpp_obj.get())
        return <int64_t> std_libcpp.count(vec.begin(), vec.end(), citem)


Sequence.register(List__SimpleStruct)

cdef class Set__i32:
    def __init__(self, items=None):
        if isinstance(items, Set__i32):
            self._cpp_obj = (<Set__i32> items)._cpp_obj
        else:
            self._cpp_obj = move(Set__i32._make_instance(items))

    @staticmethod
    cdef create(shared_ptr[cset[int32_t]] c_items):
        inst = <Set__i32>Set__i32.__new__(Set__i32)
        inst._cpp_obj = c_items
        return inst

    @staticmethod
    cdef unique_ptr[cset[int32_t]] _make_instance(object items) except *:
        cdef unique_ptr[cset[int32_t]] c_inst = make_unique[cset[int32_t]]()
        if items is not None:
            for item in items:
                if not isinstance(item, int):
                    raise TypeError(f"{item!r} is not of type int")
                item = <int32_t> item
                deref(c_inst).insert(item)
        return move_unique(c_inst)

    def __contains__(self, item):
        if not self or item is None:
            return False
        if not isinstance(item, int):
            return False
        return pbool(deref(self._cpp_obj).count(item))


    def __len__(self):
        return deref(self._cpp_obj).size()

    def __iter__(self):
        if not self:
            raise StopIteration
        for citem in deref(self._cpp_obj):
            yield citem

    def __repr__(self):
        if not self:
            return 'iset()'
        return f'i{{{", ".join(map(repr, self))}}}'

    def __richcmp__(self, other, op):
        cdef int cop = op
        cdef cset[int32_t] cself, cother
        cdef cbool retval
        if (isinstance(self, Set__i32) and
                isinstance(other, Set__i32)):
            cself = deref((<Set__i32> self)._cpp_obj)
            cother = deref((<Set__i32> other)._cpp_obj)
            # C level comparisons
            if cop == 0:    # Less Than (strict subset)
                if not cself.size() < cother.size():
                    return False
                for item in cself:
                    if not cother.count(item):
                        return False
                return True
            elif cop == 1:  # Less Than or Equal To  (subset)
                for item in cself:
                    if not cother.count(item):
                        return False
                return True
            elif cop == 2:  # Equivalent
                if cself.size() != cother.size():
                    return False
                for item in cself:
                    if not cother.count(item):
                        return False
                return True
            elif cop == 3:  # Not Equivalent
                for item in cself:
                    if not cother.count(item):
                        return True
                return cself.size() != cother.size()
            elif cop == 4:  # Greater Than (strict superset)
                if not cself.size() > cother.size():
                    return False
                for item in cother:
                    if not cself.count(item):
                        return False
                return True
            elif cop == 5:  # Greater Than or Equal To (superset)
                for item in cother:
                    if not cself.count(item):
                        return False
                return True

        # Python level comparisons
        if cop == 0:
            return Set.__lt__(self, other)
        elif cop == 1:
            return Set.__le__(self, other)
        elif cop == 2:
            return Set.__eq__(self, other)
        elif cop == 3:
            return Set.__ne__(self, other)
        elif cop == 4:
            return Set.__gt__(self, other)
        elif cop == 5:
            return Set.__ge__(self, other)

    def __hash__(self):
        if not self.__hash:
            self.__hash = hash(tuple(self))
        return self.__hash

    def __and__(self, other):
        if not isinstance(self, Set__i32):
            self = Set__i32(self)
        if not isinstance(other, Set__i32):
            other = Set__i32(other)

        cdef shared_ptr[cset[int32_t]] shretval = \
            make_shared[cset[int32_t]]()
        for citem in deref((<Set__i32> self)._cpp_obj):
            if deref((<Set__i32> other)._cpp_obj).count(citem) > 0:
                deref(shretval).insert(citem)
        return Set__i32.create(shretval)

    def __sub__(self, other):
        if not isinstance(self, Set__i32):
            self = Set__i32(self)
        if not isinstance(other, Set__i32):
            other = Set__i32(other)

        cdef shared_ptr[cset[int32_t]] shretval = \
            make_shared[cset[int32_t]]()
        for citem in deref((<Set__i32> self)._cpp_obj):
            if deref((<Set__i32> other)._cpp_obj).count(citem) == 0:
                deref(shretval).insert(citem)
        return Set__i32.create(shretval)

    def __or__(self, other):
        if not isinstance(self, Set__i32):
            self = Set__i32(self)
        if not isinstance(other, Set__i32):
            other = Set__i32(other)

        cdef shared_ptr[cset[int32_t]] shretval = \
            make_shared[cset[int32_t]]()
        for citem in deref((<Set__i32> self)._cpp_obj):
                deref(shretval).insert(citem)
        for citem in deref((<Set__i32> other)._cpp_obj):
                deref(shretval).insert(citem)
        return Set__i32.create(shretval)

    def __xor__(self, other):
        if not isinstance(self, Set__i32):
            self = Set__i32(self)
        if not isinstance(other, Set__i32):
            other = Set__i32(other)

        cdef shared_ptr[cset[int32_t]] shretval = \
            make_shared[cset[int32_t]]()
        for citem in deref((<Set__i32> self)._cpp_obj):
            if deref((<Set__i32> other)._cpp_obj).count(citem) == 0:
                deref(shretval).insert(citem)
        for citem in deref((<Set__i32> other)._cpp_obj):
            if deref((<Set__i32> self)._cpp_obj).count(citem) == 0:
                deref(shretval).insert(citem)
        return Set__i32.create(shretval)

    def isdisjoint(self, other):
        return len(self & other) == 0

    def union(self, other):
        return self | other

    def intersection(self, other):
        return self & other

    def difference(self, other):
        return self - other

    def symmetric_difference(self, other):
        return self ^ other

    def issubset(self, other):
        return self <= other

    def issuperset(self, other):
        return self >= other


Set.register(Set__i32)

cdef class Set__string:
    def __init__(self, items=None):
        if isinstance(items, Set__string):
            self._cpp_obj = (<Set__string> items)._cpp_obj
        else:
            self._cpp_obj = move(Set__string._make_instance(items))

    @staticmethod
    cdef create(shared_ptr[cset[string]] c_items):
        inst = <Set__string>Set__string.__new__(Set__string)
        inst._cpp_obj = c_items
        return inst

    @staticmethod
    cdef unique_ptr[cset[string]] _make_instance(object items) except *:
        cdef unique_ptr[cset[string]] c_inst = make_unique[cset[string]]()
        if items is not None:
            for item in items:
                if not isinstance(item, str):
                    raise TypeError(f"{item!r} is not of type str")
                deref(c_inst).insert(item.encode('UTF-8'))
        return move_unique(c_inst)

    def __contains__(self, item):
        if not self or item is None:
            return False
        if not isinstance(item, str):
            return False
        return pbool(deref(self._cpp_obj).count(item.encode('UTF-8')))


    def __len__(self):
        return deref(self._cpp_obj).size()

    def __iter__(self):
        if not self:
            raise StopIteration
        for citem in deref(self._cpp_obj):
            yield bytes(citem).decode('UTF-8')

    def __repr__(self):
        if not self:
            return 'iset()'
        return f'i{{{", ".join(map(repr, self))}}}'

    def __richcmp__(self, other, op):
        cdef int cop = op
        cdef cset[string] cself, cother
        cdef cbool retval
        if (isinstance(self, Set__string) and
                isinstance(other, Set__string)):
            cself = deref((<Set__string> self)._cpp_obj)
            cother = deref((<Set__string> other)._cpp_obj)
            # C level comparisons
            if cop == 0:    # Less Than (strict subset)
                if not cself.size() < cother.size():
                    return False
                for item in cself:
                    if not cother.count(item):
                        return False
                return True
            elif cop == 1:  # Less Than or Equal To  (subset)
                for item in cself:
                    if not cother.count(item):
                        return False
                return True
            elif cop == 2:  # Equivalent
                if cself.size() != cother.size():
                    return False
                for item in cself:
                    if not cother.count(item):
                        return False
                return True
            elif cop == 3:  # Not Equivalent
                for item in cself:
                    if not cother.count(item):
                        return True
                return cself.size() != cother.size()
            elif cop == 4:  # Greater Than (strict superset)
                if not cself.size() > cother.size():
                    return False
                for item in cother:
                    if not cself.count(item):
                        return False
                return True
            elif cop == 5:  # Greater Than or Equal To (superset)
                for item in cother:
                    if not cself.count(item):
                        return False
                return True

        # Python level comparisons
        if cop == 0:
            return Set.__lt__(self, other)
        elif cop == 1:
            return Set.__le__(self, other)
        elif cop == 2:
            return Set.__eq__(self, other)
        elif cop == 3:
            return Set.__ne__(self, other)
        elif cop == 4:
            return Set.__gt__(self, other)
        elif cop == 5:
            return Set.__ge__(self, other)

    def __hash__(self):
        if not self.__hash:
            self.__hash = hash(tuple(self))
        return self.__hash

    def __and__(self, other):
        if not isinstance(self, Set__string):
            self = Set__string(self)
        if not isinstance(other, Set__string):
            other = Set__string(other)

        cdef shared_ptr[cset[string]] shretval = \
            make_shared[cset[string]]()
        for citem in deref((<Set__string> self)._cpp_obj):
            if deref((<Set__string> other)._cpp_obj).count(citem) > 0:
                deref(shretval).insert(citem)
        return Set__string.create(shretval)

    def __sub__(self, other):
        if not isinstance(self, Set__string):
            self = Set__string(self)
        if not isinstance(other, Set__string):
            other = Set__string(other)

        cdef shared_ptr[cset[string]] shretval = \
            make_shared[cset[string]]()
        for citem in deref((<Set__string> self)._cpp_obj):
            if deref((<Set__string> other)._cpp_obj).count(citem) == 0:
                deref(shretval).insert(citem)
        return Set__string.create(shretval)

    def __or__(self, other):
        if not isinstance(self, Set__string):
            self = Set__string(self)
        if not isinstance(other, Set__string):
            other = Set__string(other)

        cdef shared_ptr[cset[string]] shretval = \
            make_shared[cset[string]]()
        for citem in deref((<Set__string> self)._cpp_obj):
                deref(shretval).insert(citem)
        for citem in deref((<Set__string> other)._cpp_obj):
                deref(shretval).insert(citem)
        return Set__string.create(shretval)

    def __xor__(self, other):
        if not isinstance(self, Set__string):
            self = Set__string(self)
        if not isinstance(other, Set__string):
            other = Set__string(other)

        cdef shared_ptr[cset[string]] shretval = \
            make_shared[cset[string]]()
        for citem in deref((<Set__string> self)._cpp_obj):
            if deref((<Set__string> other)._cpp_obj).count(citem) == 0:
                deref(shretval).insert(citem)
        for citem in deref((<Set__string> other)._cpp_obj):
            if deref((<Set__string> self)._cpp_obj).count(citem) == 0:
                deref(shretval).insert(citem)
        return Set__string.create(shretval)

    def isdisjoint(self, other):
        return len(self & other) == 0

    def union(self, other):
        return self | other

    def intersection(self, other):
        return self & other

    def difference(self, other):
        return self - other

    def symmetric_difference(self, other):
        return self ^ other

    def issubset(self, other):
        return self <= other

    def issuperset(self, other):
        return self >= other


Set.register(Set__string)

cdef class Map__string_string:
    def __init__(self, items=None):
        if isinstance(items, Map__string_string):
            self._cpp_obj = (<Map__string_string> items)._cpp_obj
        else:
            self._cpp_obj = move(Map__string_string._make_instance(items))

    @staticmethod
    cdef create(shared_ptr[cmap[string,string]] c_items):
        inst = <Map__string_string>Map__string_string.__new__(Map__string_string)
        inst._cpp_obj = c_items
        return inst

    @staticmethod
    cdef unique_ptr[cmap[string,string]] _make_instance(object items) except *:
        cdef unique_ptr[cmap[string,string]] c_inst = make_unique[cmap[string,string]]()
        if items is not None:
            for key, item in items.items():
                if not isinstance(key, str):
                    raise TypeError(f"{key!r} is not of type str")
                if not isinstance(item, str):
                    raise TypeError(f"{item!r} is not of type str")

                deref(c_inst).insert(cpair[string,string](key.encode('UTF-8'),item.encode('UTF-8')))
        return move_unique(c_inst)

    def __getitem__(self, key):
        err = KeyError(f'{key}')
        if not self or key is None:
            raise err
        if not isinstance(key, str):
            raise err
        cdef string ckey = key.encode('UTF-8')
        cdef cmap[string,string].iterator iter = deref(
            self._cpp_obj).find(ckey)
        if iter == deref(self._cpp_obj).end():
            raise err
        cdef string citem = deref(iter).second
        return bytes(citem).decode('UTF-8')

    def __len__(self):
        return deref(self._cpp_obj).size()

    def __iter__(self):
        if not self:
            raise StopIteration
        cdef string citem
        for pair in deref(self._cpp_obj):
            citem = pair.first
            yield bytes(citem).decode('UTF-8')

    def __richcmp__(self, other, op):
        cdef int cop = op
        if cop not in (2, 3):
            raise TypeError("unorderable types: {}, {}".format(type(self), type(other)))
        if not (isinstance(self, Mapping) and isinstance(other, Mapping)):
            return cop != 2
        if (len(self) != len(other)):
            return cop != 2

        for key in self:
            if key not in other:
                return cop != 2
            if other[key] != self[key]:
                return cop != 2

        return cop == 2

    def __hash__(self):
        if not self.__hash:
            self.__hash = hash(tuple(self.items()))
        return self.__hash

    def __repr__(self):
        if not self:
            return 'i{}'
        return f'i{{{", ".join(map(lambda i: f"{repr(i[0])}: {repr(i[1])}", self.items()))}}}'

    def __contains__(self, key):
        if not self or key is None:
            return False
        if not isinstance(key, str):
            return False
        cdef string ckey = key.encode('UTF-8')
        return deref(self._cpp_obj).count(ckey) > 0

    def get(self, key, default=None):
        if not self or key is None:
            return default
        try:
            if not isinstance(key, str):
                key = str(key)
        except Exception:
            return default
        if not isinstance(key, str):
            return default
        if key not in self:
            return default
        return self[key]

    def keys(self):
        return self.__iter__()

    def values(self):
        if not self:
            raise StopIteration
        cdef string citem
        for pair in deref(self._cpp_obj):
            citem = pair.second
            yield bytes(citem).decode('UTF-8')

    def items(self):
        if not self:
            raise StopIteration
        cdef string ckey
        cdef string citem
        for pair in deref(self._cpp_obj):
            ckey = pair.first
            citem = pair.second

            yield (ckey.decode('UTF-8'), bytes(citem).decode('UTF-8'))



Mapping.register(Map__string_string)

cdef class Map__string_SimpleStruct:
    def __init__(self, items=None):
        if isinstance(items, Map__string_SimpleStruct):
            self._cpp_obj = (<Map__string_SimpleStruct> items)._cpp_obj
        else:
            self._cpp_obj = move(Map__string_SimpleStruct._make_instance(items))

    @staticmethod
    cdef create(shared_ptr[cmap[string,cSimpleStruct]] c_items):
        inst = <Map__string_SimpleStruct>Map__string_SimpleStruct.__new__(Map__string_SimpleStruct)
        inst._cpp_obj = c_items
        return inst

    @staticmethod
    cdef unique_ptr[cmap[string,cSimpleStruct]] _make_instance(object items) except *:
        cdef unique_ptr[cmap[string,cSimpleStruct]] c_inst = make_unique[cmap[string,cSimpleStruct]]()
        if items is not None:
            for key, item in items.items():
                if not isinstance(key, str):
                    raise TypeError(f"{key!r} is not of type str")
                if not isinstance(item, SimpleStruct):
                    raise TypeError(f"{item!r} is not of type 'SimpleStruct'")

                deref(c_inst).insert(cpair[string,cSimpleStruct](key.encode('UTF-8'),deref((<SimpleStruct>item)._cpp_obj)))
        return move_unique(c_inst)

    def __getitem__(self, key):
        err = KeyError(f'{key}')
        if not self or key is None:
            raise err
        if not isinstance(key, str):
            raise err
        cdef string ckey = key.encode('UTF-8')
        cdef cmap[string,cSimpleStruct].iterator iter = deref(
            self._cpp_obj).find(ckey)
        if iter == deref(self._cpp_obj).end():
            raise err
        cdef cSimpleStruct citem = deref(iter).second
        return SimpleStruct.create(make_shared[cSimpleStruct](citem))

    def __len__(self):
        return deref(self._cpp_obj).size()

    def __iter__(self):
        if not self:
            raise StopIteration
        cdef string citem
        for pair in deref(self._cpp_obj):
            citem = pair.first
            yield bytes(citem).decode('UTF-8')

    def __richcmp__(self, other, op):
        cdef int cop = op
        if cop not in (2, 3):
            raise TypeError("unorderable types: {}, {}".format(type(self), type(other)))
        if not (isinstance(self, Mapping) and isinstance(other, Mapping)):
            return cop != 2
        if (len(self) != len(other)):
            return cop != 2

        for key in self:
            if key not in other:
                return cop != 2
            if other[key] != self[key]:
                return cop != 2

        return cop == 2

    def __hash__(self):
        if not self.__hash:
            self.__hash = hash(tuple(self.items()))
        return self.__hash

    def __repr__(self):
        if not self:
            return 'i{}'
        return f'i{{{", ".join(map(lambda i: f"{repr(i[0])}: {repr(i[1])}", self.items()))}}}'

    def __contains__(self, key):
        if not self or key is None:
            return False
        if not isinstance(key, str):
            return False
        cdef string ckey = key.encode('UTF-8')
        return deref(self._cpp_obj).count(ckey) > 0

    def get(self, key, default=None):
        if not self or key is None:
            return default
        try:
            if not isinstance(key, str):
                key = str(key)
        except Exception:
            return default
        if not isinstance(key, str):
            return default
        if key not in self:
            return default
        return self[key]

    def keys(self):
        return self.__iter__()

    def values(self):
        if not self:
            raise StopIteration
        cdef cSimpleStruct citem
        for pair in deref(self._cpp_obj):
            citem = pair.second
            yield SimpleStruct.create(make_shared[cSimpleStruct](citem))

    def items(self):
        if not self:
            raise StopIteration
        cdef string ckey
        cdef cSimpleStruct citem
        for pair in deref(self._cpp_obj):
            ckey = pair.first
            citem = pair.second

            yield (ckey.decode('UTF-8'), SimpleStruct.create(make_shared[cSimpleStruct](citem)))



Mapping.register(Map__string_SimpleStruct)

cdef class Map__string_i16:
    def __init__(self, items=None):
        if isinstance(items, Map__string_i16):
            self._cpp_obj = (<Map__string_i16> items)._cpp_obj
        else:
            self._cpp_obj = move(Map__string_i16._make_instance(items))

    @staticmethod
    cdef create(shared_ptr[cmap[string,int16_t]] c_items):
        inst = <Map__string_i16>Map__string_i16.__new__(Map__string_i16)
        inst._cpp_obj = c_items
        return inst

    @staticmethod
    cdef unique_ptr[cmap[string,int16_t]] _make_instance(object items) except *:
        cdef unique_ptr[cmap[string,int16_t]] c_inst = make_unique[cmap[string,int16_t]]()
        if items is not None:
            for key, item in items.items():
                if not isinstance(key, str):
                    raise TypeError(f"{key!r} is not of type str")
                if not isinstance(item, int):
                    raise TypeError(f"{item!r} is not of type int")
                item = <int16_t> item

                deref(c_inst).insert(cpair[string,int16_t](key.encode('UTF-8'),item))
        return move_unique(c_inst)

    def __getitem__(self, key):
        err = KeyError(f'{key}')
        if not self or key is None:
            raise err
        if not isinstance(key, str):
            raise err
        cdef string ckey = key.encode('UTF-8')
        cdef cmap[string,int16_t].iterator iter = deref(
            self._cpp_obj).find(ckey)
        if iter == deref(self._cpp_obj).end():
            raise err
        cdef int16_t citem = deref(iter).second
        return citem

    def __len__(self):
        return deref(self._cpp_obj).size()

    def __iter__(self):
        if not self:
            raise StopIteration
        cdef string citem
        for pair in deref(self._cpp_obj):
            citem = pair.first
            yield bytes(citem).decode('UTF-8')

    def __richcmp__(self, other, op):
        cdef int cop = op
        if cop not in (2, 3):
            raise TypeError("unorderable types: {}, {}".format(type(self), type(other)))
        if not (isinstance(self, Mapping) and isinstance(other, Mapping)):
            return cop != 2
        if (len(self) != len(other)):
            return cop != 2

        for key in self:
            if key not in other:
                return cop != 2
            if other[key] != self[key]:
                return cop != 2

        return cop == 2

    def __hash__(self):
        if not self.__hash:
            self.__hash = hash(tuple(self.items()))
        return self.__hash

    def __repr__(self):
        if not self:
            return 'i{}'
        return f'i{{{", ".join(map(lambda i: f"{repr(i[0])}: {repr(i[1])}", self.items()))}}}'

    def __contains__(self, key):
        if not self or key is None:
            return False
        if not isinstance(key, str):
            return False
        cdef string ckey = key.encode('UTF-8')
        return deref(self._cpp_obj).count(ckey) > 0

    def get(self, key, default=None):
        if not self or key is None:
            return default
        try:
            if not isinstance(key, str):
                key = str(key)
        except Exception:
            return default
        if not isinstance(key, str):
            return default
        if key not in self:
            return default
        return self[key]

    def keys(self):
        return self.__iter__()

    def values(self):
        if not self:
            raise StopIteration
        cdef int16_t citem
        for pair in deref(self._cpp_obj):
            citem = pair.second
            yield citem

    def items(self):
        if not self:
            raise StopIteration
        cdef string ckey
        cdef int16_t citem
        for pair in deref(self._cpp_obj):
            ckey = pair.first
            citem = pair.second

            yield (ckey.decode('UTF-8'), citem)



Mapping.register(Map__string_i16)

cdef class List__List__i32:
    def __init__(self, items=None):
        if isinstance(items, List__List__i32):
            self._cpp_obj = (<List__List__i32> items)._cpp_obj
        else:
            self._cpp_obj = move(List__List__i32._make_instance(items))

    @staticmethod
    cdef create(shared_ptr[vector[vector[int32_t]]] c_items):
        inst = <List__List__i32>List__List__i32.__new__(List__List__i32)
        inst._cpp_obj = c_items
        return inst

    @staticmethod
    cdef unique_ptr[vector[vector[int32_t]]] _make_instance(object items) except *:
        cdef unique_ptr[vector[vector[int32_t]]] c_inst = make_unique[vector[vector[int32_t]]]()
        if items is not None:
            for item in items:
                if item is None:
                    raise TypeError("None is not of the type _typing.Sequence[int]")
                if not isinstance(item, List__i32):
                    item = List__i32(item)
                deref(c_inst).push_back(vector[int32_t](deref(List__i32(item)._cpp_obj.get())))
        return move_unique(c_inst)

    def __add__(object self, object other):
        return type(self)(itertools.chain(self, other))

    def __getitem__(self, object index_obj):
        cdef shared_ptr[vector[vector[int32_t]]] c_inst
        cdef vector[int32_t] citem
        if isinstance(index_obj, slice):
            c_inst = make_shared[vector[vector[int32_t]]]()
            sz = deref(self._cpp_obj).size()
            for index in range(*index_obj.indices(sz)):
                citem = deref(self._cpp_obj.get())[index]
                deref(c_inst).push_back(citem)
            return List__List__i32.create(c_inst)
        else:
            index = <int?>index_obj
            size = len(self)
            # Convert a negative index
            if index < 0:
                index = size + index
            if index >= size or index < 0:
                raise IndexError('list index out of range')
            citem = deref(self._cpp_obj.get())[index]
            return List__i32.create(
    make_shared[vector[int32_t]](citem))

    def __len__(self):
        return deref(self._cpp_obj).size()

    def __richcmp__(self, other, op):
        cdef int cop = op
        if cop not in (2, 3):
            raise TypeError("unorderable types: {}, {}".format(type(self), type(other)))
        if not (isinstance(self, Iterable) and isinstance(other, Iterable)):
            return cop != 2
        if (len(self) != len(other)):
            return cop != 2

        for one, two in zip(self, other):
            if one != two:
                return cop != 2

        return cop == 2

    def __hash__(self):
        if not self.__hash:
            self.__hash = hash(tuple(self))
        return self.__hash

    def __contains__(self, item):
        if not self or item is None:
            return False
        try:
            if not isinstance(item, List__i32):
                item = List__i32(item)
        except Exception:
            return False
        if not isinstance(item, List__i32):
            return False
        cdef vector[int32_t] citem = vector[int32_t](deref(List__i32(item)._cpp_obj.get()))
        cdef vector[vector[int32_t]] vec = deref(
            self._cpp_obj.get())
        return std_libcpp.find(vec.begin(), vec.end(), citem) != vec.end()

    def __iter__(self):
        if not self:
            raise StopIteration
        cdef vector[int32_t] citem
        for citem in deref(self._cpp_obj):
            yield List__i32.create(
    make_shared[vector[int32_t]](citem))

    def __repr__(self):
        if not self:
            return 'i[]'
        return f'i[{", ".join(map(repr, self))}]'

    def __reversed__(self):
        if not self:
            raise StopIteration
        cdef vector[int32_t] citem
        cdef vector[vector[int32_t]] vec = deref(
            self._cpp_obj.get())
        cdef vector[vector[int32_t]].reverse_iterator loc = vec.rbegin()
        while loc != vec.rend():
            citem = deref(loc)
            yield List__i32.create(
    make_shared[vector[int32_t]](citem))
            inc(loc)

    def index(self, item, start not None=__NOTSET, stop not None=__NOTSET):
        err = ValueError(f'{item} is not in list')
        if not self or item is None:
            raise err
        offset_begin = offset_end = 0
        if stop is not __NOTSET or start is not __NOTSET:
            # Like self[start:stop].index(item)
            size = len(self)
            stop = stop if stop is not __NOTSET else size
            start = start if start is not __NOTSET else 0
            # Convert stop to a negative position.
            if stop > 0:
                stop = min(stop - size, 0)
            if stop <= -size:
                raise err  # List would be empty
            offset_end = -stop
            # Convert start to always be positive
            if start < 0:
                start = max(size + start, 0)
            if start >= size:
                raise err  # past end of list
            offset_begin = start

        try:
            if not isinstance(item, List__i32):
                item = List__i32(item)
        except Exception:
            raise err from None
        if not isinstance(item, List__i32):
            raise err
        cdef vector[int32_t] citem = vector[int32_t](deref(List__i32(item)._cpp_obj.get()))
        cdef vector[vector[int32_t]] vec = deref(self._cpp_obj.get())
        cdef vector[vector[int32_t]].iterator end = std_libcpp.prev(vec.end(), <int64_t>offset_end)
        cdef vector[vector[int32_t]].iterator loc = std_libcpp.find(
            std_libcpp.next(vec.begin(), <int64_t>offset_begin),
            end,
            citem
        )
        if loc != end:
            return <int64_t> std_libcpp.distance(vec.begin(), loc)
        raise err

    def count(self, item):
        if not self or item is None:
            return 0
        try:
            if not isinstance(item, List__i32):
                item = List__i32(item)
        except Exception:
            return 0
        if not isinstance(item, List__i32):
            return 0
        cdef vector[int32_t] citem = vector[int32_t](deref(List__i32(item)._cpp_obj.get()))
        cdef vector[vector[int32_t]] vec = deref(self._cpp_obj.get())
        return <int64_t> std_libcpp.count(vec.begin(), vec.end(), citem)


Sequence.register(List__List__i32)

cdef class Map__string_i32:
    def __init__(self, items=None):
        if isinstance(items, Map__string_i32):
            self._cpp_obj = (<Map__string_i32> items)._cpp_obj
        else:
            self._cpp_obj = move(Map__string_i32._make_instance(items))

    @staticmethod
    cdef create(shared_ptr[cmap[string,int32_t]] c_items):
        inst = <Map__string_i32>Map__string_i32.__new__(Map__string_i32)
        inst._cpp_obj = c_items
        return inst

    @staticmethod
    cdef unique_ptr[cmap[string,int32_t]] _make_instance(object items) except *:
        cdef unique_ptr[cmap[string,int32_t]] c_inst = make_unique[cmap[string,int32_t]]()
        if items is not None:
            for key, item in items.items():
                if not isinstance(key, str):
                    raise TypeError(f"{key!r} is not of type str")
                if not isinstance(item, int):
                    raise TypeError(f"{item!r} is not of type int")
                item = <int32_t> item

                deref(c_inst).insert(cpair[string,int32_t](key.encode('UTF-8'),item))
        return move_unique(c_inst)

    def __getitem__(self, key):
        err = KeyError(f'{key}')
        if not self or key is None:
            raise err
        if not isinstance(key, str):
            raise err
        cdef string ckey = key.encode('UTF-8')
        cdef cmap[string,int32_t].iterator iter = deref(
            self._cpp_obj).find(ckey)
        if iter == deref(self._cpp_obj).end():
            raise err
        cdef int32_t citem = deref(iter).second
        return citem

    def __len__(self):
        return deref(self._cpp_obj).size()

    def __iter__(self):
        if not self:
            raise StopIteration
        cdef string citem
        for pair in deref(self._cpp_obj):
            citem = pair.first
            yield bytes(citem).decode('UTF-8')

    def __richcmp__(self, other, op):
        cdef int cop = op
        if cop not in (2, 3):
            raise TypeError("unorderable types: {}, {}".format(type(self), type(other)))
        if not (isinstance(self, Mapping) and isinstance(other, Mapping)):
            return cop != 2
        if (len(self) != len(other)):
            return cop != 2

        for key in self:
            if key not in other:
                return cop != 2
            if other[key] != self[key]:
                return cop != 2

        return cop == 2

    def __hash__(self):
        if not self.__hash:
            self.__hash = hash(tuple(self.items()))
        return self.__hash

    def __repr__(self):
        if not self:
            return 'i{}'
        return f'i{{{", ".join(map(lambda i: f"{repr(i[0])}: {repr(i[1])}", self.items()))}}}'

    def __contains__(self, key):
        if not self or key is None:
            return False
        if not isinstance(key, str):
            return False
        cdef string ckey = key.encode('UTF-8')
        return deref(self._cpp_obj).count(ckey) > 0

    def get(self, key, default=None):
        if not self or key is None:
            return default
        try:
            if not isinstance(key, str):
                key = str(key)
        except Exception:
            return default
        if not isinstance(key, str):
            return default
        if key not in self:
            return default
        return self[key]

    def keys(self):
        return self.__iter__()

    def values(self):
        if not self:
            raise StopIteration
        cdef int32_t citem
        for pair in deref(self._cpp_obj):
            citem = pair.second
            yield citem

    def items(self):
        if not self:
            raise StopIteration
        cdef string ckey
        cdef int32_t citem
        for pair in deref(self._cpp_obj):
            ckey = pair.first
            citem = pair.second

            yield (ckey.decode('UTF-8'), citem)



Mapping.register(Map__string_i32)

cdef class Map__string_Map__string_i32:
    def __init__(self, items=None):
        if isinstance(items, Map__string_Map__string_i32):
            self._cpp_obj = (<Map__string_Map__string_i32> items)._cpp_obj
        else:
            self._cpp_obj = move(Map__string_Map__string_i32._make_instance(items))

    @staticmethod
    cdef create(shared_ptr[cmap[string,cmap[string,int32_t]]] c_items):
        inst = <Map__string_Map__string_i32>Map__string_Map__string_i32.__new__(Map__string_Map__string_i32)
        inst._cpp_obj = c_items
        return inst

    @staticmethod
    cdef unique_ptr[cmap[string,cmap[string,int32_t]]] _make_instance(object items) except *:
        cdef unique_ptr[cmap[string,cmap[string,int32_t]]] c_inst = make_unique[cmap[string,cmap[string,int32_t]]]()
        if items is not None:
            for key, item in items.items():
                if not isinstance(key, str):
                    raise TypeError(f"{key!r} is not of type str")
                if item is None:
                    raise TypeError("None is not of type _typing.Mapping[str, int]")
                if not isinstance(item, Map__string_i32):
                    item = Map__string_i32(item)

                deref(c_inst).insert(cpair[string,cmap[string,int32_t]](key.encode('UTF-8'),cmap[string,int32_t](deref(Map__string_i32(item)._cpp_obj.get()))))
        return move_unique(c_inst)

    def __getitem__(self, key):
        err = KeyError(f'{key}')
        if not self or key is None:
            raise err
        if not isinstance(key, str):
            raise err
        cdef string ckey = key.encode('UTF-8')
        cdef cmap[string,cmap[string,int32_t]].iterator iter = deref(
            self._cpp_obj).find(ckey)
        if iter == deref(self._cpp_obj).end():
            raise err
        cdef cmap[string,int32_t] citem = deref(iter).second
        return Map__string_i32.create(
    make_shared[cmap[string,int32_t]](citem))

    def __len__(self):
        return deref(self._cpp_obj).size()

    def __iter__(self):
        if not self:
            raise StopIteration
        cdef string citem
        for pair in deref(self._cpp_obj):
            citem = pair.first
            yield bytes(citem).decode('UTF-8')

    def __richcmp__(self, other, op):
        cdef int cop = op
        if cop not in (2, 3):
            raise TypeError("unorderable types: {}, {}".format(type(self), type(other)))
        if not (isinstance(self, Mapping) and isinstance(other, Mapping)):
            return cop != 2
        if (len(self) != len(other)):
            return cop != 2

        for key in self:
            if key not in other:
                return cop != 2
            if other[key] != self[key]:
                return cop != 2

        return cop == 2

    def __hash__(self):
        if not self.__hash:
            self.__hash = hash(tuple(self.items()))
        return self.__hash

    def __repr__(self):
        if not self:
            return 'i{}'
        return f'i{{{", ".join(map(lambda i: f"{repr(i[0])}: {repr(i[1])}", self.items()))}}}'

    def __contains__(self, key):
        if not self or key is None:
            return False
        if not isinstance(key, str):
            return False
        cdef string ckey = key.encode('UTF-8')
        return deref(self._cpp_obj).count(ckey) > 0

    def get(self, key, default=None):
        if not self or key is None:
            return default
        try:
            if not isinstance(key, str):
                key = str(key)
        except Exception:
            return default
        if not isinstance(key, str):
            return default
        if key not in self:
            return default
        return self[key]

    def keys(self):
        return self.__iter__()

    def values(self):
        if not self:
            raise StopIteration
        cdef cmap[string,int32_t] citem
        for pair in deref(self._cpp_obj):
            citem = pair.second
            yield Map__string_i32.create(
    make_shared[cmap[string,int32_t]](citem))

    def items(self):
        if not self:
            raise StopIteration
        cdef string ckey
        cdef cmap[string,int32_t] citem
        for pair in deref(self._cpp_obj):
            ckey = pair.first
            citem = pair.second

            yield (ckey.decode('UTF-8'), Map__string_i32.create(
    make_shared[cmap[string,int32_t]](citem)))



Mapping.register(Map__string_Map__string_i32)

cdef class List__Set__string:
    def __init__(self, items=None):
        if isinstance(items, List__Set__string):
            self._cpp_obj = (<List__Set__string> items)._cpp_obj
        else:
            self._cpp_obj = move(List__Set__string._make_instance(items))

    @staticmethod
    cdef create(shared_ptr[vector[cset[string]]] c_items):
        inst = <List__Set__string>List__Set__string.__new__(List__Set__string)
        inst._cpp_obj = c_items
        return inst

    @staticmethod
    cdef unique_ptr[vector[cset[string]]] _make_instance(object items) except *:
        cdef unique_ptr[vector[cset[string]]] c_inst = make_unique[vector[cset[string]]]()
        if items is not None:
            for item in items:
                if item is None:
                    raise TypeError("None is not of the type _typing.AbstractSet[str]")
                if not isinstance(item, Set__string):
                    item = Set__string(item)
                deref(c_inst).push_back(cset[string](deref(Set__string(item)._cpp_obj.get())))
        return move_unique(c_inst)

    def __add__(object self, object other):
        return type(self)(itertools.chain(self, other))

    def __getitem__(self, object index_obj):
        cdef shared_ptr[vector[cset[string]]] c_inst
        cdef cset[string] citem
        if isinstance(index_obj, slice):
            c_inst = make_shared[vector[cset[string]]]()
            sz = deref(self._cpp_obj).size()
            for index in range(*index_obj.indices(sz)):
                citem = deref(self._cpp_obj.get())[index]
                deref(c_inst).push_back(citem)
            return List__Set__string.create(c_inst)
        else:
            index = <int?>index_obj
            size = len(self)
            # Convert a negative index
            if index < 0:
                index = size + index
            if index >= size or index < 0:
                raise IndexError('list index out of range')
            citem = deref(self._cpp_obj.get())[index]
            return Set__string.create(
    make_shared[cset[string]](citem))

    def __len__(self):
        return deref(self._cpp_obj).size()

    def __richcmp__(self, other, op):
        cdef int cop = op
        if cop not in (2, 3):
            raise TypeError("unorderable types: {}, {}".format(type(self), type(other)))
        if not (isinstance(self, Iterable) and isinstance(other, Iterable)):
            return cop != 2
        if (len(self) != len(other)):
            return cop != 2

        for one, two in zip(self, other):
            if one != two:
                return cop != 2

        return cop == 2

    def __hash__(self):
        if not self.__hash:
            self.__hash = hash(tuple(self))
        return self.__hash

    def __contains__(self, item):
        if not self or item is None:
            return False
        try:
            if not isinstance(item, Set__string):
                item = Set__string(item)
        except Exception:
            return False
        if not isinstance(item, Set__string):
            return False
        cdef cset[string] citem = cset[string](deref(Set__string(item)._cpp_obj.get()))
        cdef vector[cset[string]] vec = deref(
            self._cpp_obj.get())
        return std_libcpp.find(vec.begin(), vec.end(), citem) != vec.end()

    def __iter__(self):
        if not self:
            raise StopIteration
        cdef cset[string] citem
        for citem in deref(self._cpp_obj):
            yield Set__string.create(
    make_shared[cset[string]](citem))

    def __repr__(self):
        if not self:
            return 'i[]'
        return f'i[{", ".join(map(repr, self))}]'

    def __reversed__(self):
        if not self:
            raise StopIteration
        cdef cset[string] citem
        cdef vector[cset[string]] vec = deref(
            self._cpp_obj.get())
        cdef vector[cset[string]].reverse_iterator loc = vec.rbegin()
        while loc != vec.rend():
            citem = deref(loc)
            yield Set__string.create(
    make_shared[cset[string]](citem))
            inc(loc)

    def index(self, item, start not None=__NOTSET, stop not None=__NOTSET):
        err = ValueError(f'{item} is not in list')
        if not self or item is None:
            raise err
        offset_begin = offset_end = 0
        if stop is not __NOTSET or start is not __NOTSET:
            # Like self[start:stop].index(item)
            size = len(self)
            stop = stop if stop is not __NOTSET else size
            start = start if start is not __NOTSET else 0
            # Convert stop to a negative position.
            if stop > 0:
                stop = min(stop - size, 0)
            if stop <= -size:
                raise err  # List would be empty
            offset_end = -stop
            # Convert start to always be positive
            if start < 0:
                start = max(size + start, 0)
            if start >= size:
                raise err  # past end of list
            offset_begin = start

        try:
            if not isinstance(item, Set__string):
                item = Set__string(item)
        except Exception:
            raise err from None
        if not isinstance(item, Set__string):
            raise err
        cdef cset[string] citem = cset[string](deref(Set__string(item)._cpp_obj.get()))
        cdef vector[cset[string]] vec = deref(self._cpp_obj.get())
        cdef vector[cset[string]].iterator end = std_libcpp.prev(vec.end(), <int64_t>offset_end)
        cdef vector[cset[string]].iterator loc = std_libcpp.find(
            std_libcpp.next(vec.begin(), <int64_t>offset_begin),
            end,
            citem
        )
        if loc != end:
            return <int64_t> std_libcpp.distance(vec.begin(), loc)
        raise err

    def count(self, item):
        if not self or item is None:
            return 0
        try:
            if not isinstance(item, Set__string):
                item = Set__string(item)
        except Exception:
            return 0
        if not isinstance(item, Set__string):
            return 0
        cdef cset[string] citem = cset[string](deref(Set__string(item)._cpp_obj.get()))
        cdef vector[cset[string]] vec = deref(self._cpp_obj.get())
        return <int64_t> std_libcpp.count(vec.begin(), vec.end(), citem)


Sequence.register(List__Set__string)

cdef class Map__string_List__SimpleStruct:
    def __init__(self, items=None):
        if isinstance(items, Map__string_List__SimpleStruct):
            self._cpp_obj = (<Map__string_List__SimpleStruct> items)._cpp_obj
        else:
            self._cpp_obj = move(Map__string_List__SimpleStruct._make_instance(items))

    @staticmethod
    cdef create(shared_ptr[cmap[string,vector[cSimpleStruct]]] c_items):
        inst = <Map__string_List__SimpleStruct>Map__string_List__SimpleStruct.__new__(Map__string_List__SimpleStruct)
        inst._cpp_obj = c_items
        return inst

    @staticmethod
    cdef unique_ptr[cmap[string,vector[cSimpleStruct]]] _make_instance(object items) except *:
        cdef unique_ptr[cmap[string,vector[cSimpleStruct]]] c_inst = make_unique[cmap[string,vector[cSimpleStruct]]]()
        if items is not None:
            for key, item in items.items():
                if not isinstance(key, str):
                    raise TypeError(f"{key!r} is not of type str")
                if item is None:
                    raise TypeError("None is not of type _typing.Sequence['SimpleStruct']")
                if not isinstance(item, List__SimpleStruct):
                    item = List__SimpleStruct(item)

                deref(c_inst).insert(cpair[string,vector[cSimpleStruct]](key.encode('UTF-8'),vector[cSimpleStruct](deref(List__SimpleStruct(item)._cpp_obj.get()))))
        return move_unique(c_inst)

    def __getitem__(self, key):
        err = KeyError(f'{key}')
        if not self or key is None:
            raise err
        if not isinstance(key, str):
            raise err
        cdef string ckey = key.encode('UTF-8')
        cdef cmap[string,vector[cSimpleStruct]].iterator iter = deref(
            self._cpp_obj).find(ckey)
        if iter == deref(self._cpp_obj).end():
            raise err
        cdef vector[cSimpleStruct] citem = deref(iter).second
        return List__SimpleStruct.create(
    make_shared[vector[cSimpleStruct]](citem))

    def __len__(self):
        return deref(self._cpp_obj).size()

    def __iter__(self):
        if not self:
            raise StopIteration
        cdef string citem
        for pair in deref(self._cpp_obj):
            citem = pair.first
            yield bytes(citem).decode('UTF-8')

    def __richcmp__(self, other, op):
        cdef int cop = op
        if cop not in (2, 3):
            raise TypeError("unorderable types: {}, {}".format(type(self), type(other)))
        if not (isinstance(self, Mapping) and isinstance(other, Mapping)):
            return cop != 2
        if (len(self) != len(other)):
            return cop != 2

        for key in self:
            if key not in other:
                return cop != 2
            if other[key] != self[key]:
                return cop != 2

        return cop == 2

    def __hash__(self):
        if not self.__hash:
            self.__hash = hash(tuple(self.items()))
        return self.__hash

    def __repr__(self):
        if not self:
            return 'i{}'
        return f'i{{{", ".join(map(lambda i: f"{repr(i[0])}: {repr(i[1])}", self.items()))}}}'

    def __contains__(self, key):
        if not self or key is None:
            return False
        if not isinstance(key, str):
            return False
        cdef string ckey = key.encode('UTF-8')
        return deref(self._cpp_obj).count(ckey) > 0

    def get(self, key, default=None):
        if not self or key is None:
            return default
        try:
            if not isinstance(key, str):
                key = str(key)
        except Exception:
            return default
        if not isinstance(key, str):
            return default
        if key not in self:
            return default
        return self[key]

    def keys(self):
        return self.__iter__()

    def values(self):
        if not self:
            raise StopIteration
        cdef vector[cSimpleStruct] citem
        for pair in deref(self._cpp_obj):
            citem = pair.second
            yield List__SimpleStruct.create(
    make_shared[vector[cSimpleStruct]](citem))

    def items(self):
        if not self:
            raise StopIteration
        cdef string ckey
        cdef vector[cSimpleStruct] citem
        for pair in deref(self._cpp_obj):
            ckey = pair.first
            citem = pair.second

            yield (ckey.decode('UTF-8'), List__SimpleStruct.create(
    make_shared[vector[cSimpleStruct]](citem)))



Mapping.register(Map__string_List__SimpleStruct)

cdef class List__List__string:
    def __init__(self, items=None):
        if isinstance(items, List__List__string):
            self._cpp_obj = (<List__List__string> items)._cpp_obj
        else:
            self._cpp_obj = move(List__List__string._make_instance(items))

    @staticmethod
    cdef create(shared_ptr[vector[vector[string]]] c_items):
        inst = <List__List__string>List__List__string.__new__(List__List__string)
        inst._cpp_obj = c_items
        return inst

    @staticmethod
    cdef unique_ptr[vector[vector[string]]] _make_instance(object items) except *:
        cdef unique_ptr[vector[vector[string]]] c_inst = make_unique[vector[vector[string]]]()
        if items is not None:
            for item in items:
                if item is None:
                    raise TypeError("None is not of the type _typing.Sequence[str]")
                if not isinstance(item, List__string):
                    item = List__string(item)
                deref(c_inst).push_back(vector[string](deref(List__string(item)._cpp_obj.get())))
        return move_unique(c_inst)

    def __add__(object self, object other):
        return type(self)(itertools.chain(self, other))

    def __getitem__(self, object index_obj):
        cdef shared_ptr[vector[vector[string]]] c_inst
        cdef vector[string] citem
        if isinstance(index_obj, slice):
            c_inst = make_shared[vector[vector[string]]]()
            sz = deref(self._cpp_obj).size()
            for index in range(*index_obj.indices(sz)):
                citem = deref(self._cpp_obj.get())[index]
                deref(c_inst).push_back(citem)
            return List__List__string.create(c_inst)
        else:
            index = <int?>index_obj
            size = len(self)
            # Convert a negative index
            if index < 0:
                index = size + index
            if index >= size or index < 0:
                raise IndexError('list index out of range')
            citem = deref(self._cpp_obj.get())[index]
            return List__string.create(
    make_shared[vector[string]](citem))

    def __len__(self):
        return deref(self._cpp_obj).size()

    def __richcmp__(self, other, op):
        cdef int cop = op
        if cop not in (2, 3):
            raise TypeError("unorderable types: {}, {}".format(type(self), type(other)))
        if not (isinstance(self, Iterable) and isinstance(other, Iterable)):
            return cop != 2
        if (len(self) != len(other)):
            return cop != 2

        for one, two in zip(self, other):
            if one != two:
                return cop != 2

        return cop == 2

    def __hash__(self):
        if not self.__hash:
            self.__hash = hash(tuple(self))
        return self.__hash

    def __contains__(self, item):
        if not self or item is None:
            return False
        try:
            if not isinstance(item, List__string):
                item = List__string(item)
        except Exception:
            return False
        if not isinstance(item, List__string):
            return False
        cdef vector[string] citem = vector[string](deref(List__string(item)._cpp_obj.get()))
        cdef vector[vector[string]] vec = deref(
            self._cpp_obj.get())
        return std_libcpp.find(vec.begin(), vec.end(), citem) != vec.end()

    def __iter__(self):
        if not self:
            raise StopIteration
        cdef vector[string] citem
        for citem in deref(self._cpp_obj):
            yield List__string.create(
    make_shared[vector[string]](citem))

    def __repr__(self):
        if not self:
            return 'i[]'
        return f'i[{", ".join(map(repr, self))}]'

    def __reversed__(self):
        if not self:
            raise StopIteration
        cdef vector[string] citem
        cdef vector[vector[string]] vec = deref(
            self._cpp_obj.get())
        cdef vector[vector[string]].reverse_iterator loc = vec.rbegin()
        while loc != vec.rend():
            citem = deref(loc)
            yield List__string.create(
    make_shared[vector[string]](citem))
            inc(loc)

    def index(self, item, start not None=__NOTSET, stop not None=__NOTSET):
        err = ValueError(f'{item} is not in list')
        if not self or item is None:
            raise err
        offset_begin = offset_end = 0
        if stop is not __NOTSET or start is not __NOTSET:
            # Like self[start:stop].index(item)
            size = len(self)
            stop = stop if stop is not __NOTSET else size
            start = start if start is not __NOTSET else 0
            # Convert stop to a negative position.
            if stop > 0:
                stop = min(stop - size, 0)
            if stop <= -size:
                raise err  # List would be empty
            offset_end = -stop
            # Convert start to always be positive
            if start < 0:
                start = max(size + start, 0)
            if start >= size:
                raise err  # past end of list
            offset_begin = start

        try:
            if not isinstance(item, List__string):
                item = List__string(item)
        except Exception:
            raise err from None
        if not isinstance(item, List__string):
            raise err
        cdef vector[string] citem = vector[string](deref(List__string(item)._cpp_obj.get()))
        cdef vector[vector[string]] vec = deref(self._cpp_obj.get())
        cdef vector[vector[string]].iterator end = std_libcpp.prev(vec.end(), <int64_t>offset_end)
        cdef vector[vector[string]].iterator loc = std_libcpp.find(
            std_libcpp.next(vec.begin(), <int64_t>offset_begin),
            end,
            citem
        )
        if loc != end:
            return <int64_t> std_libcpp.distance(vec.begin(), loc)
        raise err

    def count(self, item):
        if not self or item is None:
            return 0
        try:
            if not isinstance(item, List__string):
                item = List__string(item)
        except Exception:
            return 0
        if not isinstance(item, List__string):
            return 0
        cdef vector[string] citem = vector[string](deref(List__string(item)._cpp_obj.get()))
        cdef vector[vector[string]] vec = deref(self._cpp_obj.get())
        return <int64_t> std_libcpp.count(vec.begin(), vec.end(), citem)


Sequence.register(List__List__string)

cdef class List__Set__i32:
    def __init__(self, items=None):
        if isinstance(items, List__Set__i32):
            self._cpp_obj = (<List__Set__i32> items)._cpp_obj
        else:
            self._cpp_obj = move(List__Set__i32._make_instance(items))

    @staticmethod
    cdef create(shared_ptr[vector[cset[int32_t]]] c_items):
        inst = <List__Set__i32>List__Set__i32.__new__(List__Set__i32)
        inst._cpp_obj = c_items
        return inst

    @staticmethod
    cdef unique_ptr[vector[cset[int32_t]]] _make_instance(object items) except *:
        cdef unique_ptr[vector[cset[int32_t]]] c_inst = make_unique[vector[cset[int32_t]]]()
        if items is not None:
            for item in items:
                if item is None:
                    raise TypeError("None is not of the type _typing.AbstractSet[int]")
                if not isinstance(item, Set__i32):
                    item = Set__i32(item)
                deref(c_inst).push_back(cset[int32_t](deref(Set__i32(item)._cpp_obj.get())))
        return move_unique(c_inst)

    def __add__(object self, object other):
        return type(self)(itertools.chain(self, other))

    def __getitem__(self, object index_obj):
        cdef shared_ptr[vector[cset[int32_t]]] c_inst
        cdef cset[int32_t] citem
        if isinstance(index_obj, slice):
            c_inst = make_shared[vector[cset[int32_t]]]()
            sz = deref(self._cpp_obj).size()
            for index in range(*index_obj.indices(sz)):
                citem = deref(self._cpp_obj.get())[index]
                deref(c_inst).push_back(citem)
            return List__Set__i32.create(c_inst)
        else:
            index = <int?>index_obj
            size = len(self)
            # Convert a negative index
            if index < 0:
                index = size + index
            if index >= size or index < 0:
                raise IndexError('list index out of range')
            citem = deref(self._cpp_obj.get())[index]
            return Set__i32.create(
    make_shared[cset[int32_t]](citem))

    def __len__(self):
        return deref(self._cpp_obj).size()

    def __richcmp__(self, other, op):
        cdef int cop = op
        if cop not in (2, 3):
            raise TypeError("unorderable types: {}, {}".format(type(self), type(other)))
        if not (isinstance(self, Iterable) and isinstance(other, Iterable)):
            return cop != 2
        if (len(self) != len(other)):
            return cop != 2

        for one, two in zip(self, other):
            if one != two:
                return cop != 2

        return cop == 2

    def __hash__(self):
        if not self.__hash:
            self.__hash = hash(tuple(self))
        return self.__hash

    def __contains__(self, item):
        if not self or item is None:
            return False
        try:
            if not isinstance(item, Set__i32):
                item = Set__i32(item)
        except Exception:
            return False
        if not isinstance(item, Set__i32):
            return False
        cdef cset[int32_t] citem = cset[int32_t](deref(Set__i32(item)._cpp_obj.get()))
        cdef vector[cset[int32_t]] vec = deref(
            self._cpp_obj.get())
        return std_libcpp.find(vec.begin(), vec.end(), citem) != vec.end()

    def __iter__(self):
        if not self:
            raise StopIteration
        cdef cset[int32_t] citem
        for citem in deref(self._cpp_obj):
            yield Set__i32.create(
    make_shared[cset[int32_t]](citem))

    def __repr__(self):
        if not self:
            return 'i[]'
        return f'i[{", ".join(map(repr, self))}]'

    def __reversed__(self):
        if not self:
            raise StopIteration
        cdef cset[int32_t] citem
        cdef vector[cset[int32_t]] vec = deref(
            self._cpp_obj.get())
        cdef vector[cset[int32_t]].reverse_iterator loc = vec.rbegin()
        while loc != vec.rend():
            citem = deref(loc)
            yield Set__i32.create(
    make_shared[cset[int32_t]](citem))
            inc(loc)

    def index(self, item, start not None=__NOTSET, stop not None=__NOTSET):
        err = ValueError(f'{item} is not in list')
        if not self or item is None:
            raise err
        offset_begin = offset_end = 0
        if stop is not __NOTSET or start is not __NOTSET:
            # Like self[start:stop].index(item)
            size = len(self)
            stop = stop if stop is not __NOTSET else size
            start = start if start is not __NOTSET else 0
            # Convert stop to a negative position.
            if stop > 0:
                stop = min(stop - size, 0)
            if stop <= -size:
                raise err  # List would be empty
            offset_end = -stop
            # Convert start to always be positive
            if start < 0:
                start = max(size + start, 0)
            if start >= size:
                raise err  # past end of list
            offset_begin = start

        try:
            if not isinstance(item, Set__i32):
                item = Set__i32(item)
        except Exception:
            raise err from None
        if not isinstance(item, Set__i32):
            raise err
        cdef cset[int32_t] citem = cset[int32_t](deref(Set__i32(item)._cpp_obj.get()))
        cdef vector[cset[int32_t]] vec = deref(self._cpp_obj.get())
        cdef vector[cset[int32_t]].iterator end = std_libcpp.prev(vec.end(), <int64_t>offset_end)
        cdef vector[cset[int32_t]].iterator loc = std_libcpp.find(
            std_libcpp.next(vec.begin(), <int64_t>offset_begin),
            end,
            citem
        )
        if loc != end:
            return <int64_t> std_libcpp.distance(vec.begin(), loc)
        raise err

    def count(self, item):
        if not self or item is None:
            return 0
        try:
            if not isinstance(item, Set__i32):
                item = Set__i32(item)
        except Exception:
            return 0
        if not isinstance(item, Set__i32):
            return 0
        cdef cset[int32_t] citem = cset[int32_t](deref(Set__i32(item)._cpp_obj.get()))
        cdef vector[cset[int32_t]] vec = deref(self._cpp_obj.get())
        return <int64_t> std_libcpp.count(vec.begin(), vec.end(), citem)


Sequence.register(List__Set__i32)

cdef class List__Map__string_string:
    def __init__(self, items=None):
        if isinstance(items, List__Map__string_string):
            self._cpp_obj = (<List__Map__string_string> items)._cpp_obj
        else:
            self._cpp_obj = move(List__Map__string_string._make_instance(items))

    @staticmethod
    cdef create(shared_ptr[vector[cmap[string,string]]] c_items):
        inst = <List__Map__string_string>List__Map__string_string.__new__(List__Map__string_string)
        inst._cpp_obj = c_items
        return inst

    @staticmethod
    cdef unique_ptr[vector[cmap[string,string]]] _make_instance(object items) except *:
        cdef unique_ptr[vector[cmap[string,string]]] c_inst = make_unique[vector[cmap[string,string]]]()
        if items is not None:
            for item in items:
                if item is None:
                    raise TypeError("None is not of the type _typing.Mapping[str, str]")
                if not isinstance(item, Map__string_string):
                    item = Map__string_string(item)
                deref(c_inst).push_back(cmap[string,string](deref(Map__string_string(item)._cpp_obj.get())))
        return move_unique(c_inst)

    def __add__(object self, object other):
        return type(self)(itertools.chain(self, other))

    def __getitem__(self, object index_obj):
        cdef shared_ptr[vector[cmap[string,string]]] c_inst
        cdef cmap[string,string] citem
        if isinstance(index_obj, slice):
            c_inst = make_shared[vector[cmap[string,string]]]()
            sz = deref(self._cpp_obj).size()
            for index in range(*index_obj.indices(sz)):
                citem = deref(self._cpp_obj.get())[index]
                deref(c_inst).push_back(citem)
            return List__Map__string_string.create(c_inst)
        else:
            index = <int?>index_obj
            size = len(self)
            # Convert a negative index
            if index < 0:
                index = size + index
            if index >= size or index < 0:
                raise IndexError('list index out of range')
            citem = deref(self._cpp_obj.get())[index]
            return Map__string_string.create(
    make_shared[cmap[string,string]](citem))

    def __len__(self):
        return deref(self._cpp_obj).size()

    def __richcmp__(self, other, op):
        cdef int cop = op
        if cop not in (2, 3):
            raise TypeError("unorderable types: {}, {}".format(type(self), type(other)))
        if not (isinstance(self, Iterable) and isinstance(other, Iterable)):
            return cop != 2
        if (len(self) != len(other)):
            return cop != 2

        for one, two in zip(self, other):
            if one != two:
                return cop != 2

        return cop == 2

    def __hash__(self):
        if not self.__hash:
            self.__hash = hash(tuple(self))
        return self.__hash

    def __contains__(self, item):
        if not self or item is None:
            return False
        try:
            if not isinstance(item, Map__string_string):
                item = Map__string_string(item)
        except Exception:
            return False
        if not isinstance(item, Map__string_string):
            return False
        cdef cmap[string,string] citem = cmap[string,string](deref(Map__string_string(item)._cpp_obj.get()))
        cdef vector[cmap[string,string]] vec = deref(
            self._cpp_obj.get())
        return std_libcpp.find(vec.begin(), vec.end(), citem) != vec.end()

    def __iter__(self):
        if not self:
            raise StopIteration
        cdef cmap[string,string] citem
        for citem in deref(self._cpp_obj):
            yield Map__string_string.create(
    make_shared[cmap[string,string]](citem))

    def __repr__(self):
        if not self:
            return 'i[]'
        return f'i[{", ".join(map(repr, self))}]'

    def __reversed__(self):
        if not self:
            raise StopIteration
        cdef cmap[string,string] citem
        cdef vector[cmap[string,string]] vec = deref(
            self._cpp_obj.get())
        cdef vector[cmap[string,string]].reverse_iterator loc = vec.rbegin()
        while loc != vec.rend():
            citem = deref(loc)
            yield Map__string_string.create(
    make_shared[cmap[string,string]](citem))
            inc(loc)

    def index(self, item, start not None=__NOTSET, stop not None=__NOTSET):
        err = ValueError(f'{item} is not in list')
        if not self or item is None:
            raise err
        offset_begin = offset_end = 0
        if stop is not __NOTSET or start is not __NOTSET:
            # Like self[start:stop].index(item)
            size = len(self)
            stop = stop if stop is not __NOTSET else size
            start = start if start is not __NOTSET else 0
            # Convert stop to a negative position.
            if stop > 0:
                stop = min(stop - size, 0)
            if stop <= -size:
                raise err  # List would be empty
            offset_end = -stop
            # Convert start to always be positive
            if start < 0:
                start = max(size + start, 0)
            if start >= size:
                raise err  # past end of list
            offset_begin = start

        try:
            if not isinstance(item, Map__string_string):
                item = Map__string_string(item)
        except Exception:
            raise err from None
        if not isinstance(item, Map__string_string):
            raise err
        cdef cmap[string,string] citem = cmap[string,string](deref(Map__string_string(item)._cpp_obj.get()))
        cdef vector[cmap[string,string]] vec = deref(self._cpp_obj.get())
        cdef vector[cmap[string,string]].iterator end = std_libcpp.prev(vec.end(), <int64_t>offset_end)
        cdef vector[cmap[string,string]].iterator loc = std_libcpp.find(
            std_libcpp.next(vec.begin(), <int64_t>offset_begin),
            end,
            citem
        )
        if loc != end:
            return <int64_t> std_libcpp.distance(vec.begin(), loc)
        raise err

    def count(self, item):
        if not self or item is None:
            return 0
        try:
            if not isinstance(item, Map__string_string):
                item = Map__string_string(item)
        except Exception:
            return 0
        if not isinstance(item, Map__string_string):
            return 0
        cdef cmap[string,string] citem = cmap[string,string](deref(Map__string_string(item)._cpp_obj.get()))
        cdef vector[cmap[string,string]] vec = deref(self._cpp_obj.get())
        return <int64_t> std_libcpp.count(vec.begin(), vec.end(), citem)


Sequence.register(List__Map__string_string)

cdef class List__binary:
    def __init__(self, items=None):
        if isinstance(items, List__binary):
            self._cpp_obj = (<List__binary> items)._cpp_obj
        else:
            self._cpp_obj = move(List__binary._make_instance(items))

    @staticmethod
    cdef create(shared_ptr[vector[string]] c_items):
        inst = <List__binary>List__binary.__new__(List__binary)
        inst._cpp_obj = c_items
        return inst

    @staticmethod
    cdef unique_ptr[vector[string]] _make_instance(object items) except *:
        cdef unique_ptr[vector[string]] c_inst = make_unique[vector[string]]()
        if items is not None:
            for item in items:
                if not isinstance(item, bytes):
                    raise TypeError(f"{item!r} is not of type bytes")
                deref(c_inst).push_back(item)
        return move_unique(c_inst)

    def __add__(object self, object other):
        return type(self)(itertools.chain(self, other))

    def __getitem__(self, object index_obj):
        cdef shared_ptr[vector[string]] c_inst
        cdef string citem
        if isinstance(index_obj, slice):
            c_inst = make_shared[vector[string]]()
            sz = deref(self._cpp_obj).size()
            for index in range(*index_obj.indices(sz)):
                citem = deref(self._cpp_obj.get())[index]
                deref(c_inst).push_back(citem)
            return List__binary.create(c_inst)
        else:
            index = <int?>index_obj
            size = len(self)
            # Convert a negative index
            if index < 0:
                index = size + index
            if index >= size or index < 0:
                raise IndexError('list index out of range')
            citem = deref(self._cpp_obj.get())[index]
            return bytes(citem)

    def __len__(self):
        return deref(self._cpp_obj).size()

    def __richcmp__(self, other, op):
        cdef int cop = op
        if cop not in (2, 3):
            raise TypeError("unorderable types: {}, {}".format(type(self), type(other)))
        if not (isinstance(self, Iterable) and isinstance(other, Iterable)):
            return cop != 2
        if (len(self) != len(other)):
            return cop != 2

        for one, two in zip(self, other):
            if one != two:
                return cop != 2

        return cop == 2

    def __hash__(self):
        if not self.__hash:
            self.__hash = hash(tuple(self))
        return self.__hash

    def __contains__(self, item):
        if not self or item is None:
            return False
        if not isinstance(item, bytes):
            return False
        cdef string citem = item
        cdef vector[string] vec = deref(
            self._cpp_obj.get())
        return std_libcpp.find(vec.begin(), vec.end(), citem) != vec.end()

    def __iter__(self):
        if not self:
            raise StopIteration
        cdef string citem
        for citem in deref(self._cpp_obj):
            yield bytes(citem)

    def __repr__(self):
        if not self:
            return 'i[]'
        return f'i[{", ".join(map(repr, self))}]'

    def __reversed__(self):
        if not self:
            raise StopIteration
        cdef string citem
        cdef vector[string] vec = deref(
            self._cpp_obj.get())
        cdef vector[string].reverse_iterator loc = vec.rbegin()
        while loc != vec.rend():
            citem = deref(loc)
            yield bytes(citem)
            inc(loc)

    def index(self, item, start not None=__NOTSET, stop not None=__NOTSET):
        err = ValueError(f'{item} is not in list')
        if not self or item is None:
            raise err
        offset_begin = offset_end = 0
        if stop is not __NOTSET or start is not __NOTSET:
            # Like self[start:stop].index(item)
            size = len(self)
            stop = stop if stop is not __NOTSET else size
            start = start if start is not __NOTSET else 0
            # Convert stop to a negative position.
            if stop > 0:
                stop = min(stop - size, 0)
            if stop <= -size:
                raise err  # List would be empty
            offset_end = -stop
            # Convert start to always be positive
            if start < 0:
                start = max(size + start, 0)
            if start >= size:
                raise err  # past end of list
            offset_begin = start

        if not isinstance(item, bytes):
            raise err
        cdef string citem = item
        cdef vector[string] vec = deref(self._cpp_obj.get())
        cdef vector[string].iterator end = std_libcpp.prev(vec.end(), <int64_t>offset_end)
        cdef vector[string].iterator loc = std_libcpp.find(
            std_libcpp.next(vec.begin(), <int64_t>offset_begin),
            end,
            citem
        )
        if loc != end:
            return <int64_t> std_libcpp.distance(vec.begin(), loc)
        raise err

    def count(self, item):
        if not self or item is None:
            return 0
        if not isinstance(item, bytes):
            return 0
        cdef string citem = item
        cdef vector[string] vec = deref(self._cpp_obj.get())
        return <int64_t> std_libcpp.count(vec.begin(), vec.end(), citem)


Sequence.register(List__binary)

cdef class Set__binary:
    def __init__(self, items=None):
        if isinstance(items, Set__binary):
            self._cpp_obj = (<Set__binary> items)._cpp_obj
        else:
            self._cpp_obj = move(Set__binary._make_instance(items))

    @staticmethod
    cdef create(shared_ptr[cset[string]] c_items):
        inst = <Set__binary>Set__binary.__new__(Set__binary)
        inst._cpp_obj = c_items
        return inst

    @staticmethod
    cdef unique_ptr[cset[string]] _make_instance(object items) except *:
        cdef unique_ptr[cset[string]] c_inst = make_unique[cset[string]]()
        if items is not None:
            for item in items:
                if not isinstance(item, bytes):
                    raise TypeError(f"{item!r} is not of type bytes")
                deref(c_inst).insert(item)
        return move_unique(c_inst)

    def __contains__(self, item):
        if not self or item is None:
            return False
        if not isinstance(item, bytes):
            return False
        return pbool(deref(self._cpp_obj).count(item))


    def __len__(self):
        return deref(self._cpp_obj).size()

    def __iter__(self):
        if not self:
            raise StopIteration
        for citem in deref(self._cpp_obj):
            yield bytes(citem)

    def __repr__(self):
        if not self:
            return 'iset()'
        return f'i{{{", ".join(map(repr, self))}}}'

    def __richcmp__(self, other, op):
        cdef int cop = op
        cdef cset[string] cself, cother
        cdef cbool retval
        if (isinstance(self, Set__binary) and
                isinstance(other, Set__binary)):
            cself = deref((<Set__binary> self)._cpp_obj)
            cother = deref((<Set__binary> other)._cpp_obj)
            # C level comparisons
            if cop == 0:    # Less Than (strict subset)
                if not cself.size() < cother.size():
                    return False
                for item in cself:
                    if not cother.count(item):
                        return False
                return True
            elif cop == 1:  # Less Than or Equal To  (subset)
                for item in cself:
                    if not cother.count(item):
                        return False
                return True
            elif cop == 2:  # Equivalent
                if cself.size() != cother.size():
                    return False
                for item in cself:
                    if not cother.count(item):
                        return False
                return True
            elif cop == 3:  # Not Equivalent
                for item in cself:
                    if not cother.count(item):
                        return True
                return cself.size() != cother.size()
            elif cop == 4:  # Greater Than (strict superset)
                if not cself.size() > cother.size():
                    return False
                for item in cother:
                    if not cself.count(item):
                        return False
                return True
            elif cop == 5:  # Greater Than or Equal To (superset)
                for item in cother:
                    if not cself.count(item):
                        return False
                return True

        # Python level comparisons
        if cop == 0:
            return Set.__lt__(self, other)
        elif cop == 1:
            return Set.__le__(self, other)
        elif cop == 2:
            return Set.__eq__(self, other)
        elif cop == 3:
            return Set.__ne__(self, other)
        elif cop == 4:
            return Set.__gt__(self, other)
        elif cop == 5:
            return Set.__ge__(self, other)

    def __hash__(self):
        if not self.__hash:
            self.__hash = hash(tuple(self))
        return self.__hash

    def __and__(self, other):
        if not isinstance(self, Set__binary):
            self = Set__binary(self)
        if not isinstance(other, Set__binary):
            other = Set__binary(other)

        cdef shared_ptr[cset[string]] shretval = \
            make_shared[cset[string]]()
        for citem in deref((<Set__binary> self)._cpp_obj):
            if deref((<Set__binary> other)._cpp_obj).count(citem) > 0:
                deref(shretval).insert(citem)
        return Set__binary.create(shretval)

    def __sub__(self, other):
        if not isinstance(self, Set__binary):
            self = Set__binary(self)
        if not isinstance(other, Set__binary):
            other = Set__binary(other)

        cdef shared_ptr[cset[string]] shretval = \
            make_shared[cset[string]]()
        for citem in deref((<Set__binary> self)._cpp_obj):
            if deref((<Set__binary> other)._cpp_obj).count(citem) == 0:
                deref(shretval).insert(citem)
        return Set__binary.create(shretval)

    def __or__(self, other):
        if not isinstance(self, Set__binary):
            self = Set__binary(self)
        if not isinstance(other, Set__binary):
            other = Set__binary(other)

        cdef shared_ptr[cset[string]] shretval = \
            make_shared[cset[string]]()
        for citem in deref((<Set__binary> self)._cpp_obj):
                deref(shretval).insert(citem)
        for citem in deref((<Set__binary> other)._cpp_obj):
                deref(shretval).insert(citem)
        return Set__binary.create(shretval)

    def __xor__(self, other):
        if not isinstance(self, Set__binary):
            self = Set__binary(self)
        if not isinstance(other, Set__binary):
            other = Set__binary(other)

        cdef shared_ptr[cset[string]] shretval = \
            make_shared[cset[string]]()
        for citem in deref((<Set__binary> self)._cpp_obj):
            if deref((<Set__binary> other)._cpp_obj).count(citem) == 0:
                deref(shretval).insert(citem)
        for citem in deref((<Set__binary> other)._cpp_obj):
            if deref((<Set__binary> self)._cpp_obj).count(citem) == 0:
                deref(shretval).insert(citem)
        return Set__binary.create(shretval)

    def isdisjoint(self, other):
        return len(self & other) == 0

    def union(self, other):
        return self | other

    def intersection(self, other):
        return self & other

    def difference(self, other):
        return self - other

    def symmetric_difference(self, other):
        return self ^ other

    def issubset(self, other):
        return self <= other

    def issuperset(self, other):
        return self >= other


Set.register(Set__binary)

cdef class List__AnEnum:
    def __init__(self, items=None):
        if isinstance(items, List__AnEnum):
            self._cpp_obj = (<List__AnEnum> items)._cpp_obj
        else:
            self._cpp_obj = move(List__AnEnum._make_instance(items))

    @staticmethod
    cdef create(shared_ptr[vector[cAnEnum]] c_items):
        inst = <List__AnEnum>List__AnEnum.__new__(List__AnEnum)
        inst._cpp_obj = c_items
        return inst

    @staticmethod
    cdef unique_ptr[vector[cAnEnum]] _make_instance(object items) except *:
        cdef unique_ptr[vector[cAnEnum]] c_inst = make_unique[vector[cAnEnum]]()
        if items is not None:
            for item in items:
                if not isinstance(item, AnEnum):
                    raise TypeError(f"{item!r} is not of type AnEnum")
                deref(c_inst).push_back(AnEnum_to_cpp(item))
        return move_unique(c_inst)

    def __add__(object self, object other):
        return type(self)(itertools.chain(self, other))

    def __getitem__(self, object index_obj):
        cdef shared_ptr[vector[cAnEnum]] c_inst
        cdef cAnEnum citem
        if isinstance(index_obj, slice):
            c_inst = make_shared[vector[cAnEnum]]()
            sz = deref(self._cpp_obj).size()
            for index in range(*index_obj.indices(sz)):
                citem = deref(self._cpp_obj.get())[index]
                deref(c_inst).push_back(citem)
            return List__AnEnum.create(c_inst)
        else:
            index = <int?>index_obj
            size = len(self)
            # Convert a negative index
            if index < 0:
                index = size + index
            if index >= size or index < 0:
                raise IndexError('list index out of range')
            citem = deref(self._cpp_obj.get())[index]
            return translate_cpp_enum_to_python(AnEnum, <int> citem)

    def __len__(self):
        return deref(self._cpp_obj).size()

    def __richcmp__(self, other, op):
        cdef int cop = op
        if cop not in (2, 3):
            raise TypeError("unorderable types: {}, {}".format(type(self), type(other)))
        if not (isinstance(self, Iterable) and isinstance(other, Iterable)):
            return cop != 2
        if (len(self) != len(other)):
            return cop != 2

        for one, two in zip(self, other):
            if one != two:
                return cop != 2

        return cop == 2

    def __hash__(self):
        if not self.__hash:
            self.__hash = hash(tuple(self))
        return self.__hash

    def __contains__(self, item):
        if not self or item is None:
            return False
        if not isinstance(item, AnEnum):
            return False
        cdef cAnEnum citem = AnEnum_to_cpp(item)
        cdef vector[cAnEnum] vec = deref(
            self._cpp_obj.get())
        return std_libcpp.find(vec.begin(), vec.end(), citem) != vec.end()

    def __iter__(self):
        if not self:
            raise StopIteration
        cdef cAnEnum citem
        for citem in deref(self._cpp_obj):
            yield translate_cpp_enum_to_python(AnEnum, <int> citem)

    def __repr__(self):
        if not self:
            return 'i[]'
        return f'i[{", ".join(map(repr, self))}]'

    def __reversed__(self):
        if not self:
            raise StopIteration
        cdef cAnEnum citem
        cdef vector[cAnEnum] vec = deref(
            self._cpp_obj.get())
        cdef vector[cAnEnum].reverse_iterator loc = vec.rbegin()
        while loc != vec.rend():
            citem = deref(loc)
            yield translate_cpp_enum_to_python(AnEnum, <int> citem)
            inc(loc)

    def index(self, item, start not None=__NOTSET, stop not None=__NOTSET):
        err = ValueError(f'{item} is not in list')
        if not self or item is None:
            raise err
        offset_begin = offset_end = 0
        if stop is not __NOTSET or start is not __NOTSET:
            # Like self[start:stop].index(item)
            size = len(self)
            stop = stop if stop is not __NOTSET else size
            start = start if start is not __NOTSET else 0
            # Convert stop to a negative position.
            if stop > 0:
                stop = min(stop - size, 0)
            if stop <= -size:
                raise err  # List would be empty
            offset_end = -stop
            # Convert start to always be positive
            if start < 0:
                start = max(size + start, 0)
            if start >= size:
                raise err  # past end of list
            offset_begin = start

        if not isinstance(item, AnEnum):
            raise err
        cdef cAnEnum citem = AnEnum_to_cpp(item)
        cdef vector[cAnEnum] vec = deref(self._cpp_obj.get())
        cdef vector[cAnEnum].iterator end = std_libcpp.prev(vec.end(), <int64_t>offset_end)
        cdef vector[cAnEnum].iterator loc = std_libcpp.find(
            std_libcpp.next(vec.begin(), <int64_t>offset_begin),
            end,
            citem
        )
        if loc != end:
            return <int64_t> std_libcpp.distance(vec.begin(), loc)
        raise err

    def count(self, item):
        if not self or item is None:
            return 0
        if not isinstance(item, AnEnum):
            return 0
        cdef cAnEnum citem = AnEnum_to_cpp(item)
        cdef vector[cAnEnum] vec = deref(self._cpp_obj.get())
        return <int64_t> std_libcpp.count(vec.begin(), vec.end(), citem)


Sequence.register(List__AnEnum)

cdef class Map__i32_double:
    def __init__(self, items=None):
        if isinstance(items, Map__i32_double):
            self._cpp_obj = (<Map__i32_double> items)._cpp_obj
        else:
            self._cpp_obj = move(Map__i32_double._make_instance(items))

    @staticmethod
    cdef create(shared_ptr[cmap[int32_t,double]] c_items):
        inst = <Map__i32_double>Map__i32_double.__new__(Map__i32_double)
        inst._cpp_obj = c_items
        return inst

    @staticmethod
    cdef unique_ptr[cmap[int32_t,double]] _make_instance(object items) except *:
        cdef unique_ptr[cmap[int32_t,double]] c_inst = make_unique[cmap[int32_t,double]]()
        if items is not None:
            for key, item in items.items():
                if not isinstance(key, int):
                    raise TypeError(f"{key!r} is not of type int")
                key = <int32_t> key
                if not isinstance(item, (float, int)):
                    raise TypeError(f"{item!r} is not of type float")

                deref(c_inst).insert(cpair[int32_t,double](key,item))
        return move_unique(c_inst)

    def __getitem__(self, key):
        err = KeyError(f'{key}')
        if not self or key is None:
            raise err
        if not isinstance(key, int):
            raise err
        cdef int32_t ckey = key
        cdef cmap[int32_t,double].iterator iter = deref(
            self._cpp_obj).find(ckey)
        if iter == deref(self._cpp_obj).end():
            raise err
        cdef double citem = deref(iter).second
        return citem

    def __len__(self):
        return deref(self._cpp_obj).size()

    def __iter__(self):
        if not self:
            raise StopIteration
        cdef int32_t citem
        for pair in deref(self._cpp_obj):
            citem = pair.first
            yield citem

    def __richcmp__(self, other, op):
        cdef int cop = op
        if cop not in (2, 3):
            raise TypeError("unorderable types: {}, {}".format(type(self), type(other)))
        if not (isinstance(self, Mapping) and isinstance(other, Mapping)):
            return cop != 2
        if (len(self) != len(other)):
            return cop != 2

        for key in self:
            if key not in other:
                return cop != 2
            if other[key] != self[key]:
                return cop != 2

        return cop == 2

    def __hash__(self):
        if not self.__hash:
            self.__hash = hash(tuple(self.items()))
        return self.__hash

    def __repr__(self):
        if not self:
            return 'i{}'
        return f'i{{{", ".join(map(lambda i: f"{repr(i[0])}: {repr(i[1])}", self.items()))}}}'

    def __contains__(self, key):
        if not self or key is None:
            return False
        if not isinstance(key, int):
            return False
        cdef int32_t ckey = key
        return deref(self._cpp_obj).count(ckey) > 0

    def get(self, key, default=None):
        if not self or key is None:
            return default
        try:
            if not isinstance(key, int):
                key = int(key)
        except Exception:
            return default
        if not isinstance(key, int):
            return default
        if key not in self:
            return default
        return self[key]

    def keys(self):
        return self.__iter__()

    def values(self):
        if not self:
            raise StopIteration
        cdef double citem
        for pair in deref(self._cpp_obj):
            citem = pair.second
            yield citem

    def items(self):
        if not self:
            raise StopIteration
        cdef int32_t ckey
        cdef double citem
        for pair in deref(self._cpp_obj):
            ckey = pair.first
            citem = pair.second

            yield (ckey, citem)



Mapping.register(Map__i32_double)

cdef class List__Map__i32_double:
    def __init__(self, items=None):
        if isinstance(items, List__Map__i32_double):
            self._cpp_obj = (<List__Map__i32_double> items)._cpp_obj
        else:
            self._cpp_obj = move(List__Map__i32_double._make_instance(items))

    @staticmethod
    cdef create(shared_ptr[vector[cmap[int32_t,double]]] c_items):
        inst = <List__Map__i32_double>List__Map__i32_double.__new__(List__Map__i32_double)
        inst._cpp_obj = c_items
        return inst

    @staticmethod
    cdef unique_ptr[vector[cmap[int32_t,double]]] _make_instance(object items) except *:
        cdef unique_ptr[vector[cmap[int32_t,double]]] c_inst = make_unique[vector[cmap[int32_t,double]]]()
        if items is not None:
            for item in items:
                if item is None:
                    raise TypeError("None is not of the type _typing.Mapping[int, float]")
                if not isinstance(item, Map__i32_double):
                    item = Map__i32_double(item)
                deref(c_inst).push_back(cmap[int32_t,double](deref(Map__i32_double(item)._cpp_obj.get())))
        return move_unique(c_inst)

    def __add__(object self, object other):
        return type(self)(itertools.chain(self, other))

    def __getitem__(self, object index_obj):
        cdef shared_ptr[vector[cmap[int32_t,double]]] c_inst
        cdef cmap[int32_t,double] citem
        if isinstance(index_obj, slice):
            c_inst = make_shared[vector[cmap[int32_t,double]]]()
            sz = deref(self._cpp_obj).size()
            for index in range(*index_obj.indices(sz)):
                citem = deref(self._cpp_obj.get())[index]
                deref(c_inst).push_back(citem)
            return List__Map__i32_double.create(c_inst)
        else:
            index = <int?>index_obj
            size = len(self)
            # Convert a negative index
            if index < 0:
                index = size + index
            if index >= size or index < 0:
                raise IndexError('list index out of range')
            citem = deref(self._cpp_obj.get())[index]
            return Map__i32_double.create(
    make_shared[cmap[int32_t,double]](citem))

    def __len__(self):
        return deref(self._cpp_obj).size()

    def __richcmp__(self, other, op):
        cdef int cop = op
        if cop not in (2, 3):
            raise TypeError("unorderable types: {}, {}".format(type(self), type(other)))
        if not (isinstance(self, Iterable) and isinstance(other, Iterable)):
            return cop != 2
        if (len(self) != len(other)):
            return cop != 2

        for one, two in zip(self, other):
            if one != two:
                return cop != 2

        return cop == 2

    def __hash__(self):
        if not self.__hash:
            self.__hash = hash(tuple(self))
        return self.__hash

    def __contains__(self, item):
        if not self or item is None:
            return False
        try:
            if not isinstance(item, Map__i32_double):
                item = Map__i32_double(item)
        except Exception:
            return False
        if not isinstance(item, Map__i32_double):
            return False
        cdef cmap[int32_t,double] citem = cmap[int32_t,double](deref(Map__i32_double(item)._cpp_obj.get()))
        cdef vector[cmap[int32_t,double]] vec = deref(
            self._cpp_obj.get())
        return std_libcpp.find(vec.begin(), vec.end(), citem) != vec.end()

    def __iter__(self):
        if not self:
            raise StopIteration
        cdef cmap[int32_t,double] citem
        for citem in deref(self._cpp_obj):
            yield Map__i32_double.create(
    make_shared[cmap[int32_t,double]](citem))

    def __repr__(self):
        if not self:
            return 'i[]'
        return f'i[{", ".join(map(repr, self))}]'

    def __reversed__(self):
        if not self:
            raise StopIteration
        cdef cmap[int32_t,double] citem
        cdef vector[cmap[int32_t,double]] vec = deref(
            self._cpp_obj.get())
        cdef vector[cmap[int32_t,double]].reverse_iterator loc = vec.rbegin()
        while loc != vec.rend():
            citem = deref(loc)
            yield Map__i32_double.create(
    make_shared[cmap[int32_t,double]](citem))
            inc(loc)

    def index(self, item, start not None=__NOTSET, stop not None=__NOTSET):
        err = ValueError(f'{item} is not in list')
        if not self or item is None:
            raise err
        offset_begin = offset_end = 0
        if stop is not __NOTSET or start is not __NOTSET:
            # Like self[start:stop].index(item)
            size = len(self)
            stop = stop if stop is not __NOTSET else size
            start = start if start is not __NOTSET else 0
            # Convert stop to a negative position.
            if stop > 0:
                stop = min(stop - size, 0)
            if stop <= -size:
                raise err  # List would be empty
            offset_end = -stop
            # Convert start to always be positive
            if start < 0:
                start = max(size + start, 0)
            if start >= size:
                raise err  # past end of list
            offset_begin = start

        try:
            if not isinstance(item, Map__i32_double):
                item = Map__i32_double(item)
        except Exception:
            raise err from None
        if not isinstance(item, Map__i32_double):
            raise err
        cdef cmap[int32_t,double] citem = cmap[int32_t,double](deref(Map__i32_double(item)._cpp_obj.get()))
        cdef vector[cmap[int32_t,double]] vec = deref(self._cpp_obj.get())
        cdef vector[cmap[int32_t,double]].iterator end = std_libcpp.prev(vec.end(), <int64_t>offset_end)
        cdef vector[cmap[int32_t,double]].iterator loc = std_libcpp.find(
            std_libcpp.next(vec.begin(), <int64_t>offset_begin),
            end,
            citem
        )
        if loc != end:
            return <int64_t> std_libcpp.distance(vec.begin(), loc)
        raise err

    def count(self, item):
        if not self or item is None:
            return 0
        try:
            if not isinstance(item, Map__i32_double):
                item = Map__i32_double(item)
        except Exception:
            return 0
        if not isinstance(item, Map__i32_double):
            return 0
        cdef cmap[int32_t,double] citem = cmap[int32_t,double](deref(Map__i32_double(item)._cpp_obj.get()))
        cdef vector[cmap[int32_t,double]] vec = deref(self._cpp_obj.get())
        return <int64_t> std_libcpp.count(vec.begin(), vec.end(), citem)


Sequence.register(List__Map__i32_double)

A_BOOL = True
A_BYTE = 8
THE_ANSWER = 42
A_NUMBER = 84
A_BIG_NUMBER = 102
A_REAL_NUMBER = 3.14
A_FAKE_NUMBER = 3.0
A_WORD = cA_WORD().decode('UTF-8')
SOME_BYTES = <bytes> cSOME_BYTES()
A_STRUCT = SimpleStruct.create(make_shared[cSimpleStruct](cA_STRUCT()))
WORD_LIST = List__string.create(make_shared[vector[string]](cWORD_LIST()))
SOME_MAP = List__Map__i32_double.create(make_shared[vector[cmap[int32_t,double]]](cSOME_MAP()))
DIGITS = Set__i32.create(make_shared[cset[int32_t]](cDIGITS()))
A_CONST_MAP = Map__string_SimpleStruct.create(make_shared[cmap[string,cSimpleStruct]](cA_CONST_MAP()))
