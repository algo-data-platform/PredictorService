#
# Autogenerated by Thrift
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#  @generated
#

from __future__ import absolute_import
import six
from thrift.util.Recursive import fix_spec
from thrift.Thrift import *
from thrift.protocol.TProtocol import TProtocolException

from json import loads
import sys
if sys.version_info[0] >= 3:
  long = int


import pprint
import warnings
from thrift import Thrift
from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol
from thrift.protocol import TCompactProtocol
from thrift.protocol import THeaderProtocol
fastproto = None
if not '__pypy__' in sys.builtin_module_names:
  try:
    from thrift.protocol import fastproto
  except:
    pass
all_structs = []
UTF8STRINGS = bool(0) or sys.version_info.major >= 3

__all__ = ['UTF8STRINGS', 'MyEnum', 'MyStruct', 'MyDataItem']

class MyEnum:
  MyValue1 = 0
  MyValue2 = 1

  _VALUES_TO_NAMES = {
    0: "MyValue1",
    1: "MyValue2",
  }

  _NAMES_TO_VALUES = {
    "MyValue1": 0,
    "MyValue2": 1,
  }

class MyStruct:
  """
  Attributes:
   - MyIntField
   - MyStringField
   - MyDataField
   - major
   - myEnum
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.MyIntField = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.MyStringField = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.MyDataField = MyDataItem()
          self.MyDataField.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I64:
          self.major = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.myEnum = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('MyStruct')
    if self.MyIntField != None:
      oprot.writeFieldBegin('MyIntField', TType.I64, 1)
      oprot.writeI64(self.MyIntField)
      oprot.writeFieldEnd()
    if self.MyStringField != None:
      oprot.writeFieldBegin('MyStringField', TType.STRING, 2)
      oprot.writeString(self.MyStringField.encode('utf-8')) if UTF8STRINGS and not isinstance(self.MyStringField, bytes) else oprot.writeString(self.MyStringField)
      oprot.writeFieldEnd()
    if self.MyDataField != None:
      oprot.writeFieldBegin('MyDataField', TType.STRUCT, 3)
      self.MyDataField.write(oprot)
      oprot.writeFieldEnd()
    if self.major != None:
      oprot.writeFieldBegin('major', TType.I64, 4)
      oprot.writeI64(self.major)
      oprot.writeFieldEnd()
    if self.myEnum != None:
      oprot.writeFieldBegin('myEnum', TType.I32, 5)
      oprot.writeI32(self.myEnum)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True):
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'MyIntField' in json_obj and json_obj['MyIntField'] is not None:
      self.MyIntField = long(json_obj['MyIntField'])
    if 'MyStringField' in json_obj and json_obj['MyStringField'] is not None:
      self.MyStringField = json_obj['MyStringField']
    if 'MyDataField' in json_obj and json_obj['MyDataField'] is not None:
      self.MyDataField = MyDataItem()
      self.MyDataField.readFromJson(json_obj['MyDataField'], is_text=False)
    if 'major' in json_obj and json_obj['major'] is not None:
      self.major = long(json_obj['major'])
    if 'myEnum' in json_obj and json_obj['myEnum'] is not None:
      self.myEnum = json_obj['myEnum']
      if not self.myEnum in MyEnum._VALUES_TO_NAMES:
        raise TProtocolException(TProtocolException.INVALID_DATA, 'Integer value ''%s'' is not a recognized value of enum type MyEnum' % self.myEnum)

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.MyIntField is not None:
      value = pprint.pformat(self.MyIntField, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    MyIntField=%s' % (value))
    if self.MyStringField is not None:
      value = pprint.pformat(self.MyStringField, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    MyStringField=%s' % (value))
    if self.MyDataField is not None:
      value = pprint.pformat(self.MyDataField, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    MyDataField=%s' % (value))
    if self.major is not None:
      value = pprint.pformat(self.major, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    major=%s' % (value))
    if self.myEnum is not None:
      value = pprint.pformat(self.myEnum, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    myEnum=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class MyDataItem:

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('MyDataItem')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True):
    json_obj = json
    if is_text:
      json_obj = loads(json)

  def __repr__(self):
    L = []
    padding = ' ' * 4
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

all_structs.append(MyStruct)
MyStruct.thrift_spec = (
  None, # 0
  (1, TType.I64, 'MyIntField', None, None, 2, ), # 1
  (2, TType.STRING, 'MyStringField', True, None, 2, ), # 2
  (3, TType.STRUCT, 'MyDataField', [MyDataItem, MyDataItem.thrift_spec, False], None, 2, ), # 3
  (4, TType.I64, 'major', None, None, 2, ), # 4
  (5, TType.I32, 'myEnum', MyEnum, None, 2, ), # 5
)

MyStruct.thrift_struct_annotations = {
}
MyStruct.thrift_field_annotations = {
}

def MyStruct__init__(self, MyIntField=None, MyStringField=None, MyDataField=None, major=None, myEnum=None,):
  self.MyIntField = MyIntField
  self.MyStringField = MyStringField
  self.MyDataField = MyDataField
  self.major = major
  self.myEnum = myEnum

MyStruct.__init__ = MyStruct__init__

def MyStruct__setstate__(self, state):
  state.setdefault('MyIntField', None)
  state.setdefault('MyStringField', None)
  state.setdefault('MyDataField', None)
  state.setdefault('major', None)
  state.setdefault('myEnum', None)
  self.__dict__ = state

MyStruct.__getstate__ = lambda self: self.__dict__.copy()
MyStruct.__setstate__ = MyStruct__setstate__

all_structs.append(MyDataItem)
MyDataItem.thrift_spec = (
)

MyDataItem.thrift_struct_annotations = {
}
MyDataItem.thrift_field_annotations = {
}

fix_spec(all_structs)
del all_structs
