/**
 * Autogenerated by Thrift
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */

#include "src/gen-cpp2/ServiceAAsyncClient.h"

#include <folly/io/IOBuf.h>
#include <folly/io/IOBufQueue.h>
#include <thrift/lib/cpp/TApplicationException.h>
#include <thrift/lib/cpp/transport/THeader.h>
#include <thrift/lib/cpp2/protocol/BinaryProtocol.h>
#include <thrift/lib/cpp2/protocol/CompactProtocol.h>
#include <thrift/lib/cpp2/protocol/Frozen2Protocol.h>
#include <thrift/lib/cpp2/server/Cpp2ConnContext.h>
#include <thrift/lib/cpp2/GeneratedCodeHelper.h>
#include <thrift/lib/cpp2/GeneratedSerializationCodeHelper.h>

namespace some { namespace ns {
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, apache::thrift::protocol::T_STRUCT,  ::some::ns::ModuleA*>> ServiceA_moduleAMethod_pargs;
typedef apache::thrift::ThriftPresult<true> ServiceA_moduleAMethod_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, apache::thrift::protocol::T_STRUCT,  ::some::ns::ModuleB*>> ServiceA_moduleBMethod_pargs;
typedef apache::thrift::ThriftPresult<true> ServiceA_moduleBMethod_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, apache::thrift::protocol::T_I32, int32_t*>, apache::thrift::FieldData<2, apache::thrift::protocol::T_STRING, std::string*>, apache::thrift::FieldData<3, apache::thrift::protocol::T_DOUBLE, double*>> ServiceA_i32StrDoubleMethod_pargs;
typedef apache::thrift::ThriftPresult<true> ServiceA_i32StrDoubleMethod_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, apache::thrift::protocol::T_I32, int32_t*>, apache::thrift::FieldData<5, apache::thrift::protocol::T_STRING, std::string*>, apache::thrift::FieldData<7, apache::thrift::protocol::T_DOUBLE, double*>> ServiceA_versioningMethod_pargs;
typedef apache::thrift::ThriftPresult<true> ServiceA_versioningMethod_presult;
typedef apache::thrift::ThriftPresult<false> ServiceA_retI32Method_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, apache::thrift::protocol::T_I32, int32_t*>> ServiceA_retI32Method_presult;
typedef apache::thrift::ThriftPresult<false> ServiceA_retModAMethod_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, apache::thrift::protocol::T_STRUCT,  ::some::ns::ModuleA*>> ServiceA_retModAMethod_presult;
typedef apache::thrift::ThriftPresult<false> ServiceA_throwMethod_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<1, apache::thrift::protocol::T_STRUCT,  ::some::ns::ExceptionA>> ServiceA_throwMethod_presult;
typedef apache::thrift::ThriftPresult<false> ServiceA_multiThrowMethod_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<1, apache::thrift::protocol::T_STRUCT,  ::some::ns::ExceptionA>, apache::thrift::FieldData<2, apache::thrift::protocol::T_STRUCT,  ::some::ns::ExceptionB>> ServiceA_multiThrowMethod_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, apache::thrift::protocol::T_I32, int32_t*>> ServiceA_i32ThrowMethod_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<1, apache::thrift::protocol::T_STRUCT,  ::some::ns::ExceptionA>> ServiceA_i32ThrowMethod_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, apache::thrift::protocol::T_STRUCT,  ::some::ns::ModuleA*>> ServiceA_moduleAThrowMethod_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<1, apache::thrift::protocol::T_STRUCT,  ::some::ns::ExceptionA>> ServiceA_moduleAThrowMethod_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, apache::thrift::protocol::T_STRING, std::string*>, apache::thrift::FieldData<3, apache::thrift::protocol::T_I32, int32_t*>, apache::thrift::FieldData<6, apache::thrift::protocol::T_STRUCT,  ::some::ns::ModuleB*>> ServiceA_mixedMethod_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, apache::thrift::protocol::T_STRING, std::string*>, apache::thrift::FieldData<1, apache::thrift::protocol::T_STRUCT,  ::some::ns::ExceptionA>, apache::thrift::FieldData<2, apache::thrift::protocol::T_STRUCT,  ::some::ns::ExceptionB>> ServiceA_mixedMethod_presult;

template <typename Protocol_>
void ServiceAAsyncClient::moduleAMethodT(Protocol_* prot, bool useSync, apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::some::ns::ModuleA& modArg) {
  struct HeaderAndConnContext {
    HeaderAndConnContext() : header(apache::thrift::transport::THeader::ALLOW_BIG_FRAMES) {}

    apache::thrift::transport::THeader header;
    apache::thrift::Cpp2ConnContext connContext;
  };
  auto headerAndConnContext = std::make_shared<HeaderAndConnContext>();
  std::shared_ptr<apache::thrift::transport::THeader> header(headerAndConnContext, &headerAndConnContext->header);
  header->setProtocolId(getChannel()->getProtocolId());
  header->setHeaders(rpcOptions.releaseWriteHeaders());
  headerAndConnContext->connContext.setRequestHeader(header.get());
  std::unique_ptr<apache::thrift::ContextStack> ctx = this->getContextStack(this->getServiceName(), "ServiceA.moduleAMethod", &headerAndConnContext->connContext);
  ServiceA_moduleAMethod_pargs args;
  args.get<0>().value = const_cast< ::some::ns::ModuleA*>(&modArg);
  auto sizer = [&](Protocol_* p) { return ::apache::thrift::detail::serializedResponseBodySizeZC(p, &args); };
  auto writer = [&](Protocol_* p) { ::apache::thrift::detail::serializeResponseBody(p, &args); };
  apache::thrift::clientSendT<Protocol_>(prot, rpcOptions, std::move(callback), std::move(ctx), header, channel_.get(), "moduleAMethod", writer, sizer, apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, useSync);
  headerAndConnContext->connContext.setRequestHeader(nullptr);
}

template <typename Protocol_>
void ServiceAAsyncClient::moduleBMethodT(Protocol_* prot, bool useSync, apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::some::ns::ModuleB& modArg) {
  struct HeaderAndConnContext {
    HeaderAndConnContext() : header(apache::thrift::transport::THeader::ALLOW_BIG_FRAMES) {}

    apache::thrift::transport::THeader header;
    apache::thrift::Cpp2ConnContext connContext;
  };
  auto headerAndConnContext = std::make_shared<HeaderAndConnContext>();
  std::shared_ptr<apache::thrift::transport::THeader> header(headerAndConnContext, &headerAndConnContext->header);
  header->setProtocolId(getChannel()->getProtocolId());
  header->setHeaders(rpcOptions.releaseWriteHeaders());
  headerAndConnContext->connContext.setRequestHeader(header.get());
  std::unique_ptr<apache::thrift::ContextStack> ctx = this->getContextStack(this->getServiceName(), "ServiceA.moduleBMethod", &headerAndConnContext->connContext);
  ServiceA_moduleBMethod_pargs args;
  args.get<0>().value = const_cast< ::some::ns::ModuleB*>(&modArg);
  auto sizer = [&](Protocol_* p) { return ::apache::thrift::detail::serializedResponseBodySizeZC(p, &args); };
  auto writer = [&](Protocol_* p) { ::apache::thrift::detail::serializeResponseBody(p, &args); };
  apache::thrift::clientSendT<Protocol_>(prot, rpcOptions, std::move(callback), std::move(ctx), header, channel_.get(), "moduleBMethod", writer, sizer, apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, useSync);
  headerAndConnContext->connContext.setRequestHeader(nullptr);
}

template <typename Protocol_>
void ServiceAAsyncClient::i32StrDoubleMethodT(Protocol_* prot, bool useSync, apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, int32_t i32Arg, const std::string& strArg, double doubleArg) {
  struct HeaderAndConnContext {
    HeaderAndConnContext() : header(apache::thrift::transport::THeader::ALLOW_BIG_FRAMES) {}

    apache::thrift::transport::THeader header;
    apache::thrift::Cpp2ConnContext connContext;
  };
  auto headerAndConnContext = std::make_shared<HeaderAndConnContext>();
  std::shared_ptr<apache::thrift::transport::THeader> header(headerAndConnContext, &headerAndConnContext->header);
  header->setProtocolId(getChannel()->getProtocolId());
  header->setHeaders(rpcOptions.releaseWriteHeaders());
  headerAndConnContext->connContext.setRequestHeader(header.get());
  std::unique_ptr<apache::thrift::ContextStack> ctx = this->getContextStack(this->getServiceName(), "ServiceA.i32StrDoubleMethod", &headerAndConnContext->connContext);
  ServiceA_i32StrDoubleMethod_pargs args;
  args.get<0>().value = &i32Arg;
  args.get<1>().value = const_cast<std::string*>(&strArg);
  args.get<2>().value = &doubleArg;
  auto sizer = [&](Protocol_* p) { return ::apache::thrift::detail::serializedResponseBodySizeZC(p, &args); };
  auto writer = [&](Protocol_* p) { ::apache::thrift::detail::serializeResponseBody(p, &args); };
  apache::thrift::clientSendT<Protocol_>(prot, rpcOptions, std::move(callback), std::move(ctx), header, channel_.get(), "i32StrDoubleMethod", writer, sizer, apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, useSync);
  headerAndConnContext->connContext.setRequestHeader(nullptr);
}

template <typename Protocol_>
void ServiceAAsyncClient::versioningMethodT(Protocol_* prot, bool useSync, apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, int32_t i32Arg, const std::string& strArg, double doubleArg) {
  struct HeaderAndConnContext {
    HeaderAndConnContext() : header(apache::thrift::transport::THeader::ALLOW_BIG_FRAMES) {}

    apache::thrift::transport::THeader header;
    apache::thrift::Cpp2ConnContext connContext;
  };
  auto headerAndConnContext = std::make_shared<HeaderAndConnContext>();
  std::shared_ptr<apache::thrift::transport::THeader> header(headerAndConnContext, &headerAndConnContext->header);
  header->setProtocolId(getChannel()->getProtocolId());
  header->setHeaders(rpcOptions.releaseWriteHeaders());
  headerAndConnContext->connContext.setRequestHeader(header.get());
  std::unique_ptr<apache::thrift::ContextStack> ctx = this->getContextStack(this->getServiceName(), "ServiceA.versioningMethod", &headerAndConnContext->connContext);
  ServiceA_versioningMethod_pargs args;
  args.get<0>().value = &i32Arg;
  args.get<1>().value = const_cast<std::string*>(&strArg);
  args.get<2>().value = &doubleArg;
  auto sizer = [&](Protocol_* p) { return ::apache::thrift::detail::serializedResponseBodySizeZC(p, &args); };
  auto writer = [&](Protocol_* p) { ::apache::thrift::detail::serializeResponseBody(p, &args); };
  apache::thrift::clientSendT<Protocol_>(prot, rpcOptions, std::move(callback), std::move(ctx), header, channel_.get(), "versioningMethod", writer, sizer, apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, useSync);
  headerAndConnContext->connContext.setRequestHeader(nullptr);
}

template <typename Protocol_>
void ServiceAAsyncClient::retI32MethodT(Protocol_* prot, bool useSync, apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback) {
  struct HeaderAndConnContext {
    HeaderAndConnContext() : header(apache::thrift::transport::THeader::ALLOW_BIG_FRAMES) {}

    apache::thrift::transport::THeader header;
    apache::thrift::Cpp2ConnContext connContext;
  };
  auto headerAndConnContext = std::make_shared<HeaderAndConnContext>();
  std::shared_ptr<apache::thrift::transport::THeader> header(headerAndConnContext, &headerAndConnContext->header);
  header->setProtocolId(getChannel()->getProtocolId());
  header->setHeaders(rpcOptions.releaseWriteHeaders());
  headerAndConnContext->connContext.setRequestHeader(header.get());
  std::unique_ptr<apache::thrift::ContextStack> ctx = this->getContextStack(this->getServiceName(), "ServiceA.retI32Method", &headerAndConnContext->connContext);
  ServiceA_retI32Method_pargs args;
  auto sizer = [&](Protocol_* p) { return ::apache::thrift::detail::serializedResponseBodySizeZC(p, &args); };
  auto writer = [&](Protocol_* p) { ::apache::thrift::detail::serializeResponseBody(p, &args); };
  apache::thrift::clientSendT<Protocol_>(prot, rpcOptions, std::move(callback), std::move(ctx), header, channel_.get(), "retI32Method", writer, sizer, apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, useSync);
  headerAndConnContext->connContext.setRequestHeader(nullptr);
}

template <typename Protocol_>
void ServiceAAsyncClient::retModAMethodT(Protocol_* prot, bool useSync, apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback) {
  struct HeaderAndConnContext {
    HeaderAndConnContext() : header(apache::thrift::transport::THeader::ALLOW_BIG_FRAMES) {}

    apache::thrift::transport::THeader header;
    apache::thrift::Cpp2ConnContext connContext;
  };
  auto headerAndConnContext = std::make_shared<HeaderAndConnContext>();
  std::shared_ptr<apache::thrift::transport::THeader> header(headerAndConnContext, &headerAndConnContext->header);
  header->setProtocolId(getChannel()->getProtocolId());
  header->setHeaders(rpcOptions.releaseWriteHeaders());
  headerAndConnContext->connContext.setRequestHeader(header.get());
  std::unique_ptr<apache::thrift::ContextStack> ctx = this->getContextStack(this->getServiceName(), "ServiceA.retModAMethod", &headerAndConnContext->connContext);
  ServiceA_retModAMethod_pargs args;
  auto sizer = [&](Protocol_* p) { return ::apache::thrift::detail::serializedResponseBodySizeZC(p, &args); };
  auto writer = [&](Protocol_* p) { ::apache::thrift::detail::serializeResponseBody(p, &args); };
  apache::thrift::clientSendT<Protocol_>(prot, rpcOptions, std::move(callback), std::move(ctx), header, channel_.get(), "retModAMethod", writer, sizer, apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, useSync);
  headerAndConnContext->connContext.setRequestHeader(nullptr);
}

template <typename Protocol_>
void ServiceAAsyncClient::throwMethodT(Protocol_* prot, bool useSync, apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback) {
  struct HeaderAndConnContext {
    HeaderAndConnContext() : header(apache::thrift::transport::THeader::ALLOW_BIG_FRAMES) {}

    apache::thrift::transport::THeader header;
    apache::thrift::Cpp2ConnContext connContext;
  };
  auto headerAndConnContext = std::make_shared<HeaderAndConnContext>();
  std::shared_ptr<apache::thrift::transport::THeader> header(headerAndConnContext, &headerAndConnContext->header);
  header->setProtocolId(getChannel()->getProtocolId());
  header->setHeaders(rpcOptions.releaseWriteHeaders());
  headerAndConnContext->connContext.setRequestHeader(header.get());
  std::unique_ptr<apache::thrift::ContextStack> ctx = this->getContextStack(this->getServiceName(), "ServiceA.throwMethod", &headerAndConnContext->connContext);
  ServiceA_throwMethod_pargs args;
  auto sizer = [&](Protocol_* p) { return ::apache::thrift::detail::serializedResponseBodySizeZC(p, &args); };
  auto writer = [&](Protocol_* p) { ::apache::thrift::detail::serializeResponseBody(p, &args); };
  apache::thrift::clientSendT<Protocol_>(prot, rpcOptions, std::move(callback), std::move(ctx), header, channel_.get(), "throwMethod", writer, sizer, apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, useSync);
  headerAndConnContext->connContext.setRequestHeader(nullptr);
}

template <typename Protocol_>
void ServiceAAsyncClient::multiThrowMethodT(Protocol_* prot, bool useSync, apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback) {
  struct HeaderAndConnContext {
    HeaderAndConnContext() : header(apache::thrift::transport::THeader::ALLOW_BIG_FRAMES) {}

    apache::thrift::transport::THeader header;
    apache::thrift::Cpp2ConnContext connContext;
  };
  auto headerAndConnContext = std::make_shared<HeaderAndConnContext>();
  std::shared_ptr<apache::thrift::transport::THeader> header(headerAndConnContext, &headerAndConnContext->header);
  header->setProtocolId(getChannel()->getProtocolId());
  header->setHeaders(rpcOptions.releaseWriteHeaders());
  headerAndConnContext->connContext.setRequestHeader(header.get());
  std::unique_ptr<apache::thrift::ContextStack> ctx = this->getContextStack(this->getServiceName(), "ServiceA.multiThrowMethod", &headerAndConnContext->connContext);
  ServiceA_multiThrowMethod_pargs args;
  auto sizer = [&](Protocol_* p) { return ::apache::thrift::detail::serializedResponseBodySizeZC(p, &args); };
  auto writer = [&](Protocol_* p) { ::apache::thrift::detail::serializeResponseBody(p, &args); };
  apache::thrift::clientSendT<Protocol_>(prot, rpcOptions, std::move(callback), std::move(ctx), header, channel_.get(), "multiThrowMethod", writer, sizer, apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, useSync);
  headerAndConnContext->connContext.setRequestHeader(nullptr);
}

template <typename Protocol_>
void ServiceAAsyncClient::i32ThrowMethodT(Protocol_* prot, bool useSync, apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, int32_t i32Arg) {
  struct HeaderAndConnContext {
    HeaderAndConnContext() : header(apache::thrift::transport::THeader::ALLOW_BIG_FRAMES) {}

    apache::thrift::transport::THeader header;
    apache::thrift::Cpp2ConnContext connContext;
  };
  auto headerAndConnContext = std::make_shared<HeaderAndConnContext>();
  std::shared_ptr<apache::thrift::transport::THeader> header(headerAndConnContext, &headerAndConnContext->header);
  header->setProtocolId(getChannel()->getProtocolId());
  header->setHeaders(rpcOptions.releaseWriteHeaders());
  headerAndConnContext->connContext.setRequestHeader(header.get());
  std::unique_ptr<apache::thrift::ContextStack> ctx = this->getContextStack(this->getServiceName(), "ServiceA.i32ThrowMethod", &headerAndConnContext->connContext);
  ServiceA_i32ThrowMethod_pargs args;
  args.get<0>().value = &i32Arg;
  auto sizer = [&](Protocol_* p) { return ::apache::thrift::detail::serializedResponseBodySizeZC(p, &args); };
  auto writer = [&](Protocol_* p) { ::apache::thrift::detail::serializeResponseBody(p, &args); };
  apache::thrift::clientSendT<Protocol_>(prot, rpcOptions, std::move(callback), std::move(ctx), header, channel_.get(), "i32ThrowMethod", writer, sizer, apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, useSync);
  headerAndConnContext->connContext.setRequestHeader(nullptr);
}

template <typename Protocol_>
void ServiceAAsyncClient::moduleAThrowMethodT(Protocol_* prot, bool useSync, apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::some::ns::ModuleA& modArg) {
  struct HeaderAndConnContext {
    HeaderAndConnContext() : header(apache::thrift::transport::THeader::ALLOW_BIG_FRAMES) {}

    apache::thrift::transport::THeader header;
    apache::thrift::Cpp2ConnContext connContext;
  };
  auto headerAndConnContext = std::make_shared<HeaderAndConnContext>();
  std::shared_ptr<apache::thrift::transport::THeader> header(headerAndConnContext, &headerAndConnContext->header);
  header->setProtocolId(getChannel()->getProtocolId());
  header->setHeaders(rpcOptions.releaseWriteHeaders());
  headerAndConnContext->connContext.setRequestHeader(header.get());
  std::unique_ptr<apache::thrift::ContextStack> ctx = this->getContextStack(this->getServiceName(), "ServiceA.moduleAThrowMethod", &headerAndConnContext->connContext);
  ServiceA_moduleAThrowMethod_pargs args;
  args.get<0>().value = const_cast< ::some::ns::ModuleA*>(&modArg);
  auto sizer = [&](Protocol_* p) { return ::apache::thrift::detail::serializedResponseBodySizeZC(p, &args); };
  auto writer = [&](Protocol_* p) { ::apache::thrift::detail::serializeResponseBody(p, &args); };
  apache::thrift::clientSendT<Protocol_>(prot, rpcOptions, std::move(callback), std::move(ctx), header, channel_.get(), "moduleAThrowMethod", writer, sizer, apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, useSync);
  headerAndConnContext->connContext.setRequestHeader(nullptr);
}

template <typename Protocol_>
void ServiceAAsyncClient::mixedMethodT(Protocol_* prot, bool useSync, apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const std::string& strArg, int32_t i32Arg, const  ::some::ns::ModuleB& modArg) {
  struct HeaderAndConnContext {
    HeaderAndConnContext() : header(apache::thrift::transport::THeader::ALLOW_BIG_FRAMES) {}

    apache::thrift::transport::THeader header;
    apache::thrift::Cpp2ConnContext connContext;
  };
  auto headerAndConnContext = std::make_shared<HeaderAndConnContext>();
  std::shared_ptr<apache::thrift::transport::THeader> header(headerAndConnContext, &headerAndConnContext->header);
  header->setProtocolId(getChannel()->getProtocolId());
  header->setHeaders(rpcOptions.releaseWriteHeaders());
  headerAndConnContext->connContext.setRequestHeader(header.get());
  std::unique_ptr<apache::thrift::ContextStack> ctx = this->getContextStack(this->getServiceName(), "ServiceA.mixedMethod", &headerAndConnContext->connContext);
  ServiceA_mixedMethod_pargs args;
  args.get<0>().value = const_cast<std::string*>(&strArg);
  args.get<1>().value = &i32Arg;
  args.get<2>().value = const_cast< ::some::ns::ModuleB*>(&modArg);
  auto sizer = [&](Protocol_* p) { return ::apache::thrift::detail::serializedResponseBodySizeZC(p, &args); };
  auto writer = [&](Protocol_* p) { ::apache::thrift::detail::serializeResponseBody(p, &args); };
  apache::thrift::clientSendT<Protocol_>(prot, rpcOptions, std::move(callback), std::move(ctx), header, channel_.get(), "mixedMethod", writer, sizer, apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, useSync);
  headerAndConnContext->connContext.setRequestHeader(nullptr);
}



void ServiceAAsyncClient::moduleAMethod(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::some::ns::ModuleA& modArg) {
  ::apache::thrift::RpcOptions rpcOptions;
  moduleAMethodImpl(false, rpcOptions, std::move(callback), modArg);
}

void ServiceAAsyncClient::moduleAMethod(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::some::ns::ModuleA& modArg) {
  moduleAMethodImpl(false, rpcOptions, std::move(callback), modArg);
}

void ServiceAAsyncClient::moduleAMethodImpl(bool useSync, apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::some::ns::ModuleA& modArg) {
  switch(getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      moduleAMethodT(&writer, useSync, rpcOptions, std::move(callback), modArg);
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      moduleAMethodT(&writer, useSync, rpcOptions, std::move(callback), modArg);
      break;
    }
    case apache::thrift::protocol::T_FROZEN2_PROTOCOL:
    {
      apache::thrift::Frozen2ProtocolWriter writer;
      moduleAMethodT(&writer, useSync, rpcOptions, std::move(callback), modArg);
      break;
    }
    default:
    {
      apache::thrift::detail::ac::throw_app_exn("Could not find Protocol");
    }
  }
}

void ServiceAAsyncClient::sync_moduleAMethod(const  ::some::ns::ModuleA& modArg) {
  ::apache::thrift::RpcOptions rpcOptions;
  sync_moduleAMethod(rpcOptions, modArg);
}

void ServiceAAsyncClient::sync_moduleAMethod(apache::thrift::RpcOptions& rpcOptions, const  ::some::ns::ModuleA& modArg) {
  apache::thrift::ClientReceiveState _returnState;
  auto callback = std::make_unique<apache::thrift::ClientSyncCallback>(
      &_returnState, apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE);
  moduleAMethodImpl(true, rpcOptions, std::move(callback), modArg);
  SCOPE_EXIT {
    if (_returnState.header() && !_returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(_returnState.header()->releaseHeaders());
    }
  };
  if (!_returnState.buf()) {
    assert(!!_returnState.exception());
    _returnState.exception().throw_exception();
  }
  recv_moduleAMethod(_returnState);
}

folly::Future<folly::Unit> ServiceAAsyncClient::future_moduleAMethod(const  ::some::ns::ModuleA& modArg) {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_moduleAMethod(rpcOptions, modArg);
}

folly::SemiFuture<folly::Unit> ServiceAAsyncClient::semifuture_moduleAMethod(const  ::some::ns::ModuleA& modArg) {
  ::apache::thrift::RpcOptions rpcOptions;
  return semifuture_moduleAMethod(rpcOptions, modArg);
}

folly::Future<folly::Unit> ServiceAAsyncClient::future_moduleAMethod(apache::thrift::RpcOptions& rpcOptions, const  ::some::ns::ModuleA& modArg) {
  folly::Promise<folly::Unit> _promise;
  auto _future = _promise.getFuture();
  auto callback = std::make_unique<apache::thrift::FutureCallback<folly::Unit>>(std::move(_promise), recv_wrapped_moduleAMethod, channel_);
  moduleAMethod(rpcOptions, std::move(callback), modArg);
  return _future;
}

folly::SemiFuture<folly::Unit> ServiceAAsyncClient::semifuture_moduleAMethod(apache::thrift::RpcOptions& rpcOptions, const  ::some::ns::ModuleA& modArg) {
  auto callbackAndFuture = makeSemiFutureCallback(recv_wrapped_moduleAMethod, channel_);
  auto callback = std::move(callbackAndFuture.first);
  moduleAMethod(rpcOptions, std::move(callback), modArg);
  return std::move(callbackAndFuture.second);
}

folly::Future<std::pair<folly::Unit, std::unique_ptr<apache::thrift::transport::THeader>>> ServiceAAsyncClient::header_future_moduleAMethod(apache::thrift::RpcOptions& rpcOptions, const  ::some::ns::ModuleA& modArg) {
  folly::Promise<std::pair<folly::Unit, std::unique_ptr<apache::thrift::transport::THeader>>> _promise;
  auto _future = _promise.getFuture();
  auto callback = std::make_unique<apache::thrift::HeaderFutureCallback<folly::Unit>>(std::move(_promise), recv_wrapped_moduleAMethod, channel_);
  moduleAMethod(rpcOptions, std::move(callback), modArg);
  return _future;
}

folly::SemiFuture<std::pair<folly::Unit, std::unique_ptr<apache::thrift::transport::THeader>>> ServiceAAsyncClient::header_semifuture_moduleAMethod(apache::thrift::RpcOptions& rpcOptions, const  ::some::ns::ModuleA& modArg) {
  auto callbackAndFuture = makeHeaderSemiFutureCallback(recv_wrapped_moduleAMethod, channel_);
  auto callback = std::move(callbackAndFuture.first);
  moduleAMethod(rpcOptions, std::move(callback), modArg);
  return std::move(callbackAndFuture.second);
}

void ServiceAAsyncClient::moduleAMethod(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::some::ns::ModuleA& modArg) {
  moduleAMethod(std::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)), modArg);
}

folly::exception_wrapper ServiceAAsyncClient::recv_wrapped_moduleAMethod(::apache::thrift::ClientReceiveState& state) {
  if (state.isException()) {
    return std::move(state.exception());
  }
  if (!state.buf()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }

  using result = ServiceA_moduleAMethod_presult;
  constexpr auto const fname = "moduleAMethod";
  switch (state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state);
    }
    case apache::thrift::protocol::T_FROZEN2_PROTOCOL:
    {
      apache::thrift::Frozen2ProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

void ServiceAAsyncClient::recv_moduleAMethod(::apache::thrift::ClientReceiveState& state) {
  auto ew = recv_wrapped_moduleAMethod(state);
  if (ew) {
    ew.throw_exception();
  }
}

void ServiceAAsyncClient::recv_instance_moduleAMethod(::apache::thrift::ClientReceiveState& state) {
  recv_moduleAMethod(state);
}

folly::exception_wrapper ServiceAAsyncClient::recv_instance_wrapped_moduleAMethod(::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_moduleAMethod(state);
}

void ServiceAAsyncClient::moduleBMethod(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::some::ns::ModuleB& modArg) {
  ::apache::thrift::RpcOptions rpcOptions;
  moduleBMethodImpl(false, rpcOptions, std::move(callback), modArg);
}

void ServiceAAsyncClient::moduleBMethod(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::some::ns::ModuleB& modArg) {
  moduleBMethodImpl(false, rpcOptions, std::move(callback), modArg);
}

void ServiceAAsyncClient::moduleBMethodImpl(bool useSync, apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::some::ns::ModuleB& modArg) {
  switch(getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      moduleBMethodT(&writer, useSync, rpcOptions, std::move(callback), modArg);
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      moduleBMethodT(&writer, useSync, rpcOptions, std::move(callback), modArg);
      break;
    }
    case apache::thrift::protocol::T_FROZEN2_PROTOCOL:
    {
      apache::thrift::Frozen2ProtocolWriter writer;
      moduleBMethodT(&writer, useSync, rpcOptions, std::move(callback), modArg);
      break;
    }
    default:
    {
      apache::thrift::detail::ac::throw_app_exn("Could not find Protocol");
    }
  }
}

void ServiceAAsyncClient::sync_moduleBMethod(const  ::some::ns::ModuleB& modArg) {
  ::apache::thrift::RpcOptions rpcOptions;
  sync_moduleBMethod(rpcOptions, modArg);
}

void ServiceAAsyncClient::sync_moduleBMethod(apache::thrift::RpcOptions& rpcOptions, const  ::some::ns::ModuleB& modArg) {
  apache::thrift::ClientReceiveState _returnState;
  auto callback = std::make_unique<apache::thrift::ClientSyncCallback>(
      &_returnState, apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE);
  moduleBMethodImpl(true, rpcOptions, std::move(callback), modArg);
  SCOPE_EXIT {
    if (_returnState.header() && !_returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(_returnState.header()->releaseHeaders());
    }
  };
  if (!_returnState.buf()) {
    assert(!!_returnState.exception());
    _returnState.exception().throw_exception();
  }
  recv_moduleBMethod(_returnState);
}

folly::Future<folly::Unit> ServiceAAsyncClient::future_moduleBMethod(const  ::some::ns::ModuleB& modArg) {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_moduleBMethod(rpcOptions, modArg);
}

folly::SemiFuture<folly::Unit> ServiceAAsyncClient::semifuture_moduleBMethod(const  ::some::ns::ModuleB& modArg) {
  ::apache::thrift::RpcOptions rpcOptions;
  return semifuture_moduleBMethod(rpcOptions, modArg);
}

folly::Future<folly::Unit> ServiceAAsyncClient::future_moduleBMethod(apache::thrift::RpcOptions& rpcOptions, const  ::some::ns::ModuleB& modArg) {
  folly::Promise<folly::Unit> _promise;
  auto _future = _promise.getFuture();
  auto callback = std::make_unique<apache::thrift::FutureCallback<folly::Unit>>(std::move(_promise), recv_wrapped_moduleBMethod, channel_);
  moduleBMethod(rpcOptions, std::move(callback), modArg);
  return _future;
}

folly::SemiFuture<folly::Unit> ServiceAAsyncClient::semifuture_moduleBMethod(apache::thrift::RpcOptions& rpcOptions, const  ::some::ns::ModuleB& modArg) {
  auto callbackAndFuture = makeSemiFutureCallback(recv_wrapped_moduleBMethod, channel_);
  auto callback = std::move(callbackAndFuture.first);
  moduleBMethod(rpcOptions, std::move(callback), modArg);
  return std::move(callbackAndFuture.second);
}

folly::Future<std::pair<folly::Unit, std::unique_ptr<apache::thrift::transport::THeader>>> ServiceAAsyncClient::header_future_moduleBMethod(apache::thrift::RpcOptions& rpcOptions, const  ::some::ns::ModuleB& modArg) {
  folly::Promise<std::pair<folly::Unit, std::unique_ptr<apache::thrift::transport::THeader>>> _promise;
  auto _future = _promise.getFuture();
  auto callback = std::make_unique<apache::thrift::HeaderFutureCallback<folly::Unit>>(std::move(_promise), recv_wrapped_moduleBMethod, channel_);
  moduleBMethod(rpcOptions, std::move(callback), modArg);
  return _future;
}

folly::SemiFuture<std::pair<folly::Unit, std::unique_ptr<apache::thrift::transport::THeader>>> ServiceAAsyncClient::header_semifuture_moduleBMethod(apache::thrift::RpcOptions& rpcOptions, const  ::some::ns::ModuleB& modArg) {
  auto callbackAndFuture = makeHeaderSemiFutureCallback(recv_wrapped_moduleBMethod, channel_);
  auto callback = std::move(callbackAndFuture.first);
  moduleBMethod(rpcOptions, std::move(callback), modArg);
  return std::move(callbackAndFuture.second);
}

void ServiceAAsyncClient::moduleBMethod(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::some::ns::ModuleB& modArg) {
  moduleBMethod(std::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)), modArg);
}

folly::exception_wrapper ServiceAAsyncClient::recv_wrapped_moduleBMethod(::apache::thrift::ClientReceiveState& state) {
  if (state.isException()) {
    return std::move(state.exception());
  }
  if (!state.buf()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }

  using result = ServiceA_moduleBMethod_presult;
  constexpr auto const fname = "moduleBMethod";
  switch (state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state);
    }
    case apache::thrift::protocol::T_FROZEN2_PROTOCOL:
    {
      apache::thrift::Frozen2ProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

void ServiceAAsyncClient::recv_moduleBMethod(::apache::thrift::ClientReceiveState& state) {
  auto ew = recv_wrapped_moduleBMethod(state);
  if (ew) {
    ew.throw_exception();
  }
}

void ServiceAAsyncClient::recv_instance_moduleBMethod(::apache::thrift::ClientReceiveState& state) {
  recv_moduleBMethod(state);
}

folly::exception_wrapper ServiceAAsyncClient::recv_instance_wrapped_moduleBMethod(::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_moduleBMethod(state);
}

void ServiceAAsyncClient::i32StrDoubleMethod(std::unique_ptr<apache::thrift::RequestCallback> callback, int32_t i32Arg, const std::string& strArg, double doubleArg) {
  ::apache::thrift::RpcOptions rpcOptions;
  i32StrDoubleMethodImpl(false, rpcOptions, std::move(callback), i32Arg, strArg, doubleArg);
}

void ServiceAAsyncClient::i32StrDoubleMethod(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, int32_t i32Arg, const std::string& strArg, double doubleArg) {
  i32StrDoubleMethodImpl(false, rpcOptions, std::move(callback), i32Arg, strArg, doubleArg);
}

void ServiceAAsyncClient::i32StrDoubleMethodImpl(bool useSync, apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, int32_t i32Arg, const std::string& strArg, double doubleArg) {
  switch(getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      i32StrDoubleMethodT(&writer, useSync, rpcOptions, std::move(callback), i32Arg, strArg, doubleArg);
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      i32StrDoubleMethodT(&writer, useSync, rpcOptions, std::move(callback), i32Arg, strArg, doubleArg);
      break;
    }
    case apache::thrift::protocol::T_FROZEN2_PROTOCOL:
    {
      apache::thrift::Frozen2ProtocolWriter writer;
      i32StrDoubleMethodT(&writer, useSync, rpcOptions, std::move(callback), i32Arg, strArg, doubleArg);
      break;
    }
    default:
    {
      apache::thrift::detail::ac::throw_app_exn("Could not find Protocol");
    }
  }
}

void ServiceAAsyncClient::sync_i32StrDoubleMethod(int32_t i32Arg, const std::string& strArg, double doubleArg) {
  ::apache::thrift::RpcOptions rpcOptions;
  sync_i32StrDoubleMethod(rpcOptions, i32Arg, strArg, doubleArg);
}

void ServiceAAsyncClient::sync_i32StrDoubleMethod(apache::thrift::RpcOptions& rpcOptions, int32_t i32Arg, const std::string& strArg, double doubleArg) {
  apache::thrift::ClientReceiveState _returnState;
  auto callback = std::make_unique<apache::thrift::ClientSyncCallback>(
      &_returnState, apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE);
  i32StrDoubleMethodImpl(true, rpcOptions, std::move(callback), i32Arg, strArg, doubleArg);
  SCOPE_EXIT {
    if (_returnState.header() && !_returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(_returnState.header()->releaseHeaders());
    }
  };
  if (!_returnState.buf()) {
    assert(!!_returnState.exception());
    _returnState.exception().throw_exception();
  }
  recv_i32StrDoubleMethod(_returnState);
}

folly::Future<folly::Unit> ServiceAAsyncClient::future_i32StrDoubleMethod(int32_t i32Arg, const std::string& strArg, double doubleArg) {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_i32StrDoubleMethod(rpcOptions, i32Arg, strArg, doubleArg);
}

folly::SemiFuture<folly::Unit> ServiceAAsyncClient::semifuture_i32StrDoubleMethod(int32_t i32Arg, const std::string& strArg, double doubleArg) {
  ::apache::thrift::RpcOptions rpcOptions;
  return semifuture_i32StrDoubleMethod(rpcOptions, i32Arg, strArg, doubleArg);
}

folly::Future<folly::Unit> ServiceAAsyncClient::future_i32StrDoubleMethod(apache::thrift::RpcOptions& rpcOptions, int32_t i32Arg, const std::string& strArg, double doubleArg) {
  folly::Promise<folly::Unit> _promise;
  auto _future = _promise.getFuture();
  auto callback = std::make_unique<apache::thrift::FutureCallback<folly::Unit>>(std::move(_promise), recv_wrapped_i32StrDoubleMethod, channel_);
  i32StrDoubleMethod(rpcOptions, std::move(callback), i32Arg, strArg, doubleArg);
  return _future;
}

folly::SemiFuture<folly::Unit> ServiceAAsyncClient::semifuture_i32StrDoubleMethod(apache::thrift::RpcOptions& rpcOptions, int32_t i32Arg, const std::string& strArg, double doubleArg) {
  auto callbackAndFuture = makeSemiFutureCallback(recv_wrapped_i32StrDoubleMethod, channel_);
  auto callback = std::move(callbackAndFuture.first);
  i32StrDoubleMethod(rpcOptions, std::move(callback), i32Arg, strArg, doubleArg);
  return std::move(callbackAndFuture.second);
}

folly::Future<std::pair<folly::Unit, std::unique_ptr<apache::thrift::transport::THeader>>> ServiceAAsyncClient::header_future_i32StrDoubleMethod(apache::thrift::RpcOptions& rpcOptions, int32_t i32Arg, const std::string& strArg, double doubleArg) {
  folly::Promise<std::pair<folly::Unit, std::unique_ptr<apache::thrift::transport::THeader>>> _promise;
  auto _future = _promise.getFuture();
  auto callback = std::make_unique<apache::thrift::HeaderFutureCallback<folly::Unit>>(std::move(_promise), recv_wrapped_i32StrDoubleMethod, channel_);
  i32StrDoubleMethod(rpcOptions, std::move(callback), i32Arg, strArg, doubleArg);
  return _future;
}

folly::SemiFuture<std::pair<folly::Unit, std::unique_ptr<apache::thrift::transport::THeader>>> ServiceAAsyncClient::header_semifuture_i32StrDoubleMethod(apache::thrift::RpcOptions& rpcOptions, int32_t i32Arg, const std::string& strArg, double doubleArg) {
  auto callbackAndFuture = makeHeaderSemiFutureCallback(recv_wrapped_i32StrDoubleMethod, channel_);
  auto callback = std::move(callbackAndFuture.first);
  i32StrDoubleMethod(rpcOptions, std::move(callback), i32Arg, strArg, doubleArg);
  return std::move(callbackAndFuture.second);
}

void ServiceAAsyncClient::i32StrDoubleMethod(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, int32_t i32Arg, const std::string& strArg, double doubleArg) {
  i32StrDoubleMethod(std::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)), i32Arg, strArg, doubleArg);
}

folly::exception_wrapper ServiceAAsyncClient::recv_wrapped_i32StrDoubleMethod(::apache::thrift::ClientReceiveState& state) {
  if (state.isException()) {
    return std::move(state.exception());
  }
  if (!state.buf()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }

  using result = ServiceA_i32StrDoubleMethod_presult;
  constexpr auto const fname = "i32StrDoubleMethod";
  switch (state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state);
    }
    case apache::thrift::protocol::T_FROZEN2_PROTOCOL:
    {
      apache::thrift::Frozen2ProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

void ServiceAAsyncClient::recv_i32StrDoubleMethod(::apache::thrift::ClientReceiveState& state) {
  auto ew = recv_wrapped_i32StrDoubleMethod(state);
  if (ew) {
    ew.throw_exception();
  }
}

void ServiceAAsyncClient::recv_instance_i32StrDoubleMethod(::apache::thrift::ClientReceiveState& state) {
  recv_i32StrDoubleMethod(state);
}

folly::exception_wrapper ServiceAAsyncClient::recv_instance_wrapped_i32StrDoubleMethod(::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_i32StrDoubleMethod(state);
}

void ServiceAAsyncClient::versioningMethod(std::unique_ptr<apache::thrift::RequestCallback> callback, int32_t i32Arg, const std::string& strArg, double doubleArg) {
  ::apache::thrift::RpcOptions rpcOptions;
  versioningMethodImpl(false, rpcOptions, std::move(callback), i32Arg, strArg, doubleArg);
}

void ServiceAAsyncClient::versioningMethod(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, int32_t i32Arg, const std::string& strArg, double doubleArg) {
  versioningMethodImpl(false, rpcOptions, std::move(callback), i32Arg, strArg, doubleArg);
}

void ServiceAAsyncClient::versioningMethodImpl(bool useSync, apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, int32_t i32Arg, const std::string& strArg, double doubleArg) {
  switch(getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      versioningMethodT(&writer, useSync, rpcOptions, std::move(callback), i32Arg, strArg, doubleArg);
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      versioningMethodT(&writer, useSync, rpcOptions, std::move(callback), i32Arg, strArg, doubleArg);
      break;
    }
    case apache::thrift::protocol::T_FROZEN2_PROTOCOL:
    {
      apache::thrift::Frozen2ProtocolWriter writer;
      versioningMethodT(&writer, useSync, rpcOptions, std::move(callback), i32Arg, strArg, doubleArg);
      break;
    }
    default:
    {
      apache::thrift::detail::ac::throw_app_exn("Could not find Protocol");
    }
  }
}

void ServiceAAsyncClient::sync_versioningMethod(int32_t i32Arg, const std::string& strArg, double doubleArg) {
  ::apache::thrift::RpcOptions rpcOptions;
  sync_versioningMethod(rpcOptions, i32Arg, strArg, doubleArg);
}

void ServiceAAsyncClient::sync_versioningMethod(apache::thrift::RpcOptions& rpcOptions, int32_t i32Arg, const std::string& strArg, double doubleArg) {
  apache::thrift::ClientReceiveState _returnState;
  auto callback = std::make_unique<apache::thrift::ClientSyncCallback>(
      &_returnState, apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE);
  versioningMethodImpl(true, rpcOptions, std::move(callback), i32Arg, strArg, doubleArg);
  SCOPE_EXIT {
    if (_returnState.header() && !_returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(_returnState.header()->releaseHeaders());
    }
  };
  if (!_returnState.buf()) {
    assert(!!_returnState.exception());
    _returnState.exception().throw_exception();
  }
  recv_versioningMethod(_returnState);
}

folly::Future<folly::Unit> ServiceAAsyncClient::future_versioningMethod(int32_t i32Arg, const std::string& strArg, double doubleArg) {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_versioningMethod(rpcOptions, i32Arg, strArg, doubleArg);
}

folly::SemiFuture<folly::Unit> ServiceAAsyncClient::semifuture_versioningMethod(int32_t i32Arg, const std::string& strArg, double doubleArg) {
  ::apache::thrift::RpcOptions rpcOptions;
  return semifuture_versioningMethod(rpcOptions, i32Arg, strArg, doubleArg);
}

folly::Future<folly::Unit> ServiceAAsyncClient::future_versioningMethod(apache::thrift::RpcOptions& rpcOptions, int32_t i32Arg, const std::string& strArg, double doubleArg) {
  folly::Promise<folly::Unit> _promise;
  auto _future = _promise.getFuture();
  auto callback = std::make_unique<apache::thrift::FutureCallback<folly::Unit>>(std::move(_promise), recv_wrapped_versioningMethod, channel_);
  versioningMethod(rpcOptions, std::move(callback), i32Arg, strArg, doubleArg);
  return _future;
}

folly::SemiFuture<folly::Unit> ServiceAAsyncClient::semifuture_versioningMethod(apache::thrift::RpcOptions& rpcOptions, int32_t i32Arg, const std::string& strArg, double doubleArg) {
  auto callbackAndFuture = makeSemiFutureCallback(recv_wrapped_versioningMethod, channel_);
  auto callback = std::move(callbackAndFuture.first);
  versioningMethod(rpcOptions, std::move(callback), i32Arg, strArg, doubleArg);
  return std::move(callbackAndFuture.second);
}

folly::Future<std::pair<folly::Unit, std::unique_ptr<apache::thrift::transport::THeader>>> ServiceAAsyncClient::header_future_versioningMethod(apache::thrift::RpcOptions& rpcOptions, int32_t i32Arg, const std::string& strArg, double doubleArg) {
  folly::Promise<std::pair<folly::Unit, std::unique_ptr<apache::thrift::transport::THeader>>> _promise;
  auto _future = _promise.getFuture();
  auto callback = std::make_unique<apache::thrift::HeaderFutureCallback<folly::Unit>>(std::move(_promise), recv_wrapped_versioningMethod, channel_);
  versioningMethod(rpcOptions, std::move(callback), i32Arg, strArg, doubleArg);
  return _future;
}

folly::SemiFuture<std::pair<folly::Unit, std::unique_ptr<apache::thrift::transport::THeader>>> ServiceAAsyncClient::header_semifuture_versioningMethod(apache::thrift::RpcOptions& rpcOptions, int32_t i32Arg, const std::string& strArg, double doubleArg) {
  auto callbackAndFuture = makeHeaderSemiFutureCallback(recv_wrapped_versioningMethod, channel_);
  auto callback = std::move(callbackAndFuture.first);
  versioningMethod(rpcOptions, std::move(callback), i32Arg, strArg, doubleArg);
  return std::move(callbackAndFuture.second);
}

void ServiceAAsyncClient::versioningMethod(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, int32_t i32Arg, const std::string& strArg, double doubleArg) {
  versioningMethod(std::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)), i32Arg, strArg, doubleArg);
}

folly::exception_wrapper ServiceAAsyncClient::recv_wrapped_versioningMethod(::apache::thrift::ClientReceiveState& state) {
  if (state.isException()) {
    return std::move(state.exception());
  }
  if (!state.buf()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }

  using result = ServiceA_versioningMethod_presult;
  constexpr auto const fname = "versioningMethod";
  switch (state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state);
    }
    case apache::thrift::protocol::T_FROZEN2_PROTOCOL:
    {
      apache::thrift::Frozen2ProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

void ServiceAAsyncClient::recv_versioningMethod(::apache::thrift::ClientReceiveState& state) {
  auto ew = recv_wrapped_versioningMethod(state);
  if (ew) {
    ew.throw_exception();
  }
}

void ServiceAAsyncClient::recv_instance_versioningMethod(::apache::thrift::ClientReceiveState& state) {
  recv_versioningMethod(state);
}

folly::exception_wrapper ServiceAAsyncClient::recv_instance_wrapped_versioningMethod(::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_versioningMethod(state);
}

void ServiceAAsyncClient::retI32Method(std::unique_ptr<apache::thrift::RequestCallback> callback) {
  ::apache::thrift::RpcOptions rpcOptions;
  retI32MethodImpl(false, rpcOptions, std::move(callback));
}

void ServiceAAsyncClient::retI32Method(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback) {
  retI32MethodImpl(false, rpcOptions, std::move(callback));
}

void ServiceAAsyncClient::retI32MethodImpl(bool useSync, apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback) {
  switch(getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      retI32MethodT(&writer, useSync, rpcOptions, std::move(callback));
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      retI32MethodT(&writer, useSync, rpcOptions, std::move(callback));
      break;
    }
    case apache::thrift::protocol::T_FROZEN2_PROTOCOL:
    {
      apache::thrift::Frozen2ProtocolWriter writer;
      retI32MethodT(&writer, useSync, rpcOptions, std::move(callback));
      break;
    }
    default:
    {
      apache::thrift::detail::ac::throw_app_exn("Could not find Protocol");
    }
  }
}

int32_t ServiceAAsyncClient::sync_retI32Method() {
  ::apache::thrift::RpcOptions rpcOptions;
  return sync_retI32Method(rpcOptions);
}

int32_t ServiceAAsyncClient::sync_retI32Method(apache::thrift::RpcOptions& rpcOptions) {
  apache::thrift::ClientReceiveState _returnState;
  auto callback = std::make_unique<apache::thrift::ClientSyncCallback>(
      &_returnState, apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE);
  retI32MethodImpl(true, rpcOptions, std::move(callback));
  SCOPE_EXIT {
    if (_returnState.header() && !_returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(_returnState.header()->releaseHeaders());
    }
  };
  if (!_returnState.buf()) {
    assert(!!_returnState.exception());
    _returnState.exception().throw_exception();
  }
  return recv_retI32Method(_returnState);
}

folly::Future<int32_t> ServiceAAsyncClient::future_retI32Method() {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_retI32Method(rpcOptions);
}

folly::SemiFuture<int32_t> ServiceAAsyncClient::semifuture_retI32Method() {
  ::apache::thrift::RpcOptions rpcOptions;
  return semifuture_retI32Method(rpcOptions);
}

folly::Future<int32_t> ServiceAAsyncClient::future_retI32Method(apache::thrift::RpcOptions& rpcOptions) {
  folly::Promise<int32_t> _promise;
  auto _future = _promise.getFuture();
  auto callback = std::make_unique<apache::thrift::FutureCallback<int32_t>>(std::move(_promise), recv_wrapped_retI32Method, channel_);
  retI32Method(rpcOptions, std::move(callback));
  return _future;
}

folly::SemiFuture<int32_t> ServiceAAsyncClient::semifuture_retI32Method(apache::thrift::RpcOptions& rpcOptions) {
  auto callbackAndFuture = makeSemiFutureCallback(recv_wrapped_retI32Method, channel_);
  auto callback = std::move(callbackAndFuture.first);
  retI32Method(rpcOptions, std::move(callback));
  return std::move(callbackAndFuture.second);
}

folly::Future<std::pair<int32_t, std::unique_ptr<apache::thrift::transport::THeader>>> ServiceAAsyncClient::header_future_retI32Method(apache::thrift::RpcOptions& rpcOptions) {
  folly::Promise<std::pair<int32_t, std::unique_ptr<apache::thrift::transport::THeader>>> _promise;
  auto _future = _promise.getFuture();
  auto callback = std::make_unique<apache::thrift::HeaderFutureCallback<int32_t>>(std::move(_promise), recv_wrapped_retI32Method, channel_);
  retI32Method(rpcOptions, std::move(callback));
  return _future;
}

folly::SemiFuture<std::pair<int32_t, std::unique_ptr<apache::thrift::transport::THeader>>> ServiceAAsyncClient::header_semifuture_retI32Method(apache::thrift::RpcOptions& rpcOptions) {
  auto callbackAndFuture = makeHeaderSemiFutureCallback(recv_wrapped_retI32Method, channel_);
  auto callback = std::move(callbackAndFuture.first);
  retI32Method(rpcOptions, std::move(callback));
  return std::move(callbackAndFuture.second);
}

void ServiceAAsyncClient::retI32Method(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback) {
  retI32Method(std::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)));
}

folly::exception_wrapper ServiceAAsyncClient::recv_wrapped_retI32Method(int32_t& _return, ::apache::thrift::ClientReceiveState& state) {
  if (state.isException()) {
    return std::move(state.exception());
  }
  if (!state.buf()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }

  using result = ServiceA_retI32Method_presult;
  constexpr auto const fname = "retI32Method";
  switch (state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    case apache::thrift::protocol::T_FROZEN2_PROTOCOL:
    {
      apache::thrift::Frozen2ProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

int32_t ServiceAAsyncClient::recv_retI32Method(::apache::thrift::ClientReceiveState& state) {
  int32_t _return;
  auto ew = recv_wrapped_retI32Method(_return, state);
  if (ew) {
    ew.throw_exception();
  }
  return _return;
}

int32_t ServiceAAsyncClient::recv_instance_retI32Method(::apache::thrift::ClientReceiveState& state) {
  return recv_retI32Method(state);
}

folly::exception_wrapper ServiceAAsyncClient::recv_instance_wrapped_retI32Method(int32_t& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_retI32Method(_return, state);
}

void ServiceAAsyncClient::retModAMethod(std::unique_ptr<apache::thrift::RequestCallback> callback) {
  ::apache::thrift::RpcOptions rpcOptions;
  retModAMethodImpl(false, rpcOptions, std::move(callback));
}

void ServiceAAsyncClient::retModAMethod(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback) {
  retModAMethodImpl(false, rpcOptions, std::move(callback));
}

void ServiceAAsyncClient::retModAMethodImpl(bool useSync, apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback) {
  switch(getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      retModAMethodT(&writer, useSync, rpcOptions, std::move(callback));
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      retModAMethodT(&writer, useSync, rpcOptions, std::move(callback));
      break;
    }
    case apache::thrift::protocol::T_FROZEN2_PROTOCOL:
    {
      apache::thrift::Frozen2ProtocolWriter writer;
      retModAMethodT(&writer, useSync, rpcOptions, std::move(callback));
      break;
    }
    default:
    {
      apache::thrift::detail::ac::throw_app_exn("Could not find Protocol");
    }
  }
}

void ServiceAAsyncClient::sync_retModAMethod( ::some::ns::ModuleA& _return) {
  ::apache::thrift::RpcOptions rpcOptions;
  sync_retModAMethod(rpcOptions, _return);
}

void ServiceAAsyncClient::sync_retModAMethod(apache::thrift::RpcOptions& rpcOptions,  ::some::ns::ModuleA& _return) {
  apache::thrift::ClientReceiveState _returnState;
  auto callback = std::make_unique<apache::thrift::ClientSyncCallback>(
      &_returnState, apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE);
  retModAMethodImpl(true, rpcOptions, std::move(callback));
  SCOPE_EXIT {
    if (_returnState.header() && !_returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(_returnState.header()->releaseHeaders());
    }
  };
  if (!_returnState.buf()) {
    assert(!!_returnState.exception());
    _returnState.exception().throw_exception();
  }
  recv_retModAMethod(_return, _returnState);
}

folly::Future< ::some::ns::ModuleA> ServiceAAsyncClient::future_retModAMethod() {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_retModAMethod(rpcOptions);
}

folly::SemiFuture< ::some::ns::ModuleA> ServiceAAsyncClient::semifuture_retModAMethod() {
  ::apache::thrift::RpcOptions rpcOptions;
  return semifuture_retModAMethod(rpcOptions);
}

folly::Future< ::some::ns::ModuleA> ServiceAAsyncClient::future_retModAMethod(apache::thrift::RpcOptions& rpcOptions) {
  folly::Promise< ::some::ns::ModuleA> _promise;
  auto _future = _promise.getFuture();
  auto callback = std::make_unique<apache::thrift::FutureCallback< ::some::ns::ModuleA>>(std::move(_promise), recv_wrapped_retModAMethod, channel_);
  retModAMethod(rpcOptions, std::move(callback));
  return _future;
}

folly::SemiFuture< ::some::ns::ModuleA> ServiceAAsyncClient::semifuture_retModAMethod(apache::thrift::RpcOptions& rpcOptions) {
  auto callbackAndFuture = makeSemiFutureCallback(recv_wrapped_retModAMethod, channel_);
  auto callback = std::move(callbackAndFuture.first);
  retModAMethod(rpcOptions, std::move(callback));
  return std::move(callbackAndFuture.second);
}

folly::Future<std::pair< ::some::ns::ModuleA, std::unique_ptr<apache::thrift::transport::THeader>>> ServiceAAsyncClient::header_future_retModAMethod(apache::thrift::RpcOptions& rpcOptions) {
  folly::Promise<std::pair< ::some::ns::ModuleA, std::unique_ptr<apache::thrift::transport::THeader>>> _promise;
  auto _future = _promise.getFuture();
  auto callback = std::make_unique<apache::thrift::HeaderFutureCallback< ::some::ns::ModuleA>>(std::move(_promise), recv_wrapped_retModAMethod, channel_);
  retModAMethod(rpcOptions, std::move(callback));
  return _future;
}

folly::SemiFuture<std::pair< ::some::ns::ModuleA, std::unique_ptr<apache::thrift::transport::THeader>>> ServiceAAsyncClient::header_semifuture_retModAMethod(apache::thrift::RpcOptions& rpcOptions) {
  auto callbackAndFuture = makeHeaderSemiFutureCallback(recv_wrapped_retModAMethod, channel_);
  auto callback = std::move(callbackAndFuture.first);
  retModAMethod(rpcOptions, std::move(callback));
  return std::move(callbackAndFuture.second);
}

void ServiceAAsyncClient::retModAMethod(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback) {
  retModAMethod(std::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)));
}

folly::exception_wrapper ServiceAAsyncClient::recv_wrapped_retModAMethod( ::some::ns::ModuleA& _return, ::apache::thrift::ClientReceiveState& state) {
  if (state.isException()) {
    return std::move(state.exception());
  }
  if (!state.buf()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }

  using result = ServiceA_retModAMethod_presult;
  constexpr auto const fname = "retModAMethod";
  switch (state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    case apache::thrift::protocol::T_FROZEN2_PROTOCOL:
    {
      apache::thrift::Frozen2ProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

void ServiceAAsyncClient::recv_retModAMethod( ::some::ns::ModuleA& _return, ::apache::thrift::ClientReceiveState& state) {
  auto ew = recv_wrapped_retModAMethod(_return, state);
  if (ew) {
    ew.throw_exception();
  }
}

void ServiceAAsyncClient::recv_instance_retModAMethod( ::some::ns::ModuleA& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_retModAMethod(_return, state);
}

folly::exception_wrapper ServiceAAsyncClient::recv_instance_wrapped_retModAMethod( ::some::ns::ModuleA& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_retModAMethod(_return, state);
}

void ServiceAAsyncClient::throwMethod(std::unique_ptr<apache::thrift::RequestCallback> callback) {
  ::apache::thrift::RpcOptions rpcOptions;
  throwMethodImpl(false, rpcOptions, std::move(callback));
}

void ServiceAAsyncClient::throwMethod(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback) {
  throwMethodImpl(false, rpcOptions, std::move(callback));
}

void ServiceAAsyncClient::throwMethodImpl(bool useSync, apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback) {
  switch(getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      throwMethodT(&writer, useSync, rpcOptions, std::move(callback));
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      throwMethodT(&writer, useSync, rpcOptions, std::move(callback));
      break;
    }
    case apache::thrift::protocol::T_FROZEN2_PROTOCOL:
    {
      apache::thrift::Frozen2ProtocolWriter writer;
      throwMethodT(&writer, useSync, rpcOptions, std::move(callback));
      break;
    }
    default:
    {
      apache::thrift::detail::ac::throw_app_exn("Could not find Protocol");
    }
  }
}

void ServiceAAsyncClient::sync_throwMethod() {
  ::apache::thrift::RpcOptions rpcOptions;
  sync_throwMethod(rpcOptions);
}

void ServiceAAsyncClient::sync_throwMethod(apache::thrift::RpcOptions& rpcOptions) {
  apache::thrift::ClientReceiveState _returnState;
  auto callback = std::make_unique<apache::thrift::ClientSyncCallback>(
      &_returnState, apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE);
  throwMethodImpl(true, rpcOptions, std::move(callback));
  SCOPE_EXIT {
    if (_returnState.header() && !_returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(_returnState.header()->releaseHeaders());
    }
  };
  if (!_returnState.buf()) {
    assert(!!_returnState.exception());
    _returnState.exception().throw_exception();
  }
  recv_throwMethod(_returnState);
}

folly::Future<folly::Unit> ServiceAAsyncClient::future_throwMethod() {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_throwMethod(rpcOptions);
}

folly::SemiFuture<folly::Unit> ServiceAAsyncClient::semifuture_throwMethod() {
  ::apache::thrift::RpcOptions rpcOptions;
  return semifuture_throwMethod(rpcOptions);
}

folly::Future<folly::Unit> ServiceAAsyncClient::future_throwMethod(apache::thrift::RpcOptions& rpcOptions) {
  folly::Promise<folly::Unit> _promise;
  auto _future = _promise.getFuture();
  auto callback = std::make_unique<apache::thrift::FutureCallback<folly::Unit>>(std::move(_promise), recv_wrapped_throwMethod, channel_);
  throwMethod(rpcOptions, std::move(callback));
  return _future;
}

folly::SemiFuture<folly::Unit> ServiceAAsyncClient::semifuture_throwMethod(apache::thrift::RpcOptions& rpcOptions) {
  auto callbackAndFuture = makeSemiFutureCallback(recv_wrapped_throwMethod, channel_);
  auto callback = std::move(callbackAndFuture.first);
  throwMethod(rpcOptions, std::move(callback));
  return std::move(callbackAndFuture.second);
}

folly::Future<std::pair<folly::Unit, std::unique_ptr<apache::thrift::transport::THeader>>> ServiceAAsyncClient::header_future_throwMethod(apache::thrift::RpcOptions& rpcOptions) {
  folly::Promise<std::pair<folly::Unit, std::unique_ptr<apache::thrift::transport::THeader>>> _promise;
  auto _future = _promise.getFuture();
  auto callback = std::make_unique<apache::thrift::HeaderFutureCallback<folly::Unit>>(std::move(_promise), recv_wrapped_throwMethod, channel_);
  throwMethod(rpcOptions, std::move(callback));
  return _future;
}

folly::SemiFuture<std::pair<folly::Unit, std::unique_ptr<apache::thrift::transport::THeader>>> ServiceAAsyncClient::header_semifuture_throwMethod(apache::thrift::RpcOptions& rpcOptions) {
  auto callbackAndFuture = makeHeaderSemiFutureCallback(recv_wrapped_throwMethod, channel_);
  auto callback = std::move(callbackAndFuture.first);
  throwMethod(rpcOptions, std::move(callback));
  return std::move(callbackAndFuture.second);
}

void ServiceAAsyncClient::throwMethod(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback) {
  throwMethod(std::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)));
}

folly::exception_wrapper ServiceAAsyncClient::recv_wrapped_throwMethod(::apache::thrift::ClientReceiveState& state) {
  if (state.isException()) {
    return std::move(state.exception());
  }
  if (!state.buf()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }

  using result = ServiceA_throwMethod_presult;
  constexpr auto const fname = "throwMethod";
  switch (state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state);
    }
    case apache::thrift::protocol::T_FROZEN2_PROTOCOL:
    {
      apache::thrift::Frozen2ProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

void ServiceAAsyncClient::recv_throwMethod(::apache::thrift::ClientReceiveState& state) {
  auto ew = recv_wrapped_throwMethod(state);
  if (ew) {
    ew.throw_exception();
  }
}

void ServiceAAsyncClient::recv_instance_throwMethod(::apache::thrift::ClientReceiveState& state) {
  recv_throwMethod(state);
}

folly::exception_wrapper ServiceAAsyncClient::recv_instance_wrapped_throwMethod(::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_throwMethod(state);
}

void ServiceAAsyncClient::multiThrowMethod(std::unique_ptr<apache::thrift::RequestCallback> callback) {
  ::apache::thrift::RpcOptions rpcOptions;
  multiThrowMethodImpl(false, rpcOptions, std::move(callback));
}

void ServiceAAsyncClient::multiThrowMethod(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback) {
  multiThrowMethodImpl(false, rpcOptions, std::move(callback));
}

void ServiceAAsyncClient::multiThrowMethodImpl(bool useSync, apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback) {
  switch(getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      multiThrowMethodT(&writer, useSync, rpcOptions, std::move(callback));
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      multiThrowMethodT(&writer, useSync, rpcOptions, std::move(callback));
      break;
    }
    case apache::thrift::protocol::T_FROZEN2_PROTOCOL:
    {
      apache::thrift::Frozen2ProtocolWriter writer;
      multiThrowMethodT(&writer, useSync, rpcOptions, std::move(callback));
      break;
    }
    default:
    {
      apache::thrift::detail::ac::throw_app_exn("Could not find Protocol");
    }
  }
}

void ServiceAAsyncClient::sync_multiThrowMethod() {
  ::apache::thrift::RpcOptions rpcOptions;
  sync_multiThrowMethod(rpcOptions);
}

void ServiceAAsyncClient::sync_multiThrowMethod(apache::thrift::RpcOptions& rpcOptions) {
  apache::thrift::ClientReceiveState _returnState;
  auto callback = std::make_unique<apache::thrift::ClientSyncCallback>(
      &_returnState, apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE);
  multiThrowMethodImpl(true, rpcOptions, std::move(callback));
  SCOPE_EXIT {
    if (_returnState.header() && !_returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(_returnState.header()->releaseHeaders());
    }
  };
  if (!_returnState.buf()) {
    assert(!!_returnState.exception());
    _returnState.exception().throw_exception();
  }
  recv_multiThrowMethod(_returnState);
}

folly::Future<folly::Unit> ServiceAAsyncClient::future_multiThrowMethod() {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_multiThrowMethod(rpcOptions);
}

folly::SemiFuture<folly::Unit> ServiceAAsyncClient::semifuture_multiThrowMethod() {
  ::apache::thrift::RpcOptions rpcOptions;
  return semifuture_multiThrowMethod(rpcOptions);
}

folly::Future<folly::Unit> ServiceAAsyncClient::future_multiThrowMethod(apache::thrift::RpcOptions& rpcOptions) {
  folly::Promise<folly::Unit> _promise;
  auto _future = _promise.getFuture();
  auto callback = std::make_unique<apache::thrift::FutureCallback<folly::Unit>>(std::move(_promise), recv_wrapped_multiThrowMethod, channel_);
  multiThrowMethod(rpcOptions, std::move(callback));
  return _future;
}

folly::SemiFuture<folly::Unit> ServiceAAsyncClient::semifuture_multiThrowMethod(apache::thrift::RpcOptions& rpcOptions) {
  auto callbackAndFuture = makeSemiFutureCallback(recv_wrapped_multiThrowMethod, channel_);
  auto callback = std::move(callbackAndFuture.first);
  multiThrowMethod(rpcOptions, std::move(callback));
  return std::move(callbackAndFuture.second);
}

folly::Future<std::pair<folly::Unit, std::unique_ptr<apache::thrift::transport::THeader>>> ServiceAAsyncClient::header_future_multiThrowMethod(apache::thrift::RpcOptions& rpcOptions) {
  folly::Promise<std::pair<folly::Unit, std::unique_ptr<apache::thrift::transport::THeader>>> _promise;
  auto _future = _promise.getFuture();
  auto callback = std::make_unique<apache::thrift::HeaderFutureCallback<folly::Unit>>(std::move(_promise), recv_wrapped_multiThrowMethod, channel_);
  multiThrowMethod(rpcOptions, std::move(callback));
  return _future;
}

folly::SemiFuture<std::pair<folly::Unit, std::unique_ptr<apache::thrift::transport::THeader>>> ServiceAAsyncClient::header_semifuture_multiThrowMethod(apache::thrift::RpcOptions& rpcOptions) {
  auto callbackAndFuture = makeHeaderSemiFutureCallback(recv_wrapped_multiThrowMethod, channel_);
  auto callback = std::move(callbackAndFuture.first);
  multiThrowMethod(rpcOptions, std::move(callback));
  return std::move(callbackAndFuture.second);
}

void ServiceAAsyncClient::multiThrowMethod(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback) {
  multiThrowMethod(std::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)));
}

folly::exception_wrapper ServiceAAsyncClient::recv_wrapped_multiThrowMethod(::apache::thrift::ClientReceiveState& state) {
  if (state.isException()) {
    return std::move(state.exception());
  }
  if (!state.buf()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }

  using result = ServiceA_multiThrowMethod_presult;
  constexpr auto const fname = "multiThrowMethod";
  switch (state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state);
    }
    case apache::thrift::protocol::T_FROZEN2_PROTOCOL:
    {
      apache::thrift::Frozen2ProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

void ServiceAAsyncClient::recv_multiThrowMethod(::apache::thrift::ClientReceiveState& state) {
  auto ew = recv_wrapped_multiThrowMethod(state);
  if (ew) {
    ew.throw_exception();
  }
}

void ServiceAAsyncClient::recv_instance_multiThrowMethod(::apache::thrift::ClientReceiveState& state) {
  recv_multiThrowMethod(state);
}

folly::exception_wrapper ServiceAAsyncClient::recv_instance_wrapped_multiThrowMethod(::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_multiThrowMethod(state);
}

void ServiceAAsyncClient::i32ThrowMethod(std::unique_ptr<apache::thrift::RequestCallback> callback, int32_t i32Arg) {
  ::apache::thrift::RpcOptions rpcOptions;
  i32ThrowMethodImpl(false, rpcOptions, std::move(callback), i32Arg);
}

void ServiceAAsyncClient::i32ThrowMethod(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, int32_t i32Arg) {
  i32ThrowMethodImpl(false, rpcOptions, std::move(callback), i32Arg);
}

void ServiceAAsyncClient::i32ThrowMethodImpl(bool useSync, apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, int32_t i32Arg) {
  switch(getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      i32ThrowMethodT(&writer, useSync, rpcOptions, std::move(callback), i32Arg);
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      i32ThrowMethodT(&writer, useSync, rpcOptions, std::move(callback), i32Arg);
      break;
    }
    case apache::thrift::protocol::T_FROZEN2_PROTOCOL:
    {
      apache::thrift::Frozen2ProtocolWriter writer;
      i32ThrowMethodT(&writer, useSync, rpcOptions, std::move(callback), i32Arg);
      break;
    }
    default:
    {
      apache::thrift::detail::ac::throw_app_exn("Could not find Protocol");
    }
  }
}

void ServiceAAsyncClient::sync_i32ThrowMethod(int32_t i32Arg) {
  ::apache::thrift::RpcOptions rpcOptions;
  sync_i32ThrowMethod(rpcOptions, i32Arg);
}

void ServiceAAsyncClient::sync_i32ThrowMethod(apache::thrift::RpcOptions& rpcOptions, int32_t i32Arg) {
  apache::thrift::ClientReceiveState _returnState;
  auto callback = std::make_unique<apache::thrift::ClientSyncCallback>(
      &_returnState, apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE);
  i32ThrowMethodImpl(true, rpcOptions, std::move(callback), i32Arg);
  SCOPE_EXIT {
    if (_returnState.header() && !_returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(_returnState.header()->releaseHeaders());
    }
  };
  if (!_returnState.buf()) {
    assert(!!_returnState.exception());
    _returnState.exception().throw_exception();
  }
  recv_i32ThrowMethod(_returnState);
}

folly::Future<folly::Unit> ServiceAAsyncClient::future_i32ThrowMethod(int32_t i32Arg) {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_i32ThrowMethod(rpcOptions, i32Arg);
}

folly::SemiFuture<folly::Unit> ServiceAAsyncClient::semifuture_i32ThrowMethod(int32_t i32Arg) {
  ::apache::thrift::RpcOptions rpcOptions;
  return semifuture_i32ThrowMethod(rpcOptions, i32Arg);
}

folly::Future<folly::Unit> ServiceAAsyncClient::future_i32ThrowMethod(apache::thrift::RpcOptions& rpcOptions, int32_t i32Arg) {
  folly::Promise<folly::Unit> _promise;
  auto _future = _promise.getFuture();
  auto callback = std::make_unique<apache::thrift::FutureCallback<folly::Unit>>(std::move(_promise), recv_wrapped_i32ThrowMethod, channel_);
  i32ThrowMethod(rpcOptions, std::move(callback), i32Arg);
  return _future;
}

folly::SemiFuture<folly::Unit> ServiceAAsyncClient::semifuture_i32ThrowMethod(apache::thrift::RpcOptions& rpcOptions, int32_t i32Arg) {
  auto callbackAndFuture = makeSemiFutureCallback(recv_wrapped_i32ThrowMethod, channel_);
  auto callback = std::move(callbackAndFuture.first);
  i32ThrowMethod(rpcOptions, std::move(callback), i32Arg);
  return std::move(callbackAndFuture.second);
}

folly::Future<std::pair<folly::Unit, std::unique_ptr<apache::thrift::transport::THeader>>> ServiceAAsyncClient::header_future_i32ThrowMethod(apache::thrift::RpcOptions& rpcOptions, int32_t i32Arg) {
  folly::Promise<std::pair<folly::Unit, std::unique_ptr<apache::thrift::transport::THeader>>> _promise;
  auto _future = _promise.getFuture();
  auto callback = std::make_unique<apache::thrift::HeaderFutureCallback<folly::Unit>>(std::move(_promise), recv_wrapped_i32ThrowMethod, channel_);
  i32ThrowMethod(rpcOptions, std::move(callback), i32Arg);
  return _future;
}

folly::SemiFuture<std::pair<folly::Unit, std::unique_ptr<apache::thrift::transport::THeader>>> ServiceAAsyncClient::header_semifuture_i32ThrowMethod(apache::thrift::RpcOptions& rpcOptions, int32_t i32Arg) {
  auto callbackAndFuture = makeHeaderSemiFutureCallback(recv_wrapped_i32ThrowMethod, channel_);
  auto callback = std::move(callbackAndFuture.first);
  i32ThrowMethod(rpcOptions, std::move(callback), i32Arg);
  return std::move(callbackAndFuture.second);
}

void ServiceAAsyncClient::i32ThrowMethod(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, int32_t i32Arg) {
  i32ThrowMethod(std::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)), i32Arg);
}

folly::exception_wrapper ServiceAAsyncClient::recv_wrapped_i32ThrowMethod(::apache::thrift::ClientReceiveState& state) {
  if (state.isException()) {
    return std::move(state.exception());
  }
  if (!state.buf()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }

  using result = ServiceA_i32ThrowMethod_presult;
  constexpr auto const fname = "i32ThrowMethod";
  switch (state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state);
    }
    case apache::thrift::protocol::T_FROZEN2_PROTOCOL:
    {
      apache::thrift::Frozen2ProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

void ServiceAAsyncClient::recv_i32ThrowMethod(::apache::thrift::ClientReceiveState& state) {
  auto ew = recv_wrapped_i32ThrowMethod(state);
  if (ew) {
    ew.throw_exception();
  }
}

void ServiceAAsyncClient::recv_instance_i32ThrowMethod(::apache::thrift::ClientReceiveState& state) {
  recv_i32ThrowMethod(state);
}

folly::exception_wrapper ServiceAAsyncClient::recv_instance_wrapped_i32ThrowMethod(::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_i32ThrowMethod(state);
}

void ServiceAAsyncClient::moduleAThrowMethod(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::some::ns::ModuleA& modArg) {
  ::apache::thrift::RpcOptions rpcOptions;
  moduleAThrowMethodImpl(false, rpcOptions, std::move(callback), modArg);
}

void ServiceAAsyncClient::moduleAThrowMethod(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::some::ns::ModuleA& modArg) {
  moduleAThrowMethodImpl(false, rpcOptions, std::move(callback), modArg);
}

void ServiceAAsyncClient::moduleAThrowMethodImpl(bool useSync, apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::some::ns::ModuleA& modArg) {
  switch(getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      moduleAThrowMethodT(&writer, useSync, rpcOptions, std::move(callback), modArg);
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      moduleAThrowMethodT(&writer, useSync, rpcOptions, std::move(callback), modArg);
      break;
    }
    case apache::thrift::protocol::T_FROZEN2_PROTOCOL:
    {
      apache::thrift::Frozen2ProtocolWriter writer;
      moduleAThrowMethodT(&writer, useSync, rpcOptions, std::move(callback), modArg);
      break;
    }
    default:
    {
      apache::thrift::detail::ac::throw_app_exn("Could not find Protocol");
    }
  }
}

void ServiceAAsyncClient::sync_moduleAThrowMethod(const  ::some::ns::ModuleA& modArg) {
  ::apache::thrift::RpcOptions rpcOptions;
  sync_moduleAThrowMethod(rpcOptions, modArg);
}

void ServiceAAsyncClient::sync_moduleAThrowMethod(apache::thrift::RpcOptions& rpcOptions, const  ::some::ns::ModuleA& modArg) {
  apache::thrift::ClientReceiveState _returnState;
  auto callback = std::make_unique<apache::thrift::ClientSyncCallback>(
      &_returnState, apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE);
  moduleAThrowMethodImpl(true, rpcOptions, std::move(callback), modArg);
  SCOPE_EXIT {
    if (_returnState.header() && !_returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(_returnState.header()->releaseHeaders());
    }
  };
  if (!_returnState.buf()) {
    assert(!!_returnState.exception());
    _returnState.exception().throw_exception();
  }
  recv_moduleAThrowMethod(_returnState);
}

folly::Future<folly::Unit> ServiceAAsyncClient::future_moduleAThrowMethod(const  ::some::ns::ModuleA& modArg) {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_moduleAThrowMethod(rpcOptions, modArg);
}

folly::SemiFuture<folly::Unit> ServiceAAsyncClient::semifuture_moduleAThrowMethod(const  ::some::ns::ModuleA& modArg) {
  ::apache::thrift::RpcOptions rpcOptions;
  return semifuture_moduleAThrowMethod(rpcOptions, modArg);
}

folly::Future<folly::Unit> ServiceAAsyncClient::future_moduleAThrowMethod(apache::thrift::RpcOptions& rpcOptions, const  ::some::ns::ModuleA& modArg) {
  folly::Promise<folly::Unit> _promise;
  auto _future = _promise.getFuture();
  auto callback = std::make_unique<apache::thrift::FutureCallback<folly::Unit>>(std::move(_promise), recv_wrapped_moduleAThrowMethod, channel_);
  moduleAThrowMethod(rpcOptions, std::move(callback), modArg);
  return _future;
}

folly::SemiFuture<folly::Unit> ServiceAAsyncClient::semifuture_moduleAThrowMethod(apache::thrift::RpcOptions& rpcOptions, const  ::some::ns::ModuleA& modArg) {
  auto callbackAndFuture = makeSemiFutureCallback(recv_wrapped_moduleAThrowMethod, channel_);
  auto callback = std::move(callbackAndFuture.first);
  moduleAThrowMethod(rpcOptions, std::move(callback), modArg);
  return std::move(callbackAndFuture.second);
}

folly::Future<std::pair<folly::Unit, std::unique_ptr<apache::thrift::transport::THeader>>> ServiceAAsyncClient::header_future_moduleAThrowMethod(apache::thrift::RpcOptions& rpcOptions, const  ::some::ns::ModuleA& modArg) {
  folly::Promise<std::pair<folly::Unit, std::unique_ptr<apache::thrift::transport::THeader>>> _promise;
  auto _future = _promise.getFuture();
  auto callback = std::make_unique<apache::thrift::HeaderFutureCallback<folly::Unit>>(std::move(_promise), recv_wrapped_moduleAThrowMethod, channel_);
  moduleAThrowMethod(rpcOptions, std::move(callback), modArg);
  return _future;
}

folly::SemiFuture<std::pair<folly::Unit, std::unique_ptr<apache::thrift::transport::THeader>>> ServiceAAsyncClient::header_semifuture_moduleAThrowMethod(apache::thrift::RpcOptions& rpcOptions, const  ::some::ns::ModuleA& modArg) {
  auto callbackAndFuture = makeHeaderSemiFutureCallback(recv_wrapped_moduleAThrowMethod, channel_);
  auto callback = std::move(callbackAndFuture.first);
  moduleAThrowMethod(rpcOptions, std::move(callback), modArg);
  return std::move(callbackAndFuture.second);
}

void ServiceAAsyncClient::moduleAThrowMethod(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::some::ns::ModuleA& modArg) {
  moduleAThrowMethod(std::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)), modArg);
}

folly::exception_wrapper ServiceAAsyncClient::recv_wrapped_moduleAThrowMethod(::apache::thrift::ClientReceiveState& state) {
  if (state.isException()) {
    return std::move(state.exception());
  }
  if (!state.buf()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }

  using result = ServiceA_moduleAThrowMethod_presult;
  constexpr auto const fname = "moduleAThrowMethod";
  switch (state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state);
    }
    case apache::thrift::protocol::T_FROZEN2_PROTOCOL:
    {
      apache::thrift::Frozen2ProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

void ServiceAAsyncClient::recv_moduleAThrowMethod(::apache::thrift::ClientReceiveState& state) {
  auto ew = recv_wrapped_moduleAThrowMethod(state);
  if (ew) {
    ew.throw_exception();
  }
}

void ServiceAAsyncClient::recv_instance_moduleAThrowMethod(::apache::thrift::ClientReceiveState& state) {
  recv_moduleAThrowMethod(state);
}

folly::exception_wrapper ServiceAAsyncClient::recv_instance_wrapped_moduleAThrowMethod(::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_moduleAThrowMethod(state);
}

void ServiceAAsyncClient::mixedMethod(std::unique_ptr<apache::thrift::RequestCallback> callback, const std::string& strArg, int32_t i32Arg, const  ::some::ns::ModuleB& modArg) {
  ::apache::thrift::RpcOptions rpcOptions;
  mixedMethodImpl(false, rpcOptions, std::move(callback), strArg, i32Arg, modArg);
}

void ServiceAAsyncClient::mixedMethod(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const std::string& strArg, int32_t i32Arg, const  ::some::ns::ModuleB& modArg) {
  mixedMethodImpl(false, rpcOptions, std::move(callback), strArg, i32Arg, modArg);
}

void ServiceAAsyncClient::mixedMethodImpl(bool useSync, apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const std::string& strArg, int32_t i32Arg, const  ::some::ns::ModuleB& modArg) {
  switch(getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      mixedMethodT(&writer, useSync, rpcOptions, std::move(callback), strArg, i32Arg, modArg);
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      mixedMethodT(&writer, useSync, rpcOptions, std::move(callback), strArg, i32Arg, modArg);
      break;
    }
    case apache::thrift::protocol::T_FROZEN2_PROTOCOL:
    {
      apache::thrift::Frozen2ProtocolWriter writer;
      mixedMethodT(&writer, useSync, rpcOptions, std::move(callback), strArg, i32Arg, modArg);
      break;
    }
    default:
    {
      apache::thrift::detail::ac::throw_app_exn("Could not find Protocol");
    }
  }
}

void ServiceAAsyncClient::sync_mixedMethod(std::string& _return, const std::string& strArg, int32_t i32Arg, const  ::some::ns::ModuleB& modArg) {
  ::apache::thrift::RpcOptions rpcOptions;
  sync_mixedMethod(rpcOptions, _return, strArg, i32Arg, modArg);
}

void ServiceAAsyncClient::sync_mixedMethod(apache::thrift::RpcOptions& rpcOptions, std::string& _return, const std::string& strArg, int32_t i32Arg, const  ::some::ns::ModuleB& modArg) {
  apache::thrift::ClientReceiveState _returnState;
  auto callback = std::make_unique<apache::thrift::ClientSyncCallback>(
      &_returnState, apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE);
  mixedMethodImpl(true, rpcOptions, std::move(callback), strArg, i32Arg, modArg);
  SCOPE_EXIT {
    if (_returnState.header() && !_returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(_returnState.header()->releaseHeaders());
    }
  };
  if (!_returnState.buf()) {
    assert(!!_returnState.exception());
    _returnState.exception().throw_exception();
  }
  recv_mixedMethod(_return, _returnState);
}

folly::Future<std::string> ServiceAAsyncClient::future_mixedMethod(const std::string& strArg, int32_t i32Arg, const  ::some::ns::ModuleB& modArg) {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_mixedMethod(rpcOptions, strArg, i32Arg, modArg);
}

folly::SemiFuture<std::string> ServiceAAsyncClient::semifuture_mixedMethod(const std::string& strArg, int32_t i32Arg, const  ::some::ns::ModuleB& modArg) {
  ::apache::thrift::RpcOptions rpcOptions;
  return semifuture_mixedMethod(rpcOptions, strArg, i32Arg, modArg);
}

folly::Future<std::string> ServiceAAsyncClient::future_mixedMethod(apache::thrift::RpcOptions& rpcOptions, const std::string& strArg, int32_t i32Arg, const  ::some::ns::ModuleB& modArg) {
  folly::Promise<std::string> _promise;
  auto _future = _promise.getFuture();
  auto callback = std::make_unique<apache::thrift::FutureCallback<std::string>>(std::move(_promise), recv_wrapped_mixedMethod, channel_);
  mixedMethod(rpcOptions, std::move(callback), strArg, i32Arg, modArg);
  return _future;
}

folly::SemiFuture<std::string> ServiceAAsyncClient::semifuture_mixedMethod(apache::thrift::RpcOptions& rpcOptions, const std::string& strArg, int32_t i32Arg, const  ::some::ns::ModuleB& modArg) {
  auto callbackAndFuture = makeSemiFutureCallback(recv_wrapped_mixedMethod, channel_);
  auto callback = std::move(callbackAndFuture.first);
  mixedMethod(rpcOptions, std::move(callback), strArg, i32Arg, modArg);
  return std::move(callbackAndFuture.second);
}

folly::Future<std::pair<std::string, std::unique_ptr<apache::thrift::transport::THeader>>> ServiceAAsyncClient::header_future_mixedMethod(apache::thrift::RpcOptions& rpcOptions, const std::string& strArg, int32_t i32Arg, const  ::some::ns::ModuleB& modArg) {
  folly::Promise<std::pair<std::string, std::unique_ptr<apache::thrift::transport::THeader>>> _promise;
  auto _future = _promise.getFuture();
  auto callback = std::make_unique<apache::thrift::HeaderFutureCallback<std::string>>(std::move(_promise), recv_wrapped_mixedMethod, channel_);
  mixedMethod(rpcOptions, std::move(callback), strArg, i32Arg, modArg);
  return _future;
}

folly::SemiFuture<std::pair<std::string, std::unique_ptr<apache::thrift::transport::THeader>>> ServiceAAsyncClient::header_semifuture_mixedMethod(apache::thrift::RpcOptions& rpcOptions, const std::string& strArg, int32_t i32Arg, const  ::some::ns::ModuleB& modArg) {
  auto callbackAndFuture = makeHeaderSemiFutureCallback(recv_wrapped_mixedMethod, channel_);
  auto callback = std::move(callbackAndFuture.first);
  mixedMethod(rpcOptions, std::move(callback), strArg, i32Arg, modArg);
  return std::move(callbackAndFuture.second);
}

void ServiceAAsyncClient::mixedMethod(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const std::string& strArg, int32_t i32Arg, const  ::some::ns::ModuleB& modArg) {
  mixedMethod(std::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)), strArg, i32Arg, modArg);
}

folly::exception_wrapper ServiceAAsyncClient::recv_wrapped_mixedMethod(std::string& _return, ::apache::thrift::ClientReceiveState& state) {
  if (state.isException()) {
    return std::move(state.exception());
  }
  if (!state.buf()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }

  using result = ServiceA_mixedMethod_presult;
  constexpr auto const fname = "mixedMethod";
  switch (state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    case apache::thrift::protocol::T_FROZEN2_PROTOCOL:
    {
      apache::thrift::Frozen2ProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          fname, &reader, state, _return);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

void ServiceAAsyncClient::recv_mixedMethod(std::string& _return, ::apache::thrift::ClientReceiveState& state) {
  auto ew = recv_wrapped_mixedMethod(_return, state);
  if (ew) {
    ew.throw_exception();
  }
}

void ServiceAAsyncClient::recv_instance_mixedMethod(std::string& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_mixedMethod(_return, state);
}

folly::exception_wrapper ServiceAAsyncClient::recv_instance_wrapped_mixedMethod(std::string& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_mixedMethod(_return, state);
}

}} // some::ns
namespace apache { namespace thrift {

}} // apache::thrift
